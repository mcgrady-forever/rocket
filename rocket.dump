
rocket:     file format elf64-x86-64


Disassembly of section .init:

0000000000403a30 <_init>:
  403a30:	48 83 ec 08          	sub    $0x8,%rsp
  403a34:	e8 83 0d 00 00       	callq  4047bc <call_gmon_start>
  403a39:	48 83 c4 08          	add    $0x8,%rsp
  403a3d:	c3                   	retq   

Disassembly of section .plt:

0000000000403a40 <_ZNSs6appendEPKcm@plt-0x10>:
  403a40:	ff 35 aa 05 21 00    	pushq  0x2105aa(%rip)        # 613ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
  403a46:	ff 25 ac 05 21 00    	jmpq   *0x2105ac(%rip)        # 613ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
  403a4c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403a50 <_ZNSs6appendEPKcm@plt>:
  403a50:	ff 25 aa 05 21 00    	jmpq   *0x2105aa(%rip)        # 614000 <_GLOBAL_OFFSET_TABLE_+0x18>
  403a56:	68 00 00 00 00       	pushq  $0x0
  403a5b:	e9 e0 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403a60 <_ZNKSs16find_last_not_ofEPKcmm@plt>:
  403a60:	ff 25 a2 05 21 00    	jmpq   *0x2105a2(%rip)        # 614008 <_GLOBAL_OFFSET_TABLE_+0x20>
  403a66:	68 01 00 00 00       	pushq  $0x1
  403a6b:	e9 d0 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403a70 <_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RSbIS4_S5_T1_ES4_@plt>:
  403a70:	ff 25 9a 05 21 00    	jmpq   *0x21059a(%rip)        # 614010 <_GLOBAL_OFFSET_TABLE_+0x28>
  403a76:	68 02 00 00 00       	pushq  $0x2
  403a7b:	e9 c0 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403a80 <dup2@plt>:
  403a80:	ff 25 92 05 21 00    	jmpq   *0x210592(%rip)        # 614018 <_GLOBAL_OFFSET_TABLE_+0x30>
  403a86:	68 03 00 00 00       	pushq  $0x3
  403a8b:	e9 b0 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403a90 <pthread_cond_destroy@plt>:
  403a90:	ff 25 8a 05 21 00    	jmpq   *0x21058a(%rip)        # 614020 <_GLOBAL_OFFSET_TABLE_+0x38>
  403a96:	68 04 00 00 00       	pushq  $0x4
  403a9b:	e9 a0 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403aa0 <_ZNSolsEi@plt>:
  403aa0:	ff 25 82 05 21 00    	jmpq   *0x210582(%rip)        # 614028 <_GLOBAL_OFFSET_TABLE_+0x40>
  403aa6:	68 05 00 00 00       	pushq  $0x5
  403aab:	e9 90 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ab0 <_ZNSi10_M_extractImEERSiRT_@plt>:
  403ab0:	ff 25 7a 05 21 00    	jmpq   *0x21057a(%rip)        # 614030 <_GLOBAL_OFFSET_TABLE_+0x48>
  403ab6:	68 06 00 00 00       	pushq  $0x6
  403abb:	e9 80 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ac0 <memset@plt>:
  403ac0:	ff 25 72 05 21 00    	jmpq   *0x210572(%rip)        # 614038 <_GLOBAL_OFFSET_TABLE_+0x50>
  403ac6:	68 07 00 00 00       	pushq  $0x7
  403acb:	e9 70 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ad0 <setsid@plt>:
  403ad0:	ff 25 6a 05 21 00    	jmpq   *0x21056a(%rip)        # 614040 <_GLOBAL_OFFSET_TABLE_+0x58>
  403ad6:	68 08 00 00 00       	pushq  $0x8
  403adb:	e9 60 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ae0 <_ZSt16__throw_bad_castv@plt>:
  403ae0:	ff 25 62 05 21 00    	jmpq   *0x210562(%rip)        # 614048 <_GLOBAL_OFFSET_TABLE_+0x60>
  403ae6:	68 09 00 00 00       	pushq  $0x9
  403aeb:	e9 50 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>:
  403af0:	ff 25 5a 05 21 00    	jmpq   *0x21055a(%rip)        # 614050 <_GLOBAL_OFFSET_TABLE_+0x68>
  403af6:	68 0a 00 00 00       	pushq  $0xa
  403afb:	e9 40 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b00 <close@plt>:
  403b00:	ff 25 52 05 21 00    	jmpq   *0x210552(%rip)        # 614058 <_GLOBAL_OFFSET_TABLE_+0x70>
  403b06:	68 0b 00 00 00       	pushq  $0xb
  403b0b:	e9 30 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b10 <_ZNSs9_M_mutateEmmm@plt>:
  403b10:	ff 25 4a 05 21 00    	jmpq   *0x21054a(%rip)        # 614060 <_GLOBAL_OFFSET_TABLE_+0x78>
  403b16:	68 0c 00 00 00       	pushq  $0xc
  403b1b:	e9 20 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b20 <_ZNSt8ios_baseC2Ev@plt>:
  403b20:	ff 25 42 05 21 00    	jmpq   *0x210542(%rip)        # 614068 <_GLOBAL_OFFSET_TABLE_+0x80>
  403b26:	68 0d 00 00 00       	pushq  $0xd
  403b2b:	e9 10 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b30 <_ZNSi10_M_extractIjEERSiRT_@plt>:
  403b30:	ff 25 3a 05 21 00    	jmpq   *0x21053a(%rip)        # 614070 <_GLOBAL_OFFSET_TABLE_+0x88>
  403b36:	68 0e 00 00 00       	pushq  $0xe
  403b3b:	e9 00 ff ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b40 <__cxa_guard_acquire@plt>:
  403b40:	ff 25 32 05 21 00    	jmpq   *0x210532(%rip)        # 614078 <_GLOBAL_OFFSET_TABLE_+0x90>
  403b46:	68 0f 00 00 00       	pushq  $0xf
  403b4b:	e9 f0 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b50 <_ZNSsC1EPKcmRKSaIcE@plt>:
  403b50:	ff 25 2a 05 21 00    	jmpq   *0x21052a(%rip)        # 614080 <_GLOBAL_OFFSET_TABLE_+0x98>
  403b56:	68 10 00 00 00       	pushq  $0x10
  403b5b:	e9 e0 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b60 <__fprintf_chk@plt>:
  403b60:	ff 25 22 05 21 00    	jmpq   *0x210522(%rip)        # 614088 <_GLOBAL_OFFSET_TABLE_+0xa0>
  403b66:	68 11 00 00 00       	pushq  $0x11
  403b6b:	e9 d0 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b70 <epoll_create@plt>:
  403b70:	ff 25 1a 05 21 00    	jmpq   *0x21051a(%rip)        # 614090 <_GLOBAL_OFFSET_TABLE_+0xa8>
  403b76:	68 12 00 00 00       	pushq  $0x12
  403b7b:	e9 c0 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b80 <gethostbyname@plt>:
  403b80:	ff 25 12 05 21 00    	jmpq   *0x210512(%rip)        # 614098 <_GLOBAL_OFFSET_TABLE_+0xb0>
  403b86:	68 13 00 00 00       	pushq  $0x13
  403b8b:	e9 b0 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403b90 <_Znam@plt>:
  403b90:	ff 25 0a 05 21 00    	jmpq   *0x21050a(%rip)        # 6140a0 <_GLOBAL_OFFSET_TABLE_+0xb8>
  403b96:	68 14 00 00 00       	pushq  $0x14
  403b9b:	e9 a0 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ba0 <pthread_cond_signal@plt>:
  403ba0:	ff 25 02 05 21 00    	jmpq   *0x210502(%rip)        # 6140a8 <_GLOBAL_OFFSET_TABLE_+0xc0>
  403ba6:	68 15 00 00 00       	pushq  $0x15
  403bab:	e9 90 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403bb0 <_ZdlPv@plt>:
  403bb0:	ff 25 fa 04 21 00    	jmpq   *0x2104fa(%rip)        # 6140b0 <_GLOBAL_OFFSET_TABLE_+0xc8>
  403bb6:	68 16 00 00 00       	pushq  $0x16
  403bbb:	e9 80 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403bc0 <select@plt>:
  403bc0:	ff 25 f2 04 21 00    	jmpq   *0x2104f2(%rip)        # 6140b8 <_GLOBAL_OFFSET_TABLE_+0xd0>
  403bc6:	68 17 00 00 00       	pushq  $0x17
  403bcb:	e9 70 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403bd0 <exit@plt>:
  403bd0:	ff 25 ea 04 21 00    	jmpq   *0x2104ea(%rip)        # 6140c0 <_GLOBAL_OFFSET_TABLE_+0xd8>
  403bd6:	68 18 00 00 00       	pushq  $0x18
  403bdb:	e9 60 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403be0 <__assert_fail@plt>:
  403be0:	ff 25 e2 04 21 00    	jmpq   *0x2104e2(%rip)        # 6140c8 <_GLOBAL_OFFSET_TABLE_+0xe0>
  403be6:	68 19 00 00 00       	pushq  $0x19
  403beb:	e9 50 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>:
  403bf0:	ff 25 da 04 21 00    	jmpq   *0x2104da(%rip)        # 6140d0 <_GLOBAL_OFFSET_TABLE_+0xe8>
  403bf6:	68 1a 00 00 00       	pushq  $0x1a
  403bfb:	e9 40 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c00 <__printf_chk@plt>:
  403c00:	ff 25 d2 04 21 00    	jmpq   *0x2104d2(%rip)        # 6140d8 <_GLOBAL_OFFSET_TABLE_+0xf0>
  403c06:	68 1b 00 00 00       	pushq  $0x1b
  403c0b:	e9 30 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c10 <strcasecmp@plt>:
  403c10:	ff 25 ca 04 21 00    	jmpq   *0x2104ca(%rip)        # 6140e0 <_GLOBAL_OFFSET_TABLE_+0xf8>
  403c16:	68 1c 00 00 00       	pushq  $0x1c
  403c1b:	e9 20 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c20 <__cxa_rethrow@plt>:
  403c20:	ff 25 c2 04 21 00    	jmpq   *0x2104c2(%rip)        # 6140e8 <_GLOBAL_OFFSET_TABLE_+0x100>
  403c26:	68 1d 00 00 00       	pushq  $0x1d
  403c2b:	e9 10 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c30 <_ZNSt8ios_base4InitC1Ev@plt>:
  403c30:	ff 25 ba 04 21 00    	jmpq   *0x2104ba(%rip)        # 6140f0 <_GLOBAL_OFFSET_TABLE_+0x108>
  403c36:	68 1e 00 00 00       	pushq  $0x1e
  403c3b:	e9 00 fe ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c40 <read@plt>:
  403c40:	ff 25 b2 04 21 00    	jmpq   *0x2104b2(%rip)        # 6140f8 <_GLOBAL_OFFSET_TABLE_+0x110>
  403c46:	68 1f 00 00 00       	pushq  $0x1f
  403c4b:	e9 f0 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c50 <malloc@plt>:
  403c50:	ff 25 aa 04 21 00    	jmpq   *0x2104aa(%rip)        # 614100 <_GLOBAL_OFFSET_TABLE_+0x118>
  403c56:	68 20 00 00 00       	pushq  $0x20
  403c5b:	e9 e0 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c60 <fopen@plt>:
  403c60:	ff 25 a2 04 21 00    	jmpq   *0x2104a2(%rip)        # 614108 <_GLOBAL_OFFSET_TABLE_+0x120>
  403c66:	68 21 00 00 00       	pushq  $0x21
  403c6b:	e9 d0 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c70 <__libc_start_main@plt>:
  403c70:	ff 25 9a 04 21 00    	jmpq   *0x21049a(%rip)        # 614110 <_GLOBAL_OFFSET_TABLE_+0x128>
  403c76:	68 22 00 00 00       	pushq  $0x22
  403c7b:	e9 c0 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c80 <_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base@plt>:
  403c80:	ff 25 92 04 21 00    	jmpq   *0x210492(%rip)        # 614118 <_GLOBAL_OFFSET_TABLE_+0x130>
  403c86:	68 23 00 00 00       	pushq  $0x23
  403c8b:	e9 b0 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403c90 <_exit@plt>:
  403c90:	ff 25 8a 04 21 00    	jmpq   *0x21048a(%rip)        # 614120 <_GLOBAL_OFFSET_TABLE_+0x138>
  403c96:	68 24 00 00 00       	pushq  $0x24
  403c9b:	e9 a0 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ca0 <pthread_cond_timedwait@plt>:
  403ca0:	ff 25 82 04 21 00    	jmpq   *0x210482(%rip)        # 614128 <_GLOBAL_OFFSET_TABLE_+0x140>
  403ca6:	68 25 00 00 00       	pushq  $0x25
  403cab:	e9 90 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403cb0 <__memcpy_chk@plt>:
  403cb0:	ff 25 7a 04 21 00    	jmpq   *0x21047a(%rip)        # 614130 <_GLOBAL_OFFSET_TABLE_+0x148>
  403cb6:	68 26 00 00 00       	pushq  $0x26
  403cbb:	e9 80 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403cc0 <_ZNSsC1ERKSs@plt>:
  403cc0:	ff 25 72 04 21 00    	jmpq   *0x210472(%rip)        # 614138 <_GLOBAL_OFFSET_TABLE_+0x150>
  403cc6:	68 27 00 00 00       	pushq  $0x27
  403ccb:	e9 70 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403cd0 <__cxa_atexit@plt>:
  403cd0:	ff 25 6a 04 21 00    	jmpq   *0x21046a(%rip)        # 614140 <_GLOBAL_OFFSET_TABLE_+0x158>
  403cd6:	68 28 00 00 00       	pushq  $0x28
  403cdb:	e9 60 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ce0 <_ZNSt13basic_filebufIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode@plt>:
  403ce0:	ff 25 62 04 21 00    	jmpq   *0x210462(%rip)        # 614148 <_GLOBAL_OFFSET_TABLE_+0x160>
  403ce6:	68 29 00 00 00       	pushq  $0x29
  403ceb:	e9 50 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403cf0 <setsockopt@plt>:
  403cf0:	ff 25 5a 04 21 00    	jmpq   *0x21045a(%rip)        # 614150 <_GLOBAL_OFFSET_TABLE_+0x168>
  403cf6:	68 2a 00 00 00       	pushq  $0x2a
  403cfb:	e9 40 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d00 <getpid@plt>:
  403d00:	ff 25 52 04 21 00    	jmpq   *0x210452(%rip)        # 614158 <_GLOBAL_OFFSET_TABLE_+0x170>
  403d06:	68 2b 00 00 00       	pushq  $0x2b
  403d0b:	e9 30 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d10 <pthread_mutex_init@plt>:
  403d10:	ff 25 4a 04 21 00    	jmpq   *0x21044a(%rip)        # 614160 <_GLOBAL_OFFSET_TABLE_+0x178>
  403d16:	68 2c 00 00 00       	pushq  $0x2c
  403d1b:	e9 20 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d20 <__vsnprintf_chk@plt>:
  403d20:	ff 25 42 04 21 00    	jmpq   *0x210442(%rip)        # 614168 <_GLOBAL_OFFSET_TABLE_+0x180>
  403d26:	68 2d 00 00 00       	pushq  $0x2d
  403d2b:	e9 10 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d30 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>:
  403d30:	ff 25 3a 04 21 00    	jmpq   *0x21043a(%rip)        # 614170 <_GLOBAL_OFFSET_TABLE_+0x188>
  403d36:	68 2e 00 00 00       	pushq  $0x2e
  403d3b:	e9 00 fd ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d40 <free@plt>:
  403d40:	ff 25 32 04 21 00    	jmpq   *0x210432(%rip)        # 614178 <_GLOBAL_OFFSET_TABLE_+0x190>
  403d46:	68 2f 00 00 00       	pushq  $0x2f
  403d4b:	e9 f0 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d50 <_ZNKSs17find_first_not_ofEPKcmm@plt>:
  403d50:	ff 25 2a 04 21 00    	jmpq   *0x21042a(%rip)        # 614180 <_GLOBAL_OFFSET_TABLE_+0x198>
  403d56:	68 30 00 00 00       	pushq  $0x30
  403d5b:	e9 e0 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d60 <strlen@plt>:
  403d60:	ff 25 22 04 21 00    	jmpq   *0x210422(%rip)        # 614188 <_GLOBAL_OFFSET_TABLE_+0x1a0>
  403d66:	68 31 00 00 00       	pushq  $0x31
  403d6b:	e9 d0 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>:
  403d70:	ff 25 1a 04 21 00    	jmpq   *0x21041a(%rip)        # 614190 <_GLOBAL_OFFSET_TABLE_+0x1a8>
  403d76:	68 32 00 00 00       	pushq  $0x32
  403d7b:	e9 c0 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d80 <pthread_create@plt>:
  403d80:	ff 25 12 04 21 00    	jmpq   *0x210412(%rip)        # 614198 <_GLOBAL_OFFSET_TABLE_+0x1b0>
  403d86:	68 33 00 00 00       	pushq  $0x33
  403d8b:	e9 b0 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403d90 <pthread_cond_init@plt>:
  403d90:	ff 25 0a 04 21 00    	jmpq   *0x21040a(%rip)        # 6141a0 <_GLOBAL_OFFSET_TABLE_+0x1b8>
  403d96:	68 34 00 00 00       	pushq  $0x34
  403d9b:	e9 a0 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403da0 <listen@plt>:
  403da0:	ff 25 02 04 21 00    	jmpq   *0x210402(%rip)        # 6141a8 <_GLOBAL_OFFSET_TABLE_+0x1c0>
  403da6:	68 35 00 00 00       	pushq  $0x35
  403dab:	e9 90 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403db0 <_ZNKSs13find_first_ofEPKcmm@plt>:
  403db0:	ff 25 fa 03 21 00    	jmpq   *0x2103fa(%rip)        # 6141b0 <_GLOBAL_OFFSET_TABLE_+0x1c8>
  403db6:	68 36 00 00 00       	pushq  $0x36
  403dbb:	e9 80 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403dc0 <__cxa_guard_release@plt>:
  403dc0:	ff 25 f2 03 21 00    	jmpq   *0x2103f2(%rip)        # 6141b8 <_GLOBAL_OFFSET_TABLE_+0x1d0>
  403dc6:	68 37 00 00 00       	pushq  $0x37
  403dcb:	e9 70 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403dd0 <dlerror@plt>:
  403dd0:	ff 25 ea 03 21 00    	jmpq   *0x2103ea(%rip)        # 6141c0 <_GLOBAL_OFFSET_TABLE_+0x1d8>
  403dd6:	68 38 00 00 00       	pushq  $0x38
  403ddb:	e9 60 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403de0 <strrchr@plt>:
  403de0:	ff 25 e2 03 21 00    	jmpq   *0x2103e2(%rip)        # 6141c8 <_GLOBAL_OFFSET_TABLE_+0x1e0>
  403de6:	68 39 00 00 00       	pushq  $0x39
  403deb:	e9 50 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403df0 <dlclose@plt>:
  403df0:	ff 25 da 03 21 00    	jmpq   *0x2103da(%rip)        # 6141d0 <_GLOBAL_OFFSET_TABLE_+0x1e8>
  403df6:	68 3a 00 00 00       	pushq  $0x3a
  403dfb:	e9 40 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e00 <_ZNKSs4findEcm@plt>:
  403e00:	ff 25 d2 03 21 00    	jmpq   *0x2103d2(%rip)        # 6141d8 <_GLOBAL_OFFSET_TABLE_+0x1f0>
  403e06:	68 3b 00 00 00       	pushq  $0x3b
  403e0b:	e9 30 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e10 <_ZNKSs7compareEPKc@plt>:
  403e10:	ff 25 ca 03 21 00    	jmpq   *0x2103ca(%rip)        # 6141e0 <_GLOBAL_OFFSET_TABLE_+0x1f8>
  403e16:	68 3c 00 00 00       	pushq  $0x3c
  403e1b:	e9 20 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e20 <_ZNSsC1EPKcRKSaIcE@plt>:
  403e20:	ff 25 c2 03 21 00    	jmpq   *0x2103c2(%rip)        # 6141e8 <_GLOBAL_OFFSET_TABLE_+0x200>
  403e26:	68 3d 00 00 00       	pushq  $0x3d
  403e2b:	e9 10 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e30 <usleep@plt>:
  403e30:	ff 25 ba 03 21 00    	jmpq   *0x2103ba(%rip)        # 6141f0 <_GLOBAL_OFFSET_TABLE_+0x208>
  403e36:	68 3e 00 00 00       	pushq  $0x3e
  403e3b:	e9 00 fc ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e40 <strerror@plt>:
  403e40:	ff 25 b2 03 21 00    	jmpq   *0x2103b2(%rip)        # 6141f8 <_GLOBAL_OFFSET_TABLE_+0x210>
  403e46:	68 3f 00 00 00       	pushq  $0x3f
  403e4b:	e9 f0 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e50 <epoll_ctl@plt>:
  403e50:	ff 25 aa 03 21 00    	jmpq   *0x2103aa(%rip)        # 614200 <_GLOBAL_OFFSET_TABLE_+0x218>
  403e56:	68 40 00 00 00       	pushq  $0x40
  403e5b:	e9 e0 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e60 <_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev@plt>:
  403e60:	ff 25 a2 03 21 00    	jmpq   *0x2103a2(%rip)        # 614208 <_GLOBAL_OFFSET_TABLE_+0x220>
  403e66:	68 41 00 00 00       	pushq  $0x41
  403e6b:	e9 d0 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e70 <connect@plt>:
  403e70:	ff 25 9a 03 21 00    	jmpq   *0x21039a(%rip)        # 614210 <_GLOBAL_OFFSET_TABLE_+0x228>
  403e76:	68 42 00 00 00       	pushq  $0x42
  403e7b:	e9 c0 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e80 <_ZNSt6localeC1Ev@plt>:
  403e80:	ff 25 92 03 21 00    	jmpq   *0x210392(%rip)        # 614218 <_GLOBAL_OFFSET_TABLE_+0x230>
  403e86:	68 43 00 00 00       	pushq  $0x43
  403e8b:	e9 b0 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403e90 <__cxa_pure_virtual@plt>:
  403e90:	ff 25 8a 03 21 00    	jmpq   *0x21038a(%rip)        # 614220 <_GLOBAL_OFFSET_TABLE_+0x238>
  403e96:	68 44 00 00 00       	pushq  $0x44
  403e9b:	e9 a0 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>:
  403ea0:	ff 25 82 03 21 00    	jmpq   *0x210382(%rip)        # 614228 <_GLOBAL_OFFSET_TABLE_+0x240>
  403ea6:	68 45 00 00 00       	pushq  $0x45
  403eab:	e9 90 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403eb0 <_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@plt>:
  403eb0:	ff 25 7a 03 21 00    	jmpq   *0x21037a(%rip)        # 614230 <_GLOBAL_OFFSET_TABLE_+0x248>
  403eb6:	68 46 00 00 00       	pushq  $0x46
  403ebb:	e9 80 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ec0 <memmove@plt>:
  403ec0:	ff 25 72 03 21 00    	jmpq   *0x210372(%rip)        # 614238 <_GLOBAL_OFFSET_TABLE_+0x250>
  403ec6:	68 47 00 00 00       	pushq  $0x47
  403ecb:	e9 70 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ed0 <getopt_long@plt>:
  403ed0:	ff 25 6a 03 21 00    	jmpq   *0x21036a(%rip)        # 614240 <_GLOBAL_OFFSET_TABLE_+0x258>
  403ed6:	68 48 00 00 00       	pushq  $0x48
  403edb:	e9 60 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ee0 <socket@plt>:
  403ee0:	ff 25 62 03 21 00    	jmpq   *0x210362(%rip)        # 614248 <_GLOBAL_OFFSET_TABLE_+0x260>
  403ee6:	68 49 00 00 00       	pushq  $0x49
  403eeb:	e9 50 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ef0 <inet_ntoa@plt>:
  403ef0:	ff 25 5a 03 21 00    	jmpq   *0x21035a(%rip)        # 614250 <_GLOBAL_OFFSET_TABLE_+0x268>
  403ef6:	68 4a 00 00 00       	pushq  $0x4a
  403efb:	e9 40 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>:
  403f00:	ff 25 52 03 21 00    	jmpq   *0x210352(%rip)        # 614258 <_GLOBAL_OFFSET_TABLE_+0x270>
  403f06:	68 4b 00 00 00       	pushq  $0x4b
  403f0b:	e9 30 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f10 <__errno_location@plt>:
  403f10:	ff 25 4a 03 21 00    	jmpq   *0x21034a(%rip)        # 614260 <_GLOBAL_OFFSET_TABLE_+0x278>
  403f16:	68 4c 00 00 00       	pushq  $0x4c
  403f1b:	e9 20 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f20 <_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_@plt>:
  403f20:	ff 25 42 03 21 00    	jmpq   *0x210342(%rip)        # 614268 <_GLOBAL_OFFSET_TABLE_+0x280>
  403f26:	68 4d 00 00 00       	pushq  $0x4d
  403f2b:	e9 10 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f30 <_ZNSo5flushEv@plt>:
  403f30:	ff 25 3a 03 21 00    	jmpq   *0x21033a(%rip)        # 614270 <_GLOBAL_OFFSET_TABLE_+0x288>
  403f36:	68 4e 00 00 00       	pushq  $0x4e
  403f3b:	e9 00 fb ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f40 <_ZSt25__throw_bad_function_callv@plt>:
  403f40:	ff 25 32 03 21 00    	jmpq   *0x210332(%rip)        # 614278 <_GLOBAL_OFFSET_TABLE_+0x290>
  403f46:	68 4f 00 00 00       	pushq  $0x4f
  403f4b:	e9 f0 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f50 <__stack_chk_fail@plt>:
  403f50:	ff 25 2a 03 21 00    	jmpq   *0x21032a(%rip)        # 614280 <_GLOBAL_OFFSET_TABLE_+0x298>
  403f56:	68 50 00 00 00       	pushq  $0x50
  403f5b:	e9 e0 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f60 <_ZNSt8ios_baseD2Ev@plt>:
  403f60:	ff 25 22 03 21 00    	jmpq   *0x210322(%rip)        # 614288 <_GLOBAL_OFFSET_TABLE_+0x2a0>
  403f66:	68 51 00 00 00       	pushq  $0x51
  403f6b:	e9 d0 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f70 <_ZNSt12__basic_fileIcED1Ev@plt>:
  403f70:	ff 25 1a 03 21 00    	jmpq   *0x21031a(%rip)        # 614290 <_GLOBAL_OFFSET_TABLE_+0x2a8>
  403f76:	68 52 00 00 00       	pushq  $0x52
  403f7b:	e9 c0 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f80 <_ZNSs6assignEPKcm@plt>:
  403f80:	ff 25 12 03 21 00    	jmpq   *0x210312(%rip)        # 614298 <_GLOBAL_OFFSET_TABLE_+0x2b0>
  403f86:	68 53 00 00 00       	pushq  $0x53
  403f8b:	e9 b0 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403f90 <epoll_wait@plt>:
  403f90:	ff 25 0a 03 21 00    	jmpq   *0x21030a(%rip)        # 6142a0 <_GLOBAL_OFFSET_TABLE_+0x2b8>
  403f96:	68 54 00 00 00       	pushq  $0x54
  403f9b:	e9 a0 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403fa0 <_ZNSirsERi@plt>:
  403fa0:	ff 25 02 03 21 00    	jmpq   *0x210302(%rip)        # 6142a8 <_GLOBAL_OFFSET_TABLE_+0x2c0>
  403fa6:	68 55 00 00 00       	pushq  $0x55
  403fab:	e9 90 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403fb0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm@plt>:
  403fb0:	ff 25 fa 02 21 00    	jmpq   *0x2102fa(%rip)        # 6142b0 <_GLOBAL_OFFSET_TABLE_+0x2c8>
  403fb6:	68 56 00 00 00       	pushq  $0x56
  403fbb:	e9 80 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403fc0 <_ZNSs6assignERKSs@plt>:
  403fc0:	ff 25 f2 02 21 00    	jmpq   *0x2102f2(%rip)        # 6142b8 <_GLOBAL_OFFSET_TABLE_+0x2d0>
  403fc6:	68 57 00 00 00       	pushq  $0x57
  403fcb:	e9 70 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403fd0 <pthread_cond_wait@plt>:
  403fd0:	ff 25 ea 02 21 00    	jmpq   *0x2102ea(%rip)        # 6142c0 <_GLOBAL_OFFSET_TABLE_+0x2d8>
  403fd6:	68 58 00 00 00       	pushq  $0x58
  403fdb:	e9 60 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403fe0 <_ZdaPv@plt>:
  403fe0:	ff 25 e2 02 21 00    	jmpq   *0x2102e2(%rip)        # 6142c8 <_GLOBAL_OFFSET_TABLE_+0x2e0>
  403fe6:	68 59 00 00 00       	pushq  $0x59
  403feb:	e9 50 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000403ff0 <memcmp@plt>:
  403ff0:	ff 25 da 02 21 00    	jmpq   *0x2102da(%rip)        # 6142d0 <_GLOBAL_OFFSET_TABLE_+0x2e8>
  403ff6:	68 5a 00 00 00       	pushq  $0x5a
  403ffb:	e9 40 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000404000 <_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate@plt>:
  404000:	ff 25 d2 02 21 00    	jmpq   *0x2102d2(%rip)        # 6142d8 <_GLOBAL_OFFSET_TABLE_+0x2f0>
  404006:	68 5b 00 00 00       	pushq  $0x5b
  40400b:	e9 30 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000404010 <fclose@plt>:
  404010:	ff 25 ca 02 21 00    	jmpq   *0x2102ca(%rip)        # 6142e0 <_GLOBAL_OFFSET_TABLE_+0x2f8>
  404016:	68 5c 00 00 00       	pushq  $0x5c
  40401b:	e9 20 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000404020 <dlopen@plt>:
  404020:	ff 25 c2 02 21 00    	jmpq   *0x2102c2(%rip)        # 6142e8 <_GLOBAL_OFFSET_TABLE_+0x300>
  404026:	68 5d 00 00 00       	pushq  $0x5d
  40402b:	e9 10 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000404030 <remove@plt>:
  404030:	ff 25 ba 02 21 00    	jmpq   *0x2102ba(%rip)        # 6142f0 <_GLOBAL_OFFSET_TABLE_+0x308>
  404036:	68 5e 00 00 00       	pushq  $0x5e
  40403b:	e9 00 fa ff ff       	jmpq   403a40 <_init+0x10>

0000000000404040 <_ZNSt13basic_filebufIcSt11char_traitsIcEEC1Ev@plt>:
  404040:	ff 25 b2 02 21 00    	jmpq   *0x2102b2(%rip)        # 6142f8 <_GLOBAL_OFFSET_TABLE_+0x310>
  404046:	68 5f 00 00 00       	pushq  $0x5f
  40404b:	e9 f0 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404050 <_ZNSo9_M_insertImEERSoT_@plt>:
  404050:	ff 25 aa 02 21 00    	jmpq   *0x2102aa(%rip)        # 614300 <_GLOBAL_OFFSET_TABLE_+0x318>
  404056:	68 60 00 00 00       	pushq  $0x60
  40405b:	e9 e0 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404060 <dlsym@plt>:
  404060:	ff 25 a2 02 21 00    	jmpq   *0x2102a2(%rip)        # 614308 <_GLOBAL_OFFSET_TABLE_+0x320>
  404066:	68 61 00 00 00       	pushq  $0x61
  40406b:	e9 d0 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404070 <_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base@plt>:
  404070:	ff 25 9a 02 21 00    	jmpq   *0x21029a(%rip)        # 614310 <_GLOBAL_OFFSET_TABLE_+0x328>
  404076:	68 62 00 00 00       	pushq  $0x62
  40407b:	e9 c0 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404080 <__cxa_end_catch@plt>:
  404080:	ff 25 92 02 21 00    	jmpq   *0x210292(%rip)        # 614318 <_GLOBAL_OFFSET_TABLE_+0x330>
  404086:	68 63 00 00 00       	pushq  $0x63
  40408b:	e9 b0 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404090 <_ZSt17__throw_bad_allocv@plt>:
  404090:	ff 25 8a 02 21 00    	jmpq   *0x21028a(%rip)        # 614320 <_GLOBAL_OFFSET_TABLE_+0x338>
  404096:	68 64 00 00 00       	pushq  $0x64
  40409b:	e9 a0 f9 ff ff       	jmpq   403a40 <_init+0x10>

00000000004040a0 <_ZNSt13basic_filebufIcSt11char_traitsIcEED1Ev@plt>:
  4040a0:	ff 25 82 02 21 00    	jmpq   *0x210282(%rip)        # 614328 <_GLOBAL_OFFSET_TABLE_+0x340>
  4040a6:	68 65 00 00 00       	pushq  $0x65
  4040ab:	e9 90 f9 ff ff       	jmpq   403a40 <_init+0x10>

00000000004040b0 <__sprintf_chk@plt>:
  4040b0:	ff 25 7a 02 21 00    	jmpq   *0x21027a(%rip)        # 614330 <_GLOBAL_OFFSET_TABLE_+0x348>
  4040b6:	68 66 00 00 00       	pushq  $0x66
  4040bb:	e9 80 f9 ff ff       	jmpq   403a40 <_init+0x10>

00000000004040c0 <__snprintf_chk@plt>:
  4040c0:	ff 25 72 02 21 00    	jmpq   *0x210272(%rip)        # 614338 <_GLOBAL_OFFSET_TABLE_+0x350>
  4040c6:	68 67 00 00 00       	pushq  $0x67
  4040cb:	e9 70 f9 ff ff       	jmpq   403a40 <_init+0x10>

00000000004040d0 <fork@plt>:
  4040d0:	ff 25 6a 02 21 00    	jmpq   *0x21026a(%rip)        # 614340 <_GLOBAL_OFFSET_TABLE_+0x358>
  4040d6:	68 68 00 00 00       	pushq  $0x68
  4040db:	e9 60 f9 ff ff       	jmpq   403a40 <_init+0x10>

00000000004040e0 <_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@plt>:
  4040e0:	ff 25 62 02 21 00    	jmpq   *0x210262(%rip)        # 614348 <_GLOBAL_OFFSET_TABLE_+0x360>
  4040e6:	68 69 00 00 00       	pushq  $0x69
  4040eb:	e9 50 f9 ff ff       	jmpq   403a40 <_init+0x10>

00000000004040f0 <__cxa_guard_abort@plt>:
  4040f0:	ff 25 5a 02 21 00    	jmpq   *0x21025a(%rip)        # 614350 <_GLOBAL_OFFSET_TABLE_+0x368>
  4040f6:	68 6a 00 00 00       	pushq  $0x6a
  4040fb:	e9 40 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404100 <__cxa_begin_catch@plt>:
  404100:	ff 25 52 02 21 00    	jmpq   *0x210252(%rip)        # 614358 <_GLOBAL_OFFSET_TABLE_+0x370>
  404106:	68 6b 00 00 00       	pushq  $0x6b
  40410b:	e9 30 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404110 <bind@plt>:
  404110:	ff 25 4a 02 21 00    	jmpq   *0x21024a(%rip)        # 614360 <_GLOBAL_OFFSET_TABLE_+0x378>
  404116:	68 6c 00 00 00       	pushq  $0x6c
  40411b:	e9 20 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404120 <pthread_mutex_lock@plt>:
  404120:	ff 25 42 02 21 00    	jmpq   *0x210242(%rip)        # 614368 <_GLOBAL_OFFSET_TABLE_+0x380>
  404126:	68 6d 00 00 00       	pushq  $0x6d
  40412b:	e9 10 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404130 <perror@plt>:
  404130:	ff 25 3a 02 21 00    	jmpq   *0x21023a(%rip)        # 614370 <_GLOBAL_OFFSET_TABLE_+0x388>
  404136:	68 6e 00 00 00       	pushq  $0x6e
  40413b:	e9 00 f9 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404140 <__gxx_personality_v0@plt>:
  404140:	ff 25 32 02 21 00    	jmpq   *0x210232(%rip)        # 614378 <_GLOBAL_OFFSET_TABLE_+0x390>
  404146:	68 6f 00 00 00       	pushq  $0x6f
  40414b:	e9 f0 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404150 <localtime@plt>:
  404150:	ff 25 2a 02 21 00    	jmpq   *0x21022a(%rip)        # 614380 <_GLOBAL_OFFSET_TABLE_+0x398>
  404156:	68 70 00 00 00       	pushq  $0x70
  40415b:	e9 e0 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404160 <pthread_mutex_destroy@plt>:
  404160:	ff 25 22 02 21 00    	jmpq   *0x210222(%rip)        # 614388 <_GLOBAL_OFFSET_TABLE_+0x3a0>
  404166:	68 71 00 00 00       	pushq  $0x71
  40416b:	e9 d0 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404170 <write@plt>:
  404170:	ff 25 1a 02 21 00    	jmpq   *0x21021a(%rip)        # 614390 <_GLOBAL_OFFSET_TABLE_+0x3a8>
  404176:	68 72 00 00 00       	pushq  $0x72
  40417b:	e9 c0 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404180 <_Znwm@plt>:
  404180:	ff 25 12 02 21 00    	jmpq   *0x210212(%rip)        # 614398 <_GLOBAL_OFFSET_TABLE_+0x3b0>
  404186:	68 73 00 00 00       	pushq  $0x73
  40418b:	e9 b0 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404190 <_ZNSsC1ERKSsmm@plt>:
  404190:	ff 25 0a 02 21 00    	jmpq   *0x21020a(%rip)        # 6143a0 <_GLOBAL_OFFSET_TABLE_+0x3b8>
  404196:	68 74 00 00 00       	pushq  $0x74
  40419b:	e9 a0 f8 ff ff       	jmpq   403a40 <_init+0x10>

00000000004041a0 <_Unwind_Resume@plt>:
  4041a0:	ff 25 02 02 21 00    	jmpq   *0x210202(%rip)        # 6143a8 <_GLOBAL_OFFSET_TABLE_+0x3c0>
  4041a6:	68 75 00 00 00       	pushq  $0x75
  4041ab:	e9 90 f8 ff ff       	jmpq   403a40 <_init+0x10>

00000000004041b0 <_ZNSt6localeD1Ev@plt>:
  4041b0:	ff 25 fa 01 21 00    	jmpq   *0x2101fa(%rip)        # 6143b0 <_GLOBAL_OFFSET_TABLE_+0x3c8>
  4041b6:	68 76 00 00 00       	pushq  $0x76
  4041bb:	e9 80 f8 ff ff       	jmpq   403a40 <_init+0x10>

00000000004041c0 <accept@plt>:
  4041c0:	ff 25 f2 01 21 00    	jmpq   *0x2101f2(%rip)        # 6143b8 <_GLOBAL_OFFSET_TABLE_+0x3d0>
  4041c6:	68 77 00 00 00       	pushq  $0x77
  4041cb:	e9 70 f8 ff ff       	jmpq   403a40 <_init+0x10>

00000000004041d0 <pthread_mutex_unlock@plt>:
  4041d0:	ff 25 ea 01 21 00    	jmpq   *0x2101ea(%rip)        # 6143c0 <_GLOBAL_OFFSET_TABLE_+0x3d8>
  4041d6:	68 78 00 00 00       	pushq  $0x78
  4041db:	e9 60 f8 ff ff       	jmpq   403a40 <_init+0x10>

00000000004041e0 <_ZNSo3putEc@plt>:
  4041e0:	ff 25 e2 01 21 00    	jmpq   *0x2101e2(%rip)        # 6143c8 <_GLOBAL_OFFSET_TABLE_+0x3e0>
  4041e6:	68 79 00 00 00       	pushq  $0x79
  4041eb:	e9 50 f8 ff ff       	jmpq   403a40 <_init+0x10>

00000000004041f0 <_ZNSs12_M_leak_hardEv@plt>:
  4041f0:	ff 25 da 01 21 00    	jmpq   *0x2101da(%rip)        # 6143d0 <_GLOBAL_OFFSET_TABLE_+0x3e8>
  4041f6:	68 7a 00 00 00       	pushq  $0x7a
  4041fb:	e9 40 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404200 <inet_ntop@plt>:
  404200:	ff 25 d2 01 21 00    	jmpq   *0x2101d2(%rip)        # 6143d8 <_GLOBAL_OFFSET_TABLE_+0x3f0>
  404206:	68 7b 00 00 00       	pushq  $0x7b
  40420b:	e9 30 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404210 <_ZNSs4swapERSs@plt>:
  404210:	ff 25 ca 01 21 00    	jmpq   *0x2101ca(%rip)        # 6143e0 <_GLOBAL_OFFSET_TABLE_+0x3f8>
  404216:	68 7c 00 00 00       	pushq  $0x7c
  40421b:	e9 20 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404220 <memcpy@plt>:
  404220:	ff 25 c2 01 21 00    	jmpq   *0x2101c2(%rip)        # 6143e8 <_GLOBAL_OFFSET_TABLE_+0x400>
  404226:	68 7d 00 00 00       	pushq  $0x7d
  40422b:	e9 10 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404230 <fcntl@plt>:
  404230:	ff 25 ba 01 21 00    	jmpq   *0x2101ba(%rip)        # 6143f0 <_GLOBAL_OFFSET_TABLE_+0x408>
  404236:	68 7e 00 00 00       	pushq  $0x7e
  40423b:	e9 00 f8 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404240 <_ZNSs6appendERKSs@plt>:
  404240:	ff 25 b2 01 21 00    	jmpq   *0x2101b2(%rip)        # 6143f8 <_GLOBAL_OFFSET_TABLE_+0x410>
  404246:	68 7f 00 00 00       	pushq  $0x7f
  40424b:	e9 f0 f7 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404250 <open@plt>:
  404250:	ff 25 aa 01 21 00    	jmpq   *0x2101aa(%rip)        # 614400 <_GLOBAL_OFFSET_TABLE_+0x418>
  404256:	68 80 00 00 00       	pushq  $0x80
  40425b:	e9 e0 f7 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404260 <mmap@plt>:
  404260:	ff 25 a2 01 21 00    	jmpq   *0x2101a2(%rip)        # 614408 <_GLOBAL_OFFSET_TABLE_+0x420>
  404266:	68 81 00 00 00       	pushq  $0x81
  40426b:	e9 d0 f7 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404270 <_ZNSt13basic_filebufIcSt11char_traitsIcEE5closeEv@plt>:
  404270:	ff 25 9a 01 21 00    	jmpq   *0x21019a(%rip)        # 614410 <_GLOBAL_OFFSET_TABLE_+0x428>
  404276:	68 82 00 00 00       	pushq  $0x82
  40427b:	e9 c0 f7 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404280 <rename@plt>:
  404280:	ff 25 92 01 21 00    	jmpq   *0x210192(%rip)        # 614418 <_GLOBAL_OFFSET_TABLE_+0x430>
  404286:	68 83 00 00 00       	pushq  $0x83
  40428b:	e9 b0 f7 ff ff       	jmpq   403a40 <_init+0x10>

0000000000404290 <__fdelt_chk@plt>:
  404290:	ff 25 8a 01 21 00    	jmpq   *0x21018a(%rip)        # 614420 <_GLOBAL_OFFSET_TABLE_+0x438>
  404296:	68 84 00 00 00       	pushq  $0x84
  40429b:	e9 a0 f7 ff ff       	jmpq   403a40 <_init+0x10>

00000000004042a0 <time@plt>:
  4042a0:	ff 25 82 01 21 00    	jmpq   *0x210182(%rip)        # 614428 <_GLOBAL_OFFSET_TABLE_+0x440>
  4042a6:	68 85 00 00 00       	pushq  $0x85
  4042ab:	e9 90 f7 ff ff       	jmpq   403a40 <_init+0x10>

00000000004042b0 <fflush@plt>:
  4042b0:	ff 25 7a 01 21 00    	jmpq   *0x21017a(%rip)        # 614430 <_GLOBAL_OFFSET_TABLE_+0x448>
  4042b6:	68 86 00 00 00       	pushq  $0x86
  4042bb:	e9 80 f7 ff ff       	jmpq   403a40 <_init+0x10>

00000000004042c0 <inet_addr@plt>:
  4042c0:	ff 25 72 01 21 00    	jmpq   *0x210172(%rip)        # 614438 <_GLOBAL_OFFSET_TABLE_+0x450>
  4042c6:	68 87 00 00 00       	pushq  $0x87
  4042cb:	e9 70 f7 ff ff       	jmpq   403a40 <_init+0x10>

Disassembly of section .text:

00000000004042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>:
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4042d0:	48 83 3d a0 fc 20 00 	cmpq   $0x0,0x20fca0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4042d7:	00 
  4042d8:	74 0a                	je     4042e4 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0+0x14>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4042da:	83 c8 ff             	or     $0xffffffff,%eax
  4042dd:	f0 0f c1 47 10       	lock xadd %eax,0x10(%rdi)
  4042e2:	eb 09                	jmp    4042ed <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0+0x1d>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4042e4:	8b 47 10             	mov    0x10(%rdi),%eax
    *__mem += __val;
  4042e7:	8d 50 ff             	lea    -0x1(%rax),%edx
  4042ea:	89 57 10             	mov    %edx,0x10(%rdi)
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4042ed:	85 c0                	test   %eax,%eax
  4042ef:	7f 05                	jg     4042f6 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0+0x26>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4042f1:	e9 7a fa ff ff       	jmpq   403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4042f6:	c3                   	retq   
  4042f7:	90                   	nop

00000000004042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>:
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4042f8:	48 83 3d 78 fc 20 00 	cmpq   $0x0,0x20fc78(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4042ff:	00 
  404300:	74 0a                	je     40430c <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2+0x14>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  404302:	83 c8 ff             	or     $0xffffffff,%eax
  404305:	f0 0f c1 47 10       	lock xadd %eax,0x10(%rdi)
  40430a:	eb 09                	jmp    404315 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2+0x1d>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40430c:	8b 47 10             	mov    0x10(%rdi),%eax
    *__mem += __val;
  40430f:	8d 50 ff             	lea    -0x1(%rax),%edx
  404312:	89 57 10             	mov    %edx,0x10(%rdi)
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  404315:	85 c0                	test   %eax,%eax
  404317:	7f 05                	jg     40431e <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2+0x26>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  404319:	e9 52 fa ff ff       	jmpq   403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40431e:	c3                   	retq   
  40431f:	90                   	nop

0000000000404320 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>:
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  404320:	48 83 3d 50 fc 20 00 	cmpq   $0x0,0x20fc50(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  404327:	00 
  404328:	74 0a                	je     404334 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0+0x14>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40432a:	83 c8 ff             	or     $0xffffffff,%eax
  40432d:	f0 0f c1 47 10       	lock xadd %eax,0x10(%rdi)
  404332:	eb 09                	jmp    40433d <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0+0x1d>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  404334:	8b 47 10             	mov    0x10(%rdi),%eax
    *__mem += __val;
  404337:	8d 50 ff             	lea    -0x1(%rax),%edx
  40433a:	89 57 10             	mov    %edx,0x10(%rdi)
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40433d:	85 c0                	test   %eax,%eax
  40433f:	7f 05                	jg     404346 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0+0x26>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  404341:	e9 2a fa ff ff       	jmpq   403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  404346:	c3                   	retq   
  404347:	90                   	nop

0000000000404348 <_ZN5Mutex4lockEv.part.3>:
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&_mutex);
        assert(ret == 0);
  404348:	48 8d 0d 41 c7 00 00 	lea    0xc741(%rip),%rcx        # 410a90 <_ZZN5Mutex4lockEvE19__PRETTY_FUNCTION__>
            printf("~Mutex ret=%d, %p\n", ret, this);
            assert(ret == 0);
        }
    }

    void lock()
  40434f:	50                   	push   %rax
    {
        int ret = pthread_mutex_lock(&_mutex);
        assert(ret == 0);
  404350:	48 8d 35 2b c5 00 00 	lea    0xc52b(%rip),%rsi        # 410882 <_ZTSN6rocket12EpollWrapperE+0x2a2>
  404357:	48 8d 3d 2d c5 00 00 	lea    0xc52d(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40435e:	ba 3c 00 00 00       	mov    $0x3c,%edx
  404363:	e8 78 f8 ff ff       	callq  403be0 <__assert_fail@plt>

0000000000404368 <_ZN5Mutex6unlockEv.part.4>:
    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
        perror("pthread_mutex_unlock");
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  404368:	48 8d 0d 01 c7 00 00 	lea    0xc701(%rip),%rcx        # 410a70 <_ZZN5Mutex6unlockEvE19__PRETTY_FUNCTION__>
    {
        int ret = pthread_mutex_lock(&_mutex);
        assert(ret == 0);
    }

    void unlock()
  40436f:	50                   	push   %rax
    {
        int ret = pthread_mutex_unlock(&_mutex);
        perror("pthread_mutex_unlock");
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  404370:	48 8d 35 0b c5 00 00 	lea    0xc50b(%rip),%rsi        # 410882 <_ZTSN6rocket12EpollWrapperE+0x2a2>
  404377:	48 8d 3d 0d c5 00 00 	lea    0xc50d(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40437e:	ba 44 00 00 00       	mov    $0x44,%edx
  404383:	e8 58 f8 ff ff       	callq  403be0 <__assert_fail@plt>

0000000000404388 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.1>:
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  404388:	48 83 3d e8 fb 20 00 	cmpq   $0x0,0x20fbe8(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40438f:	00 
  404390:	74 0a                	je     40439c <_ZNSs4_Rep10_M_disposeERKSaIcE.part.1+0x14>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  404392:	83 c8 ff             	or     $0xffffffff,%eax
  404395:	f0 0f c1 47 10       	lock xadd %eax,0x10(%rdi)
  40439a:	eb 09                	jmp    4043a5 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.1+0x1d>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40439c:	8b 47 10             	mov    0x10(%rdi),%eax
    *__mem += __val;
  40439f:	8d 50 ff             	lea    -0x1(%rax),%edx
  4043a2:	89 57 10             	mov    %edx,0x10(%rdi)
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4043a5:	85 c0                	test   %eax,%eax
  4043a7:	7f 05                	jg     4043ae <_ZNSs4_Rep10_M_disposeERKSaIcE.part.1+0x26>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4043a9:	e9 c2 f9 ff ff       	jmpq   403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4043ae:	c3                   	retq   
  4043af:	90                   	nop

00000000004043b0 <_ZN6rocket5Mutex4lockEv.part.6>:
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&mutex_);
        assert(ret == 0);
  4043b0:	48 8d 0d 49 cb 00 00 	lea    0xcb49(%rip),%rcx        # 410f00 <_ZZN6rocket5Mutex4lockEvE19__PRETTY_FUNCTION__>
            //perror("pthread_mutex_destroy");
            assert(ret == 0);
        }
    }

    void lock()
  4043b7:	50                   	push   %rax
    {
        int ret = pthread_mutex_lock(&mutex_);
        assert(ret == 0);
  4043b8:	48 8d 35 f9 c6 00 00 	lea    0xc6f9(%rip),%rsi        # 410ab8 <_ZTS10LoggerImpl+0xd>
  4043bf:	48 8d 3d c5 c4 00 00 	lea    0xc4c5(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  4043c6:	ba 1f 00 00 00       	mov    $0x1f,%edx
  4043cb:	e8 10 f8 ff ff       	callq  403be0 <__assert_fail@plt>

00000000004043d0 <_ZN6rocket5Mutex6unlockEv.part.7>:

    void unlock()
    {
        int ret = pthread_mutex_unlock(&mutex_);
        //perror("pthread_mutex_unlock");
        assert(ret == 0);
  4043d0:	48 8d 0d 09 cb 00 00 	lea    0xcb09(%rip),%rcx        # 410ee0 <_ZZN6rocket5Mutex6unlockEvE19__PRETTY_FUNCTION__>
    {
        int ret = pthread_mutex_lock(&mutex_);
        assert(ret == 0);
    }

    void unlock()
  4043d7:	50                   	push   %rax
    {
        int ret = pthread_mutex_unlock(&mutex_);
        //perror("pthread_mutex_unlock");
        assert(ret == 0);
  4043d8:	48 8d 35 d9 c6 00 00 	lea    0xc6d9(%rip),%rsi        # 410ab8 <_ZTS10LoggerImpl+0xd>
  4043df:	48 8d 3d a5 c4 00 00 	lea    0xc4a5(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  4043e6:	ba 26 00 00 00       	mov    $0x26,%edx
  4043eb:	e8 f0 f7 ff ff       	callq  403be0 <__assert_fail@plt>

00000000004043f0 <_GLOBAL__sub_I_config_reader.cc>:
  extern wostream wclog;	/// Linked to standard error (buffered)
#endif
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
  4043f0:	48 8d 3d 4d 01 21 00 	lea    0x21014d(%rip),%rdi        # 614544 <_ZStL8__ioinit>
    s.erase(s.find_last_not_of(blank) + 1);
    
    return s;
}

  4043f7:	48 83 ec 08          	sub    $0x8,%rsp
  4043fb:	e8 30 f8 ff ff       	callq  403c30 <_ZNSt8ios_base4InitC1Ev@plt>
  404400:	48 8b 3d e1 fa 20 00 	mov    0x20fae1(%rip),%rdi        # 613ee8 <_DYNAMIC+0x260>
  404407:	48 8d 15 3a 00 21 00 	lea    0x21003a(%rip),%rdx        # 614448 <__dso_handle>
  40440e:	48 8d 35 2f 01 21 00 	lea    0x21012f(%rip),%rsi        # 614544 <_ZStL8__ioinit>
  404415:	48 83 c4 08          	add    $0x8,%rsp
  404419:	e9 b2 f8 ff ff       	jmpq   403cd0 <__cxa_atexit@plt>
  40441e:	90                   	nop
  40441f:	90                   	nop

0000000000404420 <_GLOBAL__sub_I_event_dispatcher.cc>:
  404420:	48 8d 3d 21 01 21 00 	lea    0x210121(%rip),%rdi        # 614548 <_ZStL8__ioinit>
    if (epoll_.is_write(events)) {
        LOG_ERROR("ProcessEvents WRITE EVENT, fd=%d", fd);
    }
}

  404427:	48 83 ec 08          	sub    $0x8,%rsp
  40442b:	e8 00 f8 ff ff       	callq  403c30 <_ZNSt8ios_base4InitC1Ev@plt>
  404430:	48 8b 3d b1 fa 20 00 	mov    0x20fab1(%rip),%rdi        # 613ee8 <_DYNAMIC+0x260>
  404437:	48 8d 15 0a 00 21 00 	lea    0x21000a(%rip),%rdx        # 614448 <__dso_handle>
  40443e:	48 8d 35 03 01 21 00 	lea    0x210103(%rip),%rsi        # 614548 <_ZStL8__ioinit>
  404445:	48 83 c4 08          	add    $0x8,%rsp
  404449:	e9 82 f8 ff ff       	jmpq   403cd0 <__cxa_atexit@plt>
  40444e:	90                   	nop
  40444f:	90                   	nop

0000000000404450 <main>:
        fclose(fp);
    }
}

int main(int argc, char* argv[])
{
  404450:	55                   	push   %rbp
  404451:	48 89 e5             	mov    %rsp,%rbp
  404454:	41 56                	push   %r14
  404456:	41 54                	push   %r12
  404458:	53                   	push   %rbx
  404459:	48 81 ec 98 01 00 00 	sub    $0x198,%rsp
  404460:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  404467:	00 00 
  404469:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  40446d:	31 c0                	xor    %eax,%eax
    /* parse parameter option */
    if (parse_options(argc, argv) != 0)
  40446f:	e8 cc 95 00 00       	callq  40da40 <_Z13parse_optionsiPPc>
  404474:	85 c0                	test   %eax,%eax
  404476:	0f 85 d4 01 00 00    	jne    404650 <main+0x200>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  40447c:	48 8b 05 dd fa 20 00 	mov    0x20fadd(%rip),%rax        # 613f60 <_DYNAMIC+0x2d8>
        exit(EXIT_FAILURE);
    }

    Config cfg;

    if (!cfg.load(opt_config))
  404483:	48 8d 9d 50 fe ff ff 	lea    -0x1b0(%rbp),%rbx
  40448a:	48 8b 35 77 0a 21 00 	mov    0x210a77(%rip),%rsi        # 614f08 <_ZL10opt_config>
    int rotate;
    unsigned count;
    size_t size;
    bool display;  // display to screen

    LogConfig() : file(), level(LEVEL_DEBUG), rotate(ROTATE_DAILY), count(10), size(104857600), display(true)
  404491:	c7 85 88 fe ff ff 00 	movl   $0x0,-0x178(%rbp)
  404498:	00 00 00 
  40449b:	c7 85 8c fe ff ff 00 	movl   $0x0,-0x174(%rbp)
  4044a2:	00 00 00 
  4044a5:	48 89 df             	mov    %rbx,%rdi
  4044a8:	c7 85 90 fe ff ff 0a 	movl   $0xa,-0x170(%rbp)
  4044af:	00 00 00 
  4044b2:	48 c7 85 98 fe ff ff 	movq   $0x6400000,-0x168(%rbp)
  4044b9:	00 00 40 06 
  4044bd:	48 83 c0 18          	add    $0x18,%rax
  4044c1:	c6 85 a0 fe ff ff 01 	movb   $0x1,-0x160(%rbp)
  4044c8:	48 89 85 50 fe ff ff 	mov    %rax,-0x1b0(%rbp)
  4044cf:	48 89 85 70 fe ff ff 	mov    %rax,-0x190(%rbp)
  4044d6:	48 89 85 78 fe ff ff 	mov    %rax,-0x188(%rbp)
  4044dd:	48 89 85 80 fe ff ff 	mov    %rax,-0x180(%rbp)
  4044e4:	e8 c7 03 00 00       	callq  4048b0 <_ZN6rocket6Config4loadEPKc>
  4044e9:	84 c0                	test   %al,%al
  4044eb:	0f 84 69 01 00 00    	je     40465a <main+0x20a>
    {
        fprintf(stderr, "load config file %s failed\n", opt_config);
        exit(EXIT_FAILURE);
    }

    std::cout << "log path:" << cfg._log_cfg.file << std::endl;
  4044f1:	48 8b 3d 28 fa 20 00 	mov    0x20fa28(%rip),%rdi        # 613f20 <_DYNAMIC+0x298>
  4044f8:	48 8d 35 92 c6 00 00 	lea    0xc692(%rip),%rsi        # 410b91 <_ZTS10LoggerImpl+0xe6>
  4044ff:	e8 2c f8 ff ff       	callq  403d30 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404504:	48 8b b5 80 fe ff ff 	mov    -0x180(%rbp),%rsi
    operator<<(basic_ostream<_CharT, _Traits>& __os,
	       const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 586. string inserter not a formatted function
      return __ostream_insert(__os, __str.data(), __str.size());
  40450b:	48 89 c7             	mov    %rax,%rdi
  40450e:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  404512:	e8 89 f9 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// DR 60. What is a formatted input function?
	// The inserters for manipulators are *not* formatted output functions.
	return __pf(*this);
  404517:	48 89 c7             	mov    %rax,%rdi
  40451a:	e8 c1 fb ff ff       	callq  4040e0 <_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@plt>
    LOG(ERROR) << "ERROR1";  
    //LOG(FATAL) << "FATAL";  
    google::ShutdownGoogleLogging();  
    */
    
    LOGGER.init(cfg._log_cfg);
  40451f:	e8 0c 76 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  404524:	48 8b 10             	mov    (%rax),%rdx
  404527:	48 8d 73 30          	lea    0x30(%rbx),%rsi
  40452b:	48 89 c7             	mov    %rax,%rdi
  40452e:	ff 12                	callq  *(%rdx)

    LOG_INFO("rocket server listen on %s:%d", cfg._ip.c_str(), cfg._port);
  404530:	e8 fb 75 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  404535:	8b 95 58 fe ff ff    	mov    -0x1a8(%rbp),%edx
  40453b:	51                   	push   %rcx
  40453c:	48 89 c7             	mov    %rax,%rdi
  40453f:	4c 8b 10             	mov    (%rax),%r10
  404542:	4c 8b 8d 50 fe ff ff 	mov    -0x1b0(%rbp),%r9
  404549:	4c 8d 05 4b c6 00 00 	lea    0xc64b(%rip),%r8        # 410b9b <_ZTS10LoggerImpl+0xf0>
  404550:	b9 bc 00 00 00       	mov    $0xbc,%ecx
  404555:	be 01 00 00 00       	mov    $0x1,%esi
  40455a:	31 c0                	xor    %eax,%eax
  40455c:	52                   	push   %rdx
  40455d:	48 8d 15 55 c6 00 00 	lea    0xc655(%rip),%rdx        # 410bb9 <_ZTS10LoggerImpl+0x10e>
  404564:	41 ff 52 20          	callq  *0x20(%r10)
  404568:	58                   	pop    %rax
  404569:	5a                   	pop    %rdx
    LOG_INFO("server thread pool size:%d", cfg._net_nthreads);
  40456a:	e8 c1 75 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40456f:	4c 8b 10             	mov    (%rax),%r10
  404572:	48 89 c7             	mov    %rax,%rdi
  404575:	44 8b 8d 5c fe ff ff 	mov    -0x1a4(%rbp),%r9d
  40457c:	4c 8d 05 3e c6 00 00 	lea    0xc63e(%rip),%r8        # 410bc1 <_ZTS10LoggerImpl+0x116>
  404583:	b9 bd 00 00 00       	mov    $0xbd,%ecx
  404588:	48 8d 15 2a c6 00 00 	lea    0xc62a(%rip),%rdx        # 410bb9 <_ZTS10LoggerImpl+0x10e>
  40458f:	be 01 00 00 00       	mov    $0x1,%esi
  404594:	31 c0                	xor    %eax,%eax
  404596:	41 ff 52 20          	callq  *0x20(%r10)

    // 加载so
    if (0 == load_so(cfg._app_so.c_str()))
  40459a:	48 8b bd 70 fe ff ff 	mov    -0x190(%rbp),%rdi
  4045a1:	e8 da 72 00 00       	callq  40b880 <_ZN6rocket7load_soEPKc>
  4045a6:	85 c0                	test   %eax,%eax
  4045a8:	0f 85 d2 00 00 00    	jne    404680 <main+0x230>
    {
        int ret = rocket_dll.rocket_handle_init((void *)cfg._app_conf.c_str());
  4045ae:	48 8b 05 5b f9 20 00 	mov    0x20f95b(%rip),%rax        # 613f10 <_DYNAMIC+0x288>
  4045b5:	48 8b bd 78 fe ff ff 	mov    -0x188(%rbp),%rdi
  4045bc:	ff 50 08             	callq  *0x8(%rax)
        if (ret != 0)
  4045bf:	85 c0                	test   %eax,%eax
    LOG_INFO("server thread pool size:%d", cfg._net_nthreads);

    // 加载so
    if (0 == load_so(cfg._app_so.c_str()))
    {
        int ret = rocket_dll.rocket_handle_init((void *)cfg._app_conf.c_str());
  4045c1:	41 89 c4             	mov    %eax,%r12d
        if (ret != 0)
  4045c4:	75 5e                	jne    404624 <main+0x1d4>
        LOG_ERROR("load so %s failed", cfg._app_so.c_str());
        exit(EXIT_FAILURE);
    }

    // run as daemon if daemonize is set true
    if (do_daemonize)
  4045c6:	80 3d 33 09 21 00 00 	cmpb   $0x0,0x210933(%rip)        # 614f00 <_ZL12do_daemonize>
  4045cd:	74 0e                	je     4045dd <main+0x18d>
    {
        if (daemonize() == -1)
  4045cf:	e8 8c 95 00 00       	callq  40db60 <_Z9daemonizev>
  4045d4:	83 c0 01             	add    $0x1,%eax
  4045d7:	0f 84 d5 00 00 00    	je     4046b2 <main+0x262>
            exit(EXIT_FAILURE);
        }
    }

    //create pid file
    createPidFile();
  4045dd:	e8 6e 96 00 00       	callq  40dc50 <_Z13createPidFilev>
    boost::asio::io_gservice io_service;
    Server s(io_service, port, thread_pool_size);
    io_service.run();
    */

    Server s(port, thread_pool_size);
  4045e2:	0f bf b5 58 fe ff ff 	movswl -0x1a8(%rbp),%esi
  4045e9:	48 8d 85 b0 fe ff ff 	lea    -0x150(%rbp),%rax
  4045f0:	8b 95 5c fe ff ff    	mov    -0x1a4(%rbp),%edx
  4045f6:	b9 01 00 00 00       	mov    $0x1,%ecx
  4045fb:	48 89 c7             	mov    %rax,%rdi
  4045fe:	49 89 c4             	mov    %rax,%r12
  404601:	49 89 c6             	mov    %rax,%r14
  404604:	e8 e7 9c 00 00       	callq  40e2f0 <_ZN6rocket6ServerC1Ejii>
    s.run();
  404609:	4c 89 e7             	mov    %r12,%rdi
  40460c:	e8 2f a2 00 00       	callq  40e840 <_ZN6rocket6Server3runEv>
  404611:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

    while (true) {
        usleep(1);
  404618:	bf 01 00 00 00       	mov    $0x1,%edi
  40461d:	e8 0e f8 ff ff       	callq  403e30 <usleep@plt>
  404622:	eb f4                	jmp    404618 <main+0x1c8>
    if (0 == load_so(cfg._app_so.c_str()))
    {
        int ret = rocket_dll.rocket_handle_init((void *)cfg._app_conf.c_str());
        if (ret != 0)
        {
            LOG_ERROR("handle init error, ret: %d", ret);
  404624:	e8 07 75 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  404629:	4c 8b 10             	mov    (%rax),%r10
  40462c:	48 89 c7             	mov    %rax,%rdi
  40462f:	45 89 e1             	mov    %r12d,%r9d
  404632:	4c 8d 05 a3 c5 00 00 	lea    0xc5a3(%rip),%r8        # 410bdc <_ZTS10LoggerImpl+0x131>
  404639:	b9 c5 00 00 00       	mov    $0xc5,%ecx
  40463e:	48 8d 15 74 c5 00 00 	lea    0xc574(%rip),%rdx        # 410bb9 <_ZTS10LoggerImpl+0x10e>
  404645:	be 03 00 00 00       	mov    $0x3,%esi
  40464a:	31 c0                	xor    %eax,%eax
  40464c:	41 ff 52 20          	callq  *0x20(%r10)
int main(int argc, char* argv[])
{
    /* parse parameter option */
    if (parse_options(argc, argv) != 0)
    {
        exit(EXIT_FAILURE);
  404650:	bf 01 00 00 00       	mov    $0x1,%edi
  404655:	e8 76 f5 ff ff       	callq  403bd0 <exit@plt>
# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
			__va_arg_pack ());
  40465a:	48 8b 05 0f f9 20 00 	mov    0x20f90f(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  404661:	48 8b 0d a0 08 21 00 	mov    0x2108a0(%rip),%rcx        # 614f08 <_ZL10opt_config>
  404668:	48 8d 15 06 c5 00 00 	lea    0xc506(%rip),%rdx        # 410b75 <_ZTS10LoggerImpl+0xca>
  40466f:	be 01 00 00 00       	mov    $0x1,%esi
  404674:	48 8b 38             	mov    (%rax),%rdi
  404677:	31 c0                	xor    %eax,%eax
  404679:	e8 e2 f4 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40467e:	eb d0                	jmp    404650 <main+0x200>
            exit(EXIT_FAILURE);
        }
    }
    else
    {
        LOG_ERROR("load so %s failed", cfg._app_so.c_str());
  404680:	e8 ab 74 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  404685:	4c 8b 10             	mov    (%rax),%r10
  404688:	48 89 c7             	mov    %rax,%rdi
  40468b:	4c 8b 8d 70 fe ff ff 	mov    -0x190(%rbp),%r9
  404692:	4c 8d 05 5e c5 00 00 	lea    0xc55e(%rip),%r8        # 410bf7 <_ZTS10LoggerImpl+0x14c>
  404699:	b9 cb 00 00 00       	mov    $0xcb,%ecx
  40469e:	48 8d 15 14 c5 00 00 	lea    0xc514(%rip),%rdx        # 410bb9 <_ZTS10LoggerImpl+0x10e>
  4046a5:	be 03 00 00 00       	mov    $0x3,%esi
  4046aa:	31 c0                	xor    %eax,%eax
  4046ac:	41 ff 52 20          	callq  *0x20(%r10)
  4046b0:	eb 9e                	jmp    404650 <main+0x200>
  4046b2:	48 8b 05 b7 f8 20 00 	mov    0x20f8b7(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  4046b9:	48 8d 15 49 c5 00 00 	lea    0xc549(%rip),%rdx        # 410c09 <_ZTS10LoggerImpl+0x15e>
  4046c0:	be 01 00 00 00       	mov    $0x1,%esi
  4046c5:	48 8b 38             	mov    (%rax),%rdi
  4046c8:	31 c0                	xor    %eax,%eax
  4046ca:	e8 91 f4 ff ff       	callq  403b60 <__fprintf_chk@plt>
  4046cf:	e9 7c ff ff ff       	jmpq   404650 <main+0x200>
  4046d4:	49 89 c4             	mov    %rax,%r12

    while (true) {
        usleep(1);
    }

    return 0;
  4046d7:	48 89 df             	mov    %rbx,%rdi
  4046da:	e8 91 96 00 00       	callq  40dd70 <_ZN6rocket6ConfigD1Ev>
  4046df:	4c 89 e7             	mov    %r12,%rdi
  4046e2:	e8 b9 fa ff ff       	callq  4041a0 <_Unwind_Resume@plt>
    boost::asio::io_gservice io_service;
    Server s(io_service, port, thread_pool_size);
    io_service.run();
    */

    Server s(port, thread_pool_size);
  4046e7:	4c 89 f7             	mov    %r14,%rdi
  4046ea:	49 89 c4             	mov    %rax,%r12
  4046ed:	e8 ae 95 00 00       	callq  40dca0 <_ZN6rocket6ServerD1Ev>
  4046f2:	eb e3                	jmp    4046d7 <main+0x287>
  4046f4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4046fb:	00 00 00 00 00 

0000000000404700 <_GLOBAL__sub_I_main.cc>:
  404700:	48 8d 3d 09 08 21 00 	lea    0x210809(%rip),%rdi        # 614f10 <_ZStL8__ioinit>
    while (true) {
        usleep(1);
    }

    return 0;
  404707:	48 83 ec 08          	sub    $0x8,%rsp
  40470b:	e8 20 f5 ff ff       	callq  403c30 <_ZNSt8ios_base4InitC1Ev@plt>
  404710:	48 8b 3d d1 f7 20 00 	mov    0x20f7d1(%rip),%rdi        # 613ee8 <_DYNAMIC+0x260>
  404717:	48 8d 15 2a fd 20 00 	lea    0x20fd2a(%rip),%rdx        # 614448 <__dso_handle>
  40471e:	48 8d 35 eb 07 21 00 	lea    0x2107eb(%rip),%rsi        # 614f10 <_ZStL8__ioinit>
  404725:	48 83 c4 08          	add    $0x8,%rsp
  404729:	e9 a2 f5 ff ff       	jmpq   403cd0 <__cxa_atexit@plt>
  40472e:	90                   	nop
  40472f:	90                   	nop

0000000000404730 <_GLOBAL__sub_I_server.cc>:
  404730:	48 8d 3d dd 07 21 00 	lea    0x2107dd(%rip),%rdi        # 614f14 <_ZStL8__ioinit>

void Server::WriteCallback(int fd) {

}

} // namespace rocket
  404737:	48 83 ec 08          	sub    $0x8,%rsp
  40473b:	e8 f0 f4 ff ff       	callq  403c30 <_ZNSt8ios_base4InitC1Ev@plt>
  404740:	48 8b 3d a1 f7 20 00 	mov    0x20f7a1(%rip),%rdi        # 613ee8 <_DYNAMIC+0x260>
  404747:	48 8d 15 fa fc 20 00 	lea    0x20fcfa(%rip),%rdx        # 614448 <__dso_handle>
  40474e:	48 8d 35 bf 07 21 00 	lea    0x2107bf(%rip),%rsi        # 614f14 <_ZStL8__ioinit>
  404755:	48 83 c4 08          	add    $0x8,%rsp
  404759:	e9 72 f5 ff ff       	jmpq   403cd0 <__cxa_atexit@plt>
  40475e:	90                   	nop
  40475f:	90                   	nop

0000000000404760 <_GLOBAL__sub_I_socket_util.cc>:
  404760:	48 8d 3d b1 07 21 00 	lea    0x2107b1(%rip),%rdi        # 614f18 <_ZStL8__ioinit>
  char err[60];
  snprintf(err,sizeof(err),"error %d", error);
  return std::string(err);
}

}
  404767:	48 83 ec 08          	sub    $0x8,%rsp
  40476b:	e8 c0 f4 ff ff       	callq  403c30 <_ZNSt8ios_base4InitC1Ev@plt>
  404770:	48 8b 3d 71 f7 20 00 	mov    0x20f771(%rip),%rdi        # 613ee8 <_DYNAMIC+0x260>
  404777:	48 8d 15 ca fc 20 00 	lea    0x20fcca(%rip),%rdx        # 614448 <__dso_handle>
  40477e:	48 8d 35 93 07 21 00 	lea    0x210793(%rip),%rsi        # 614f18 <_ZStL8__ioinit>
  404785:	48 83 c4 08          	add    $0x8,%rsp
  404789:	e9 42 f5 ff ff       	jmpq   403cd0 <__cxa_atexit@plt>
  40478e:	90                   	nop
  40478f:	90                   	nop

0000000000404790 <_start>:
  404790:	31 ed                	xor    %ebp,%ebp
  404792:	49 89 d1             	mov    %rdx,%r9
  404795:	5e                   	pop    %rsi
  404796:	48 89 e2             	mov    %rsp,%rdx
  404799:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  40479d:	50                   	push   %rax
  40479e:	54                   	push   %rsp
  40479f:	49 c7 c0 40 03 41 00 	mov    $0x410340,%r8
  4047a6:	48 c7 c1 b0 02 41 00 	mov    $0x4102b0,%rcx
  4047ad:	48 c7 c7 50 44 40 00 	mov    $0x404450,%rdi
  4047b4:	e8 b7 f4 ff ff       	callq  403c70 <__libc_start_main@plt>
  4047b9:	f4                   	hlt    
  4047ba:	90                   	nop
  4047bb:	90                   	nop

00000000004047bc <call_gmon_start>:
  4047bc:	48 83 ec 08          	sub    $0x8,%rsp
  4047c0:	48 8b 05 f9 f6 20 00 	mov    0x20f6f9(%rip),%rax        # 613ec0 <_DYNAMIC+0x238>
  4047c7:	48 85 c0             	test   %rax,%rax
  4047ca:	74 02                	je     4047ce <call_gmon_start+0x12>
  4047cc:	ff d0                	callq  *%rax
  4047ce:	48 83 c4 08          	add    $0x8,%rsp
  4047d2:	c3                   	retq   
  4047d3:	90                   	nop
  4047d4:	90                   	nop
  4047d5:	90                   	nop
  4047d6:	90                   	nop
  4047d7:	90                   	nop
  4047d8:	90                   	nop
  4047d9:	90                   	nop
  4047da:	90                   	nop
  4047db:	90                   	nop
  4047dc:	90                   	nop
  4047dd:	90                   	nop
  4047de:	90                   	nop
  4047df:	90                   	nop

00000000004047e0 <deregister_tm_clones>:
  4047e0:	b8 27 45 61 00       	mov    $0x614527,%eax
  4047e5:	55                   	push   %rbp
  4047e6:	48 2d 20 45 61 00    	sub    $0x614520,%rax
  4047ec:	48 83 f8 0e          	cmp    $0xe,%rax
  4047f0:	48 89 e5             	mov    %rsp,%rbp
  4047f3:	76 1b                	jbe    404810 <deregister_tm_clones+0x30>
  4047f5:	b8 00 00 00 00       	mov    $0x0,%eax
  4047fa:	48 85 c0             	test   %rax,%rax
  4047fd:	74 11                	je     404810 <deregister_tm_clones+0x30>
  4047ff:	5d                   	pop    %rbp
  404800:	bf 20 45 61 00       	mov    $0x614520,%edi
  404805:	ff e0                	jmpq   *%rax
  404807:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40480e:	00 00 
  404810:	5d                   	pop    %rbp
  404811:	c3                   	retq   
  404812:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  404819:	1f 84 00 00 00 00 00 

0000000000404820 <register_tm_clones>:
  404820:	be 20 45 61 00       	mov    $0x614520,%esi
  404825:	55                   	push   %rbp
  404826:	48 81 ee 20 45 61 00 	sub    $0x614520,%rsi
  40482d:	48 c1 fe 03          	sar    $0x3,%rsi
  404831:	48 89 e5             	mov    %rsp,%rbp
  404834:	48 89 f0             	mov    %rsi,%rax
  404837:	48 c1 e8 3f          	shr    $0x3f,%rax
  40483b:	48 01 c6             	add    %rax,%rsi
  40483e:	48 d1 fe             	sar    %rsi
  404841:	74 15                	je     404858 <register_tm_clones+0x38>
  404843:	b8 00 00 00 00       	mov    $0x0,%eax
  404848:	48 85 c0             	test   %rax,%rax
  40484b:	74 0b                	je     404858 <register_tm_clones+0x38>
  40484d:	5d                   	pop    %rbp
  40484e:	bf 20 45 61 00       	mov    $0x614520,%edi
  404853:	ff e0                	jmpq   *%rax
  404855:	0f 1f 00             	nopl   (%rax)
  404858:	5d                   	pop    %rbp
  404859:	c3                   	retq   
  40485a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000404860 <__do_global_dtors_aux>:
  404860:	80 3d d9 fc 20 00 00 	cmpb   $0x0,0x20fcd9(%rip)        # 614540 <completed.7241>
  404867:	75 11                	jne    40487a <__do_global_dtors_aux+0x1a>
  404869:	55                   	push   %rbp
  40486a:	48 89 e5             	mov    %rsp,%rbp
  40486d:	e8 6e ff ff ff       	callq  4047e0 <deregister_tm_clones>
  404872:	5d                   	pop    %rbp
  404873:	c6 05 c6 fc 20 00 01 	movb   $0x1,0x20fcc6(%rip)        # 614540 <completed.7241>
  40487a:	f3 c3                	repz retq 
  40487c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000404880 <frame_dummy>:
  404880:	bf 20 39 61 00       	mov    $0x613920,%edi
  404885:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  404889:	75 05                	jne    404890 <frame_dummy+0x10>
  40488b:	eb 93                	jmp    404820 <register_tm_clones>
  40488d:	0f 1f 00             	nopl   (%rax)
  404890:	b8 00 00 00 00       	mov    $0x0,%eax
  404895:	48 85 c0             	test   %rax,%rax
  404898:	74 f1                	je     40488b <frame_dummy+0xb>
  40489a:	55                   	push   %rbp
  40489b:	48 89 e5             	mov    %rsp,%rbp
  40489e:	ff d0                	callq  *%rax
  4048a0:	5d                   	pop    %rbp
  4048a1:	e9 7a ff ff ff       	jmpq   404820 <register_tm_clones>
  4048a6:	90                   	nop
  4048a7:	90                   	nop
  4048a8:	90                   	nop
  4048a9:	90                   	nop
  4048aa:	90                   	nop
  4048ab:	90                   	nop
  4048ac:	90                   	nop
  4048ad:	90                   	nop
  4048ae:	90                   	nop
  4048af:	90                   	nop

00000000004048b0 <_ZN6rocket6Config4loadEPKc>:

namespace rocket
{

bool Config::load(const char* file)
{
  4048b0:	41 57                	push   %r15
  4048b2:	41 56                	push   %r14
  4048b4:	41 55                	push   %r13
  4048b6:	41 54                	push   %r12
  4048b8:	55                   	push   %rbp
  4048b9:	53                   	push   %rbx
  4048ba:	48 81 ec 68 05 00 00 	sub    $0x568,%rsp
	  void
	  _M_initialize()
	  {
	    this->_M_header._M_color = _S_red;
	    this->_M_header._M_parent = 0;
	    this->_M_header._M_left = &this->_M_header;
  4048c1:	48 8d 84 24 c0 03 00 	lea    0x3c0(%rsp),%rax
  4048c8:	00 
    ConfigReader cr;

    if (!cr.Load(file))
  4048c9:	48 8d 9c 24 80 00 00 	lea    0x80(%rsp),%rbx
  4048d0:	00 

namespace rocket
{

bool Config::load(const char* file)
{
  4048d1:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
	  _Rb_tree_node_base 	_M_header;
	  size_type 		_M_node_count; // Keeps track of size of tree.

	  _Rb_tree_impl()
	  : _Node_allocator(), _M_key_compare(), _M_header(),
	    _M_node_count(0)
  4048d6:	c7 84 24 c8 03 00 00 	movl   $0x0,0x3c8(%rsp)
  4048dd:	00 00 00 00 
  4048e1:	48 c7 84 24 d0 03 00 	movq   $0x0,0x3d0(%rsp)
  4048e8:	00 00 00 00 00 
	  void
	  _M_initialize()
	  {
	    this->_M_header._M_color = _S_red;
	    this->_M_header._M_parent = 0;
	    this->_M_header._M_left = &this->_M_header;
  4048ed:	49 89 c6             	mov    %rax,%r14
  4048f0:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  4048f5:	48 8d 84 24 c8 03 00 	lea    0x3c8(%rsp),%rax
  4048fc:	00 
    ConfigReader cr;

    if (!cr.Load(file))
  4048fd:	48 89 df             	mov    %rbx,%rdi
	  _Rb_tree_node_base 	_M_header;
	  size_type 		_M_node_count; // Keeps track of size of tree.

	  _Rb_tree_impl()
	  : _Node_allocator(), _M_key_compare(), _M_header(),
	    _M_node_count(0)
  404900:	48 c7 84 24 e8 03 00 	movq   $0x0,0x3e8(%rsp)
  404907:	00 00 00 00 00 
	  void
	  _M_initialize()
	  {
	    this->_M_header._M_color = _S_red;
	    this->_M_header._M_parent = 0;
	    this->_M_header._M_left = &this->_M_header;
  40490c:	48 89 84 24 d8 03 00 	mov    %rax,0x3d8(%rsp)
  404913:	00 
	    this->_M_header._M_right = &this->_M_header;
  404914:	48 89 84 24 e0 03 00 	mov    %rax,0x3e0(%rsp)
  40491b:	00 
  40491c:	48 8d 84 24 b0 03 00 	lea    0x3b0(%rsp),%rax
  404923:	00 
  404924:	48 89 c2             	mov    %rax,%rdx
  404927:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40492c:	e8 ef f4 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404931:	48 89 de             	mov    %rbx,%rsi
  404934:	4c 89 f7             	mov    %r14,%rdi
  404937:	e8 64 4b 00 00       	callq  4094a0 <_ZN6rocket12ConfigReader4LoadERKSs>
  40493c:	88 44 24 4f          	mov    %al,0x4f(%rsp)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404940:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  404947:	00 

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404948:	48 8b 1d 11 f6 20 00 	mov    0x20f611(%rip),%rbx        # 613f60 <_DYNAMIC+0x2d8>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40494f:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404953:	48 39 df             	cmp    %rbx,%rdi
  404956:	0f 85 7c 20 00 00    	jne    4069d8 <_ZN6rocket6Config4loadEPKc+0x2128>
  40495c:	80 7c 24 4f 00       	cmpb   $0x0,0x4f(%rsp)
  404961:	0f 84 91 1d 00 00    	je     4066f8 <_ZN6rocket6Config4loadEPKc+0x1e48>
    {
        return false;
    }

    // log config
    std::string level = cr.GetString("log", "level", "debug");
  404967:	48 8d 84 24 c0 00 00 	lea    0xc0(%rsp),%rax
  40496e:	00 
  40496f:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  404974:	48 8d 35 09 ba 00 00 	lea    0xba09(%rip),%rsi        # 410384 <_IO_stdin_used+0x4>
  40497b:	48 89 c7             	mov    %rax,%rdi
  40497e:	49 89 c6             	mov    %rax,%r14
  404981:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  404986:	e8 95 f4 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40498b:	48 8d 84 24 a0 03 00 	lea    0x3a0(%rsp),%rax
  404992:	00 
  404993:	4c 8d a4 24 b0 00 00 	lea    0xb0(%rsp),%r12
  40499a:	00 
  40499b:	48 8d 35 e8 b9 00 00 	lea    0xb9e8(%rip),%rsi        # 41038a <_IO_stdin_used+0xa>
  4049a2:	48 89 c2             	mov    %rax,%rdx
  4049a5:	4c 89 e7             	mov    %r12,%rdi
  4049a8:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  4049ad:	e8 6e f4 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  4049b2:	48 8d 84 24 90 03 00 	lea    0x390(%rsp),%rax
  4049b9:	00 
  4049ba:	48 8d ac 24 a0 00 00 	lea    0xa0(%rsp),%rbp
  4049c1:	00 
  4049c2:	48 8d 35 dd b9 00 00 	lea    0xb9dd(%rip),%rsi        # 4103a6 <_IO_stdin_used+0x26>
  4049c9:	48 89 c2             	mov    %rax,%rdx
  4049cc:	48 89 ef             	mov    %rbp,%rdi
  4049cf:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  4049d4:	e8 47 f4 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  4049d9:	4c 8d ac 24 90 00 00 	lea    0x90(%rsp),%r13
  4049e0:	00 
  4049e1:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  4049e6:	4d 89 f0             	mov    %r14,%r8
  4049e9:	4c 89 e1             	mov    %r12,%rcx
  4049ec:	48 89 ea             	mov    %rbp,%rdx
  4049ef:	4c 89 ef             	mov    %r13,%rdi
  4049f2:	e8 99 56 00 00       	callq  40a090 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4049f7:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
  4049fe:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4049ff:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404a03:	48 39 df             	cmp    %rbx,%rdi
  404a06:	0f 85 34 25 00 00    	jne    406f40 <_ZN6rocket6Config4loadEPKc+0x2690>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404a0c:	48 8b 84 24 b0 00 00 	mov    0xb0(%rsp),%rax
  404a13:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404a14:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404a18:	48 39 df             	cmp    %rbx,%rdi
  404a1b:	0f 85 0f 21 00 00    	jne    406b30 <_ZN6rocket6Config4loadEPKc+0x2280>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404a21:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
  404a28:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404a29:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404a2d:	48 39 df             	cmp    %rbx,%rdi
  404a30:	0f 85 3a 21 00 00    	jne    406b70 <_ZN6rocket6Config4loadEPKc+0x22c0>
    std::string rotate = cr.GetString("log", "rotate", "daily");
  404a36:	48 8d 84 24 00 01 00 	lea    0x100(%rsp),%rax
  404a3d:	00 
  404a3e:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  404a43:	48 8d 35 46 b9 00 00 	lea    0xb946(%rip),%rsi        # 410390 <_IO_stdin_used+0x10>
  404a4a:	48 89 c7             	mov    %rax,%rdi
  404a4d:	49 89 c7             	mov    %rax,%r15
  404a50:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  404a55:	e8 c6 f3 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404a5a:	4c 8d b4 24 f0 00 00 	lea    0xf0(%rsp),%r14
  404a61:	00 
  404a62:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
  404a67:	48 8d 35 28 b9 00 00 	lea    0xb928(%rip),%rsi        # 410396 <_IO_stdin_used+0x16>
  404a6e:	4c 89 f7             	mov    %r14,%rdi
  404a71:	e8 aa f3 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404a76:	48 8d ac 24 e0 00 00 	lea    0xe0(%rsp),%rbp
  404a7d:	00 
  404a7e:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  404a83:	48 8d 35 1c b9 00 00 	lea    0xb91c(%rip),%rsi        # 4103a6 <_IO_stdin_used+0x26>
  404a8a:	48 89 ef             	mov    %rbp,%rdi
  404a8d:	e8 8e f3 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404a92:	4c 8d a4 24 d0 00 00 	lea    0xd0(%rsp),%r12
  404a99:	00 
  404a9a:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  404a9f:	4d 89 f8             	mov    %r15,%r8
  404aa2:	4c 89 f1             	mov    %r14,%rcx
  404aa5:	48 89 ea             	mov    %rbp,%rdx
  404aa8:	4c 89 e7             	mov    %r12,%rdi
  404aab:	e8 e0 55 00 00       	callq  40a090 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404ab0:	48 8b 84 24 e0 00 00 	mov    0xe0(%rsp),%rax
  404ab7:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404ab8:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404abc:	48 39 df             	cmp    %rbx,%rdi
  404abf:	0f 85 eb 20 00 00    	jne    406bb0 <_ZN6rocket6Config4loadEPKc+0x2300>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404ac5:	48 8b 84 24 f0 00 00 	mov    0xf0(%rsp),%rax
  404acc:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404acd:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404ad1:	48 39 df             	cmp    %rbx,%rdi
  404ad4:	0f 85 26 24 00 00    	jne    406f00 <_ZN6rocket6Config4loadEPKc+0x2650>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404ada:	48 8b 84 24 00 01 00 	mov    0x100(%rsp),%rax
  404ae1:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404ae2:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404ae6:	48 39 df             	cmp    %rbx,%rdi
  404ae9:	0f 85 91 26 00 00    	jne    407180 <_ZN6rocket6Config4loadEPKc+0x28d0>
    _log_cfg.level = _log_cfg.parseLevel(level);
  404aef:	4c 8b 74 24 18       	mov    0x18(%rsp),%r14
  404af4:	4c 89 ee             	mov    %r13,%rsi
  404af7:	49 8d 6e 30          	lea    0x30(%r14),%rbp
  404afb:	48 89 ef             	mov    %rbp,%rdi
  404afe:	e8 2d 6f 00 00       	callq  40ba30 <_ZN9LogConfig10parseLevelERKSs>
  404b03:	41 89 46 38          	mov    %eax,0x38(%r14)
    _log_cfg.rotate = _log_cfg.parseRotate(rotate);
  404b07:	4c 89 e6             	mov    %r12,%rsi
  404b0a:	48 89 ef             	mov    %rbp,%rdi
  404b0d:	e8 9e 6f 00 00       	callq  40bab0 <_ZN9LogConfig11parseRotateERKSs>
    _log_cfg.file = cr.GetString("log", "file", "./log/ff.log");
  404b12:	4c 8d bc 24 30 01 00 	lea    0x130(%rsp),%r15
  404b19:	00 
  404b1a:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  404b1f:	48 8d 35 77 b8 00 00 	lea    0xb877(%rip),%rsi        # 41039d <_IO_stdin_used+0x1d>

    // log config
    std::string level = cr.GetString("log", "level", "debug");
    std::string rotate = cr.GetString("log", "rotate", "daily");
    _log_cfg.level = _log_cfg.parseLevel(level);
    _log_cfg.rotate = _log_cfg.parseRotate(rotate);
  404b26:	41 89 46 3c          	mov    %eax,0x3c(%r14)
    _log_cfg.file = cr.GetString("log", "file", "./log/ff.log");
  404b2a:	4c 89 ff             	mov    %r15,%rdi
  404b2d:	e8 ee f2 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404b32:	4c 8d b4 24 20 01 00 	lea    0x120(%rsp),%r14
  404b39:	00 
  404b3a:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
  404b3f:	48 8d 35 64 b8 00 00 	lea    0xb864(%rip),%rsi        # 4103aa <_IO_stdin_used+0x2a>
  404b46:	4c 89 f7             	mov    %r14,%rdi
  404b49:	e8 d2 f2 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404b4e:	4c 8d ac 24 10 01 00 	lea    0x110(%rsp),%r13
  404b55:	00 
  404b56:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  404b5b:	48 8d 35 44 b8 00 00 	lea    0xb844(%rip),%rsi        # 4103a6 <_IO_stdin_used+0x26>
  404b62:	4c 89 ef             	mov    %r13,%rdi
  404b65:	e8 b6 f2 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404b6a:	4c 8d a4 24 40 01 00 	lea    0x140(%rsp),%r12
  404b71:	00 
  404b72:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  404b77:	4d 89 f8             	mov    %r15,%r8
  404b7a:	4c 89 f1             	mov    %r14,%rcx
  404b7d:	4c 89 ea             	mov    %r13,%rdx
  404b80:	4c 89 e7             	mov    %r12,%rdi
  404b83:	e8 08 55 00 00       	callq  40a090 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_>
      // PR 58265, this should be noexcept.
      basic_string&
      operator=(basic_string&& __str)
      {
	// NB: DR 1204.
	this->swap(__str);
  404b88:	4c 89 e6             	mov    %r12,%rsi
  404b8b:	48 89 ef             	mov    %rbp,%rdi
  404b8e:	e8 7d f6 ff ff       	callq  404210 <_ZNSs4swapERSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404b93:	48 8b 84 24 40 01 00 	mov    0x140(%rsp),%rax
  404b9a:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404b9b:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404b9f:	48 39 df             	cmp    %rbx,%rdi
  404ba2:	0f 85 18 26 00 00    	jne    4071c0 <_ZN6rocket6Config4loadEPKc+0x2910>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404ba8:	48 8b 84 24 10 01 00 	mov    0x110(%rsp),%rax
  404baf:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404bb0:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404bb4:	48 39 df             	cmp    %rbx,%rdi
  404bb7:	0f 85 43 26 00 00    	jne    407200 <_ZN6rocket6Config4loadEPKc+0x2950>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404bbd:	48 8b 84 24 20 01 00 	mov    0x120(%rsp),%rax
  404bc4:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404bc5:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404bc9:	48 39 df             	cmp    %rbx,%rdi
  404bcc:	0f 85 6e 26 00 00    	jne    407240 <_ZN6rocket6Config4loadEPKc+0x2990>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404bd2:	48 8b 84 24 30 01 00 	mov    0x130(%rsp),%rax
  404bd9:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404bda:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404bde:	48 39 df             	cmp    %rbx,%rdi
  404be1:	0f 85 99 26 00 00    	jne    407280 <_ZN6rocket6Config4loadEPKc+0x29d0>
    _log_cfg.size = cr.GetNumber<size_t>("log", "size", 104857600);
  404be7:	4c 8d a4 24 60 01 00 	lea    0x160(%rsp),%r12
  404bee:	00 
  404bef:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  404bf4:	48 8d 35 b4 b7 00 00 	lea    0xb7b4(%rip),%rsi        # 4103af <_IO_stdin_used+0x2f>
  404bfb:	4c 89 e7             	mov    %r12,%rdi
  404bfe:	e8 1d f2 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  404c03:	48 8d 84 24 80 03 00 	lea    0x380(%rsp),%rax
  404c0a:	00 
  404c0b:	4c 8d ac 24 50 01 00 	lea    0x150(%rsp),%r13
  404c12:	00 
  404c13:	48 8d 35 8c b7 00 00 	lea    0xb78c(%rip),%rsi        # 4103a6 <_IO_stdin_used+0x26>
  404c1a:	48 89 c2             	mov    %rax,%rdx
  404c1d:	4c 89 ef             	mov    %r13,%rdi
  404c20:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  404c25:	e8 f6 f1 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  404c2a:	48 8d ac 24 c0 02 00 	lea    0x2c0(%rsp),%rbp
  404c31:	00 
  404c32:	4c 89 ee             	mov    %r13,%rsi
  404c35:	48 89 ef             	mov    %rbp,%rdi
  404c38:	e8 83 f0 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  404c3d:	48 8d 35 70 b7 00 00 	lea    0xb770(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  404c44:	ba 01 00 00 00       	mov    $0x1,%edx
  404c49:	48 89 ef             	mov    %rbp,%rdi
  404c4c:	e8 ff ed ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  404c51:	4c 89 e6             	mov    %r12,%rsi
  404c54:	48 89 ef             	mov    %rbp,%rdi
  404c57:	e8 e4 f5 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  404c5c:	48 8b 10             	mov    (%rax),%rdx
  404c5f:	48 89 94 24 b0 02 00 	mov    %rdx,0x2b0(%rsp)
  404c66:	00 
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  404c67:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  404c6b:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404c6e:	48 8b 84 24 c0 02 00 	mov    0x2c0(%rsp),%rax
  404c75:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404c76:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404c7a:	48 39 df             	cmp    %rbx,%rdi
  404c7d:	0f 85 6d 1e 00 00    	jne    406af0 <_ZN6rocket6Config4loadEPKc+0x2240>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  404c83:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  404c88:	48 8d 84 24 b0 02 00 	lea    0x2b0(%rsp),%rax
  404c8f:	00 
  404c90:	48 89 c6             	mov    %rax,%rsi
  404c93:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  404c98:	4c 89 f7             	mov    %r14,%rdi
                                     const string& key,
                                     T default_value = 0)
    {
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
  404c9b:	4d 8d 76 08          	lea    0x8(%r14),%r14
  404c9f:	e8 5c 39 00 00       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
  404ca4:	49 39 c6             	cmp    %rax,%r14
  404ca7:	0f 84 53 1c 00 00    	je     406900 <_ZN6rocket6Config4loadEPKc+0x2050>
  404cad:	4c 8b bc 24 d0 03 00 	mov    0x3d0(%rsp),%r15
  404cb4:	00 
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  404cb5:	4d 85 ff             	test   %r15,%r15
  404cb8:	0f 84 05 1c 00 00    	je     4068c3 <_ZN6rocket6Config4loadEPKc+0x2013>
  404cbe:	48 8b ac 24 b0 02 00 	mov    0x2b0(%rsp),%rbp
  404cc5:	00 
  404cc6:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
  404cca:	eb 17                	jmp    404ce3 <_ZN6rocket6Config4loadEPKc+0x433>
  404ccc:	0f 1f 40 00          	nopl   0x0(%rax)
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  404cd0:	44 89 e8             	mov    %r13d,%eax
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  404cd3:	85 c0                	test   %eax,%eax
  404cd5:	78 3f                	js     404d16 <_ZN6rocket6Config4loadEPKc+0x466>
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  404cd7:	4d 89 fe             	mov    %r15,%r14
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  404cda:	4d 8b 7f 10          	mov    0x10(%r15),%r15
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  404cde:	4d 85 ff             	test   %r15,%r15
  404ce1:	74 3c                	je     404d1f <_ZN6rocket6Config4loadEPKc+0x46f>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404ce3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  404ce7:	4c 89 e2             	mov    %r12,%rdx
		< static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }
  404cea:	48 89 ee             	mov    %rbp,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  404ced:	4c 8b 6f e8          	mov    -0x18(%rdi),%r13
  404cf1:	4d 39 e5             	cmp    %r12,%r13
  404cf4:	49 0f 46 d5          	cmovbe %r13,%rdx
  404cf8:	e8 f3 f2 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  404cfd:	85 c0                	test   %eax,%eax
  404cff:	75 d2                	jne    404cd3 <_ZN6rocket6Config4loadEPKc+0x423>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  404d01:	4d 29 e5             	sub    %r12,%r13

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  404d04:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  404d0b:	7f ca                	jg     404cd7 <_ZN6rocket6Config4loadEPKc+0x427>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  404d0d:	49 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%r13
  404d14:	7d ba                	jge    404cd0 <_ZN6rocket6Config4loadEPKc+0x420>
  404d16:	4d 8b 7f 18          	mov    0x18(%r15),%r15
  404d1a:	4d 85 ff             	test   %r15,%r15
  404d1d:	75 c4                	jne    404ce3 <_ZN6rocket6Config4loadEPKc+0x433>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  404d1f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  404d24:	48 83 c0 08          	add    $0x8,%rax
  404d28:	49 39 c6             	cmp    %rax,%r14
  404d2b:	0f 84 92 1b 00 00    	je     4068c3 <_ZN6rocket6Config4loadEPKc+0x2013>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404d31:	49 8b 76 20          	mov    0x20(%r14),%rsi
  404d35:	4c 89 e2             	mov    %r12,%rdx
  404d38:	48 89 ef             	mov    %rbp,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  404d3b:	4c 8b 6e e8          	mov    -0x18(%rsi),%r13
  404d3f:	4d 39 e5             	cmp    %r12,%r13
  404d42:	49 0f 46 d5          	cmovbe %r13,%rdx
  404d46:	e8 a5 f2 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  404d4b:	85 c0                	test   %eax,%eax
  404d4d:	0f 85 68 1b 00 00    	jne    4068bb <_ZN6rocket6Config4loadEPKc+0x200b>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  404d53:	4c 89 e1             	mov    %r12,%rcx
  404d56:	4c 29 e9             	sub    %r13,%rcx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  404d59:	48 81 f9 ff ff ff 7f 	cmp    $0x7fffffff,%rcx
  404d60:	0f 8e 4a 1b 00 00    	jle    4068b0 <_ZN6rocket6Config4loadEPKc+0x2000>
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
  404d66:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  404d6d:	00 
  404d6e:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  404d72:	e8 a9 ed ff ff       	callq  403b20 <_ZNSt8ios_baseC2Ev@plt>
  404d77:	4c 8b 2d 32 f1 20 00 	mov    0x20f132(%rip),%r13        # 613eb0 <_DYNAMIC+0x228>
  404d7e:	c6 84 24 30 05 00 00 	movb   $0x0,0x530(%rsp)
  404d85:	00 
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
  404d86:	48 89 ef             	mov    %rbp,%rdi
  404d89:	48 c7 84 24 28 05 00 	movq   $0x0,0x528(%rsp)
  404d90:	00 00 00 00 00 
  404d95:	c6 84 24 31 05 00 00 	movb   $0x0,0x531(%rsp)
  404d9c:	00 
  404d9d:	31 f6                	xor    %esi,%esi
  404d9f:	48 c7 84 24 38 05 00 	movq   $0x0,0x538(%rsp)
  404da6:	00 00 00 00 00 
  404dab:	48 c7 84 24 40 05 00 	movq   $0x0,0x540(%rsp)
  404db2:	00 00 00 00 00 
  404db7:	49 8d 45 10          	lea    0x10(%r13),%rax
  404dbb:	48 c7 84 24 48 05 00 	movq   $0x0,0x548(%rsp)
  404dc2:	00 00 00 00 00 
  404dc7:	48 c7 84 24 50 05 00 	movq   $0x0,0x550(%rsp)
  404dce:	00 00 00 00 00 
  404dd3:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  404dda:	00 
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
  404ddb:	48 8b 05 e6 f0 20 00 	mov    0x20f0e6(%rip),%rax        # 613ec8 <_DYNAMIC+0x240>
  404de2:	4c 8b 78 08          	mov    0x8(%rax),%r15
  404de6:	48 8b 40 10          	mov    0x10(%rax),%rax
  404dea:	48 89 c1             	mov    %rax,%rcx
  404ded:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  404df2:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  404df6:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  404dfd:	00 
  404dfe:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  404e05:	00 
  404e06:	48 c7 84 24 f8 03 00 	movq   $0x0,0x3f8(%rsp)
  404e0d:	00 00 00 00 00 
      { this->init(0); }
  404e12:	49 03 7f e8          	add    -0x18(%r15),%rdi
  404e16:	e8 e5 f0 ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  string class does its own memory management.
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
  404e1b:	4c 8b 25 46 f1 20 00 	mov    0x20f146(%rip),%r12        # 613f68 <_DYNAMIC+0x2e0>
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), 
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale()) 
  404e22:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  404e26:	48 c7 84 24 08 04 00 	movq   $0x0,0x408(%rsp)
  404e2d:	00 00 00 00 00 
  404e32:	48 c7 84 24 10 04 00 	movq   $0x0,0x410(%rsp)
  404e39:	00 00 00 00 00 
  404e3e:	48 c7 84 24 18 04 00 	movq   $0x0,0x418(%rsp)
  404e45:	00 00 00 00 00 
  404e4a:	48 c7 84 24 20 04 00 	movq   $0x0,0x420(%rsp)
  404e51:	00 00 00 00 00 
  404e56:	48 c7 84 24 28 04 00 	movq   $0x0,0x428(%rsp)
  404e5d:	00 00 00 00 00 
  404e62:	49 8d 44 24 18       	lea    0x18(%r12),%rax
  404e67:	48 c7 84 24 30 04 00 	movq   $0x0,0x430(%rsp)
  404e6e:	00 00 00 00 00 
  404e73:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  404e7a:	00 
  404e7b:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  404e80:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  404e87:	00 
  404e88:	48 8b 05 c9 f0 20 00 	mov    0x20f0c9(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  404e8f:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  404e94:	48 83 c0 10          	add    $0x10,%rax
  404e98:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  404e9f:	00 
  404ea0:	e8 db ef ff ff       	callq  403e80 <_ZNSt6localeC1Ev@plt>
       *  own default ctor.
      */
      explicit
      basic_stringbuf(const __string_type& __str,
		      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
  404ea5:	48 8b 05 fc ef 20 00 	mov    0x20effc(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  404eac:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  404eb1:	48 8d 7d 58          	lea    0x58(%rbp),%rdi
  404eb5:	c7 84 24 40 04 00 00 	movl   $0x0,0x440(%rsp)
  404ebc:	00 00 00 00 
  404ec0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  404ec5:	48 83 c0 10          	add    $0x10,%rax
  404ec9:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  404ed0:	00 
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404ed1:	49 8b 76 28          	mov    0x28(%r14),%rsi
  404ed5:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  404ed9:	e8 72 ec ff ff       	callq  403b50 <_ZNSsC1EPKcmRKSaIcE@plt>
      {
	_M_mode = __mode;
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  404ede:	48 8b b4 24 48 04 00 	mov    0x448(%rsp),%rsi
  404ee5:	00 
  404ee6:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  404eea:	31 c9                	xor    %ecx,%ecx
  404eec:	31 d2                	xor    %edx,%edx
    protected:
      // Common initialization code goes here.
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
	_M_mode = __mode;
  404eee:	c7 84 24 40 04 00 00 	movl   $0x8,0x440(%rsp)
  404ef5:	08 00 00 00 
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  404ef9:	e8 b2 f0 ff ff       	callq  403fb0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm@plt>
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
  404efe:	48 8d 75 10          	lea    0x10(%rbp),%rsi
  404f02:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  404f06:	e8 f5 ef ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }
  404f0b:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  404f10:	48 89 ef             	mov    %rbp,%rdi
        {
            istringstream iss(_m[name]);
            T num = 0;
  404f13:	48 c7 84 24 b0 03 00 	movq   $0x0,0x3b0(%rsp)
  404f1a:	00 00 00 00 00 
  404f1f:	e8 8c eb ff ff       	callq  403ab0 <_ZNSi10_M_extractImEERSiRT_@plt>
       *
       *  The buffer is deallocated by the stringbuf object, not the
       *  formatting stream.
      */
      ~basic_istringstream()
      { }
  404f24:	49 8d 44 24 18       	lea    0x18(%r12),%rax
            iss >> num;
            return num;
  404f29:	4c 8b b4 24 b0 03 00 	mov    0x3b0(%rsp),%r14
  404f30:	00 
  404f31:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  404f38:	00 
  404f39:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  404f3e:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  404f45:	00 
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  404f46:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  404f4b:	48 83 c0 10          	add    $0x10,%rax
  404f4f:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  404f56:	00 
  404f57:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  404f5e:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404f5f:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404f63:	48 39 df             	cmp    %rbx,%rdi
  404f66:	0f 85 bd 28 00 00    	jne    407829 <_ZN6rocket6Config4loadEPKc+0x2f79>

  public:
      /// Destructor deallocates no buffer space.
      virtual 
      ~basic_streambuf() 
      { }
  404f6c:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  404f71:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  404f75:	48 83 c0 10          	add    $0x10,%rax
  404f79:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  404f80:	00 
  404f81:	e8 2a f2 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
  404f86:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  404f8a:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  404f8f:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  404f93:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  404f9a:	00 
  404f9b:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  404fa2:	00 
  404fa3:	49 8d 45 10          	lea    0x10(%r13),%rax
  404fa7:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  404fae:	00 
  404faf:	e8 ac ef ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404fb4:	48 8b 84 24 b0 02 00 	mov    0x2b0(%rsp),%rax
  404fbb:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404fbc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404fc0:	48 39 df             	cmp    %rbx,%rdi
  404fc3:	0f 85 b7 23 00 00    	jne    407380 <_ZN6rocket6Config4loadEPKc+0x2ad0>
  404fc9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  404fce:	4c 89 70 48          	mov    %r14,0x48(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404fd2:	48 8b 84 24 50 01 00 	mov    0x150(%rsp),%rax
  404fd9:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404fda:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404fde:	48 39 df             	cmp    %rbx,%rdi
  404fe1:	0f 85 59 23 00 00    	jne    407340 <_ZN6rocket6Config4loadEPKc+0x2a90>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  404fe7:	48 8b 84 24 60 01 00 	mov    0x160(%rsp),%rax
  404fee:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  404fef:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  404ff3:	48 39 df             	cmp    %rbx,%rdi
  404ff6:	0f 85 04 23 00 00    	jne    407300 <_ZN6rocket6Config4loadEPKc+0x2a50>
    _log_cfg.count = cr.GetNumber<unsigned>("log", "count", 50);
  404ffc:	4c 8d a4 24 80 01 00 	lea    0x180(%rsp),%r12
  405003:	00 
  405004:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  405009:	48 8d 35 a6 b3 00 00 	lea    0xb3a6(%rip),%rsi        # 4103b6 <_IO_stdin_used+0x36>
  405010:	4c 89 e7             	mov    %r12,%rdi
  405013:	e8 08 ee ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  405018:	4c 8d ac 24 70 01 00 	lea    0x170(%rsp),%r13
  40501f:	00 
  405020:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  405025:	48 8d 35 7a b3 00 00 	lea    0xb37a(%rip),%rsi        # 4103a6 <_IO_stdin_used+0x26>
  40502c:	4c 89 ef             	mov    %r13,%rdi
  40502f:	e8 ec ed ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  405034:	48 8d ac 24 f0 02 00 	lea    0x2f0(%rsp),%rbp
  40503b:	00 
  40503c:	4c 89 ee             	mov    %r13,%rsi
  40503f:	48 89 ef             	mov    %rbp,%rdi
  405042:	e8 79 ec ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  405047:	48 8d 35 66 b3 00 00 	lea    0xb366(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  40504e:	ba 01 00 00 00       	mov    $0x1,%edx
  405053:	48 89 ef             	mov    %rbp,%rdi
  405056:	e8 f5 e9 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  40505b:	4c 89 e6             	mov    %r12,%rsi
  40505e:	48 89 ef             	mov    %rbp,%rdi
  405061:	e8 da f1 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  405066:	48 8b 10             	mov    (%rax),%rdx
  405069:	48 89 94 24 e0 02 00 	mov    %rdx,0x2e0(%rsp)
  405070:	00 
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  405071:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  405075:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405078:	48 8b 84 24 f0 02 00 	mov    0x2f0(%rsp),%rax
  40507f:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405080:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405084:	48 39 df             	cmp    %rbx,%rdi
  405087:	0f 85 33 22 00 00    	jne    4072c0 <_ZN6rocket6Config4loadEPKc+0x2a10>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  40508d:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  405092:	48 8d 84 24 e0 02 00 	lea    0x2e0(%rsp),%rax
  405099:	00 
  40509a:	48 89 c6             	mov    %rax,%rsi
  40509d:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  4050a2:	4c 89 f7             	mov    %r14,%rdi
                                     const string& key,
                                     T default_value = 0)
    {
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
  4050a5:	4d 8d 76 08          	lea    0x8(%r14),%r14
  4050a9:	e8 52 35 00 00       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
  4050ae:	49 39 c6             	cmp    %rax,%r14
  4050b1:	0f 84 d1 18 00 00    	je     406988 <_ZN6rocket6Config4loadEPKc+0x20d8>
  4050b7:	4c 8b bc 24 d0 03 00 	mov    0x3d0(%rsp),%r15
  4050be:	00 
  4050bf:	4d 85 ff             	test   %r15,%r15
  4050c2:	0f 84 ab 17 00 00    	je     406873 <_ZN6rocket6Config4loadEPKc+0x1fc3>
  4050c8:	48 8b ac 24 e0 02 00 	mov    0x2e0(%rsp),%rbp
  4050cf:	00 
  4050d0:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
  4050d4:	eb 1d                	jmp    4050f3 <_ZN6rocket6Config4loadEPKc+0x843>
  4050d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4050dd:	00 00 00 
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4050e0:	44 89 e8             	mov    %r13d,%eax
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  4050e3:	85 c0                	test   %eax,%eax
  4050e5:	78 3f                	js     405126 <_ZN6rocket6Config4loadEPKc+0x876>
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  4050e7:	4d 89 fe             	mov    %r15,%r14
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  4050ea:	4d 8b 7f 10          	mov    0x10(%r15),%r15
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  4050ee:	4d 85 ff             	test   %r15,%r15
  4050f1:	74 3c                	je     40512f <_ZN6rocket6Config4loadEPKc+0x87f>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4050f3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4050f7:	4c 89 e2             	mov    %r12,%rdx
  4050fa:	48 89 ee             	mov    %rbp,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  4050fd:	4c 8b 6f e8          	mov    -0x18(%rdi),%r13
  405101:	4d 39 e5             	cmp    %r12,%r13
  405104:	49 0f 46 d5          	cmovbe %r13,%rdx
  405108:	e8 e3 ee ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40510d:	85 c0                	test   %eax,%eax
  40510f:	75 d2                	jne    4050e3 <_ZN6rocket6Config4loadEPKc+0x833>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  405111:	4d 29 e5             	sub    %r12,%r13

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  405114:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  40511b:	7f ca                	jg     4050e7 <_ZN6rocket6Config4loadEPKc+0x837>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  40511d:	49 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%r13
  405124:	7d ba                	jge    4050e0 <_ZN6rocket6Config4loadEPKc+0x830>
  405126:	4d 8b 7f 18          	mov    0x18(%r15),%r15
  40512a:	4d 85 ff             	test   %r15,%r15
  40512d:	75 c4                	jne    4050f3 <_ZN6rocket6Config4loadEPKc+0x843>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40512f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  405134:	48 83 c0 08          	add    $0x8,%rax
  405138:	49 39 c6             	cmp    %rax,%r14
  40513b:	0f 84 32 17 00 00    	je     406873 <_ZN6rocket6Config4loadEPKc+0x1fc3>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405141:	49 8b 76 20          	mov    0x20(%r14),%rsi
  405145:	4c 89 e2             	mov    %r12,%rdx
  405148:	48 89 ef             	mov    %rbp,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40514b:	4c 8b 6e e8          	mov    -0x18(%rsi),%r13
  40514f:	4d 39 e5             	cmp    %r12,%r13
  405152:	49 0f 46 d5          	cmovbe %r13,%rdx
  405156:	e8 95 ee ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40515b:	85 c0                	test   %eax,%eax
  40515d:	0f 85 08 17 00 00    	jne    40686b <_ZN6rocket6Config4loadEPKc+0x1fbb>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  405163:	4c 89 e1             	mov    %r12,%rcx
  405166:	4c 29 e9             	sub    %r13,%rcx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  405169:	48 81 f9 ff ff ff 7f 	cmp    $0x7fffffff,%rcx
  405170:	0f 8e ea 16 00 00    	jle    406860 <_ZN6rocket6Config4loadEPKc+0x1fb0>
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
  405176:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  40517d:	00 
  40517e:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405182:	e8 99 e9 ff ff       	callq  403b20 <_ZNSt8ios_baseC2Ev@plt>
  405187:	4c 8b 2d 22 ed 20 00 	mov    0x20ed22(%rip),%r13        # 613eb0 <_DYNAMIC+0x228>
  40518e:	c6 84 24 30 05 00 00 	movb   $0x0,0x530(%rsp)
  405195:	00 
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
  405196:	48 89 ef             	mov    %rbp,%rdi
  405199:	48 c7 84 24 28 05 00 	movq   $0x0,0x528(%rsp)
  4051a0:	00 00 00 00 00 
  4051a5:	c6 84 24 31 05 00 00 	movb   $0x0,0x531(%rsp)
  4051ac:	00 
  4051ad:	31 f6                	xor    %esi,%esi
  4051af:	48 c7 84 24 38 05 00 	movq   $0x0,0x538(%rsp)
  4051b6:	00 00 00 00 00 
  4051bb:	48 c7 84 24 40 05 00 	movq   $0x0,0x540(%rsp)
  4051c2:	00 00 00 00 00 
  4051c7:	49 8d 45 10          	lea    0x10(%r13),%rax
  4051cb:	48 c7 84 24 48 05 00 	movq   $0x0,0x548(%rsp)
  4051d2:	00 00 00 00 00 
  4051d7:	48 c7 84 24 50 05 00 	movq   $0x0,0x550(%rsp)
  4051de:	00 00 00 00 00 
  4051e3:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  4051ea:	00 
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
  4051eb:	48 8b 05 d6 ec 20 00 	mov    0x20ecd6(%rip),%rax        # 613ec8 <_DYNAMIC+0x240>
  4051f2:	4c 8b 78 08          	mov    0x8(%rax),%r15
  4051f6:	48 8b 40 10          	mov    0x10(%rax),%rax
  4051fa:	48 89 c1             	mov    %rax,%rcx
  4051fd:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  405202:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  405206:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  40520d:	00 
  40520e:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  405215:	00 
  405216:	48 c7 84 24 f8 03 00 	movq   $0x0,0x3f8(%rsp)
  40521d:	00 00 00 00 00 
      { this->init(0); }
  405222:	49 03 7f e8          	add    -0x18(%r15),%rdi
  405226:	e8 d5 ec ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  string class does its own memory management.
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
  40522b:	4c 8b 25 36 ed 20 00 	mov    0x20ed36(%rip),%r12        # 613f68 <_DYNAMIC+0x2e0>
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), 
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale()) 
  405232:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  405236:	48 c7 84 24 08 04 00 	movq   $0x0,0x408(%rsp)
  40523d:	00 00 00 00 00 
  405242:	48 c7 84 24 10 04 00 	movq   $0x0,0x410(%rsp)
  405249:	00 00 00 00 00 
  40524e:	48 c7 84 24 18 04 00 	movq   $0x0,0x418(%rsp)
  405255:	00 00 00 00 00 
  40525a:	48 c7 84 24 20 04 00 	movq   $0x0,0x420(%rsp)
  405261:	00 00 00 00 00 
  405266:	48 c7 84 24 28 04 00 	movq   $0x0,0x428(%rsp)
  40526d:	00 00 00 00 00 
  405272:	49 8d 44 24 18       	lea    0x18(%r12),%rax
  405277:	48 c7 84 24 30 04 00 	movq   $0x0,0x430(%rsp)
  40527e:	00 00 00 00 00 
  405283:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  40528a:	00 
  40528b:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  405290:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405297:	00 
  405298:	48 8b 05 b9 ec 20 00 	mov    0x20ecb9(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  40529f:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  4052a4:	48 83 c0 10          	add    $0x10,%rax
  4052a8:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4052af:	00 
  4052b0:	e8 cb eb ff ff       	callq  403e80 <_ZNSt6localeC1Ev@plt>
       *  own default ctor.
      */
      explicit
      basic_stringbuf(const __string_type& __str,
		      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
  4052b5:	48 8b 05 ec eb 20 00 	mov    0x20ebec(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  4052bc:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  4052c1:	48 8d 7d 58          	lea    0x58(%rbp),%rdi
  4052c5:	c7 84 24 40 04 00 00 	movl   $0x0,0x440(%rsp)
  4052cc:	00 00 00 00 
  4052d0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  4052d5:	48 83 c0 10          	add    $0x10,%rax
  4052d9:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4052e0:	00 
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4052e1:	49 8b 76 28          	mov    0x28(%r14),%rsi
  4052e5:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  4052e9:	e8 62 e8 ff ff       	callq  403b50 <_ZNSsC1EPKcmRKSaIcE@plt>
      {
	_M_mode = __mode;
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  4052ee:	48 8b b4 24 48 04 00 	mov    0x448(%rsp),%rsi
  4052f5:	00 
  4052f6:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  4052fa:	31 c9                	xor    %ecx,%ecx
  4052fc:	31 d2                	xor    %edx,%edx
    protected:
      // Common initialization code goes here.
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
	_M_mode = __mode;
  4052fe:	c7 84 24 40 04 00 00 	movl   $0x8,0x440(%rsp)
  405305:	08 00 00 00 
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  405309:	e8 a2 ec ff ff       	callq  403fb0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm@plt>
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
  40530e:	48 8d 75 10          	lea    0x10(%rbp),%rsi
  405312:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405316:	e8 e5 eb ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }
  40531b:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  405320:	48 89 ef             	mov    %rbp,%rdi
        {
            istringstream iss(_m[name]);
            T num = 0;
  405323:	c7 84 24 b0 03 00 00 	movl   $0x0,0x3b0(%rsp)
  40532a:	00 00 00 00 
  40532e:	e8 fd e7 ff ff       	callq  403b30 <_ZNSi10_M_extractIjEERSiRT_@plt>
       *
       *  The buffer is deallocated by the stringbuf object, not the
       *  formatting stream.
      */
      ~basic_istringstream()
      { }
  405333:	49 8d 44 24 18       	lea    0x18(%r12),%rax
            iss >> num;
            return num;
  405338:	44 8b b4 24 b0 03 00 	mov    0x3b0(%rsp),%r14d
  40533f:	00 
  405340:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  405347:	00 
  405348:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  40534d:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405354:	00 
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  405355:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40535a:	48 83 c0 10          	add    $0x10,%rax
  40535e:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405365:	00 
  405366:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  40536d:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40536e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405372:	48 39 df             	cmp    %rbx,%rdi
  405375:	0f 85 41 25 00 00    	jne    4078bc <_ZN6rocket6Config4loadEPKc+0x300c>

  public:
      /// Destructor deallocates no buffer space.
      virtual 
      ~basic_streambuf() 
      { }
  40537b:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  405380:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  405384:	48 83 c0 10          	add    $0x10,%rax
  405388:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  40538f:	00 
  405390:	e8 1b ee ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
  405395:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  405399:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  40539e:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  4053a2:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  4053a9:	00 
  4053aa:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  4053b1:	00 
  4053b2:	49 8d 45 10          	lea    0x10(%r13),%rax
  4053b6:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  4053bd:	00 
  4053be:	e8 9d eb ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4053c3:	48 8b 84 24 e0 02 00 	mov    0x2e0(%rsp),%rax
  4053ca:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4053cb:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4053cf:	48 39 df             	cmp    %rbx,%rdi
  4053d2:	0f 85 d8 20 00 00    	jne    4074b0 <_ZN6rocket6Config4loadEPKc+0x2c00>
  4053d8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4053dd:	44 89 70 40          	mov    %r14d,0x40(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4053e1:	48 8b 84 24 70 01 00 	mov    0x170(%rsp),%rax
  4053e8:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4053e9:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4053ed:	48 39 df             	cmp    %rbx,%rdi
  4053f0:	0f 85 7a 20 00 00    	jne    407470 <_ZN6rocket6Config4loadEPKc+0x2bc0>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4053f6:	48 8b 84 24 80 01 00 	mov    0x180(%rsp),%rax
  4053fd:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4053fe:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405402:	48 39 df             	cmp    %rbx,%rdi
  405405:	0f 85 25 20 00 00    	jne    407430 <_ZN6rocket6Config4loadEPKc+0x2b80>

    // server config
    _ip = cr.GetString("server", "ip", "0.0.0.0");
  40540b:	4c 8d b4 24 b0 01 00 	lea    0x1b0(%rsp),%r14
  405412:	00 
  405413:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  405418:	48 8d 35 9d af 00 00 	lea    0xaf9d(%rip),%rsi        # 4103bc <_IO_stdin_used+0x3c>
  40541f:	4c 89 f7             	mov    %r14,%rdi
  405422:	e8 f9 e9 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  405427:	4c 8d ac 24 a0 01 00 	lea    0x1a0(%rsp),%r13
  40542e:	00 
  40542f:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
  405434:	48 8d 35 89 af 00 00 	lea    0xaf89(%rip),%rsi        # 4103c4 <_IO_stdin_used+0x44>
  40543b:	4c 89 ef             	mov    %r13,%rdi
  40543e:	e8 dd e9 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  405443:	4c 8d a4 24 90 01 00 	lea    0x190(%rsp),%r12
  40544a:	00 
  40544b:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  405450:	48 8d 35 41 b9 00 00 	lea    0xb941(%rip),%rsi        # 410d98 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x78>
  405457:	4c 89 e7             	mov    %r12,%rdi
  40545a:	e8 c1 e9 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40545f:	48 8d ac 24 c0 01 00 	lea    0x1c0(%rsp),%rbp
  405466:	00 
  405467:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  40546c:	4d 89 f0             	mov    %r14,%r8
  40546f:	4c 89 e9             	mov    %r13,%rcx
  405472:	4c 89 e2             	mov    %r12,%rdx
  405475:	48 89 ef             	mov    %rbp,%rdi
  405478:	e8 13 4c 00 00       	callq  40a090 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_>
      // PR 58265, this should be noexcept.
      basic_string&
      operator=(basic_string&& __str)
      {
	// NB: DR 1204.
	this->swap(__str);
  40547d:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  405482:	48 89 ee             	mov    %rbp,%rsi
  405485:	e8 86 ed ff ff       	callq  404210 <_ZNSs4swapERSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40548a:	48 8b 84 24 c0 01 00 	mov    0x1c0(%rsp),%rax
  405491:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405492:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405496:	48 39 df             	cmp    %rbx,%rdi
  405499:	0f 85 59 1f 00 00    	jne    4073f8 <_ZN6rocket6Config4loadEPKc+0x2b48>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40549f:	48 8b 84 24 90 01 00 	mov    0x190(%rsp),%rax
  4054a6:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4054a7:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4054ab:	48 39 df             	cmp    %rbx,%rdi
  4054ae:	0f 85 8c 1c 00 00    	jne    407140 <_ZN6rocket6Config4loadEPKc+0x2890>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4054b4:	48 8b 84 24 a0 01 00 	mov    0x1a0(%rsp),%rax
  4054bb:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4054bc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4054c0:	48 39 df             	cmp    %rbx,%rdi
  4054c3:	0f 85 37 1c 00 00    	jne    407100 <_ZN6rocket6Config4loadEPKc+0x2850>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4054c9:	48 8b 84 24 b0 01 00 	mov    0x1b0(%rsp),%rax
  4054d0:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4054d1:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4054d5:	48 39 df             	cmp    %rbx,%rdi
  4054d8:	0f 85 e2 1b 00 00    	jne    4070c0 <_ZN6rocket6Config4loadEPKc+0x2810>

    _port = cr.GetNumber<int>("server", "port", 5555);
  4054de:	4c 8d a4 24 e0 01 00 	lea    0x1e0(%rsp),%r12
  4054e5:	00 
  4054e6:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  4054eb:	48 8d 35 d5 ae 00 00 	lea    0xaed5(%rip),%rsi        # 4103c7 <_IO_stdin_used+0x47>
  4054f2:	4c 89 e7             	mov    %r12,%rdi
  4054f5:	e8 26 e9 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  4054fa:	4c 8d ac 24 d0 01 00 	lea    0x1d0(%rsp),%r13
  405501:	00 
  405502:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  405507:	48 8d 35 8a b8 00 00 	lea    0xb88a(%rip),%rsi        # 410d98 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x78>
  40550e:	4c 89 ef             	mov    %r13,%rdi
  405511:	e8 0a e9 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  405516:	48 8d ac 24 20 03 00 	lea    0x320(%rsp),%rbp
  40551d:	00 
  40551e:	4c 89 ee             	mov    %r13,%rsi
  405521:	48 89 ef             	mov    %rbp,%rdi
  405524:	e8 97 e7 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  405529:	48 8d 35 84 ae 00 00 	lea    0xae84(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  405530:	ba 01 00 00 00       	mov    $0x1,%edx
  405535:	48 89 ef             	mov    %rbp,%rdi
  405538:	e8 13 e5 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  40553d:	4c 89 e6             	mov    %r12,%rsi
  405540:	48 89 ef             	mov    %rbp,%rdi
  405543:	e8 f8 ec ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  405548:	48 8b 10             	mov    (%rax),%rdx
  40554b:	48 89 94 24 10 03 00 	mov    %rdx,0x310(%rsp)
  405552:	00 
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  405553:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  405557:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40555a:	48 8b 84 24 20 03 00 	mov    0x320(%rsp),%rax
  405561:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405562:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405566:	48 39 df             	cmp    %rbx,%rdi
  405569:	0f 85 11 1b 00 00    	jne    407080 <_ZN6rocket6Config4loadEPKc+0x27d0>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  40556f:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  405574:	48 8d 84 24 10 03 00 	lea    0x310(%rsp),%rax
  40557b:	00 
  40557c:	48 89 c6             	mov    %rax,%rsi
  40557f:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  405584:	4c 89 f7             	mov    %r14,%rdi
                                     const string& key,
                                     T default_value = 0)
    {
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
  405587:	4d 8d 76 08          	lea    0x8(%r14),%r14
  40558b:	e8 70 30 00 00       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
  405590:	49 39 c6             	cmp    %rax,%r14
  405593:	0f 84 df 13 00 00    	je     406978 <_ZN6rocket6Config4loadEPKc+0x20c8>
  405599:	4c 8b bc 24 d0 03 00 	mov    0x3d0(%rsp),%r15
  4055a0:	00 
  4055a1:	4d 85 ff             	test   %r15,%r15
  4055a4:	0f 84 79 12 00 00    	je     406823 <_ZN6rocket6Config4loadEPKc+0x1f73>
  4055aa:	48 8b ac 24 10 03 00 	mov    0x310(%rsp),%rbp
  4055b1:	00 
  4055b2:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
  4055b6:	eb 1b                	jmp    4055d3 <_ZN6rocket6Config4loadEPKc+0xd23>
  4055b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4055bf:	00 
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4055c0:	44 89 e8             	mov    %r13d,%eax
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  4055c3:	85 c0                	test   %eax,%eax
  4055c5:	78 3f                	js     405606 <_ZN6rocket6Config4loadEPKc+0xd56>
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  4055c7:	4d 89 fe             	mov    %r15,%r14
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  4055ca:	4d 8b 7f 10          	mov    0x10(%r15),%r15
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  4055ce:	4d 85 ff             	test   %r15,%r15
  4055d1:	74 3c                	je     40560f <_ZN6rocket6Config4loadEPKc+0xd5f>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4055d3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4055d7:	4c 89 e2             	mov    %r12,%rdx
  4055da:	48 89 ee             	mov    %rbp,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  4055dd:	4c 8b 6f e8          	mov    -0x18(%rdi),%r13
  4055e1:	4d 39 e5             	cmp    %r12,%r13
  4055e4:	49 0f 46 d5          	cmovbe %r13,%rdx
  4055e8:	e8 03 ea ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  4055ed:	85 c0                	test   %eax,%eax
  4055ef:	75 d2                	jne    4055c3 <_ZN6rocket6Config4loadEPKc+0xd13>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  4055f1:	4d 29 e5             	sub    %r12,%r13

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  4055f4:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  4055fb:	7f ca                	jg     4055c7 <_ZN6rocket6Config4loadEPKc+0xd17>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  4055fd:	49 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%r13
  405604:	7d ba                	jge    4055c0 <_ZN6rocket6Config4loadEPKc+0xd10>
  405606:	4d 8b 7f 18          	mov    0x18(%r15),%r15
  40560a:	4d 85 ff             	test   %r15,%r15
  40560d:	75 c4                	jne    4055d3 <_ZN6rocket6Config4loadEPKc+0xd23>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40560f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  405614:	48 83 c0 08          	add    $0x8,%rax
  405618:	49 39 c6             	cmp    %rax,%r14
  40561b:	0f 84 02 12 00 00    	je     406823 <_ZN6rocket6Config4loadEPKc+0x1f73>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405621:	49 8b 76 20          	mov    0x20(%r14),%rsi
  405625:	4c 89 e2             	mov    %r12,%rdx
  405628:	48 89 ef             	mov    %rbp,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40562b:	4c 8b 6e e8          	mov    -0x18(%rsi),%r13
  40562f:	4d 39 e5             	cmp    %r12,%r13
  405632:	49 0f 46 d5          	cmovbe %r13,%rdx
  405636:	e8 b5 e9 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40563b:	85 c0                	test   %eax,%eax
  40563d:	0f 85 d8 11 00 00    	jne    40681b <_ZN6rocket6Config4loadEPKc+0x1f6b>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  405643:	4c 89 e1             	mov    %r12,%rcx
  405646:	4c 29 e9             	sub    %r13,%rcx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  405649:	48 81 f9 ff ff ff 7f 	cmp    $0x7fffffff,%rcx
  405650:	0f 8e ba 11 00 00    	jle    406810 <_ZN6rocket6Config4loadEPKc+0x1f60>
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
  405656:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  40565d:	00 
  40565e:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405662:	e8 b9 e4 ff ff       	callq  403b20 <_ZNSt8ios_baseC2Ev@plt>
  405667:	4c 8b 2d 42 e8 20 00 	mov    0x20e842(%rip),%r13        # 613eb0 <_DYNAMIC+0x228>
  40566e:	c6 84 24 30 05 00 00 	movb   $0x0,0x530(%rsp)
  405675:	00 
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
  405676:	48 89 ef             	mov    %rbp,%rdi
  405679:	48 c7 84 24 28 05 00 	movq   $0x0,0x528(%rsp)
  405680:	00 00 00 00 00 
  405685:	c6 84 24 31 05 00 00 	movb   $0x0,0x531(%rsp)
  40568c:	00 
  40568d:	31 f6                	xor    %esi,%esi
  40568f:	48 c7 84 24 38 05 00 	movq   $0x0,0x538(%rsp)
  405696:	00 00 00 00 00 
  40569b:	48 c7 84 24 40 05 00 	movq   $0x0,0x540(%rsp)
  4056a2:	00 00 00 00 00 
  4056a7:	49 8d 45 10          	lea    0x10(%r13),%rax
  4056ab:	48 c7 84 24 48 05 00 	movq   $0x0,0x548(%rsp)
  4056b2:	00 00 00 00 00 
  4056b7:	48 c7 84 24 50 05 00 	movq   $0x0,0x550(%rsp)
  4056be:	00 00 00 00 00 
  4056c3:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  4056ca:	00 
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
  4056cb:	48 8b 05 f6 e7 20 00 	mov    0x20e7f6(%rip),%rax        # 613ec8 <_DYNAMIC+0x240>
  4056d2:	4c 8b 78 08          	mov    0x8(%rax),%r15
  4056d6:	48 8b 40 10          	mov    0x10(%rax),%rax
  4056da:	48 89 c1             	mov    %rax,%rcx
  4056dd:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  4056e2:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  4056e6:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  4056ed:	00 
  4056ee:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  4056f5:	00 
  4056f6:	48 c7 84 24 f8 03 00 	movq   $0x0,0x3f8(%rsp)
  4056fd:	00 00 00 00 00 
      { this->init(0); }
  405702:	49 03 7f e8          	add    -0x18(%r15),%rdi
  405706:	e8 f5 e7 ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  string class does its own memory management.
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
  40570b:	4c 8b 25 56 e8 20 00 	mov    0x20e856(%rip),%r12        # 613f68 <_DYNAMIC+0x2e0>
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), 
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale()) 
  405712:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  405716:	48 c7 84 24 08 04 00 	movq   $0x0,0x408(%rsp)
  40571d:	00 00 00 00 00 
  405722:	48 c7 84 24 10 04 00 	movq   $0x0,0x410(%rsp)
  405729:	00 00 00 00 00 
  40572e:	48 c7 84 24 18 04 00 	movq   $0x0,0x418(%rsp)
  405735:	00 00 00 00 00 
  40573a:	48 c7 84 24 20 04 00 	movq   $0x0,0x420(%rsp)
  405741:	00 00 00 00 00 
  405746:	48 c7 84 24 28 04 00 	movq   $0x0,0x428(%rsp)
  40574d:	00 00 00 00 00 
  405752:	49 8d 44 24 18       	lea    0x18(%r12),%rax
  405757:	48 c7 84 24 30 04 00 	movq   $0x0,0x430(%rsp)
  40575e:	00 00 00 00 00 
  405763:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  40576a:	00 
  40576b:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  405770:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405777:	00 
  405778:	48 8b 05 d9 e7 20 00 	mov    0x20e7d9(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  40577f:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  405784:	48 83 c0 10          	add    $0x10,%rax
  405788:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  40578f:	00 
  405790:	e8 eb e6 ff ff       	callq  403e80 <_ZNSt6localeC1Ev@plt>
       *  own default ctor.
      */
      explicit
      basic_stringbuf(const __string_type& __str,
		      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
  405795:	48 8b 05 0c e7 20 00 	mov    0x20e70c(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  40579c:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  4057a1:	48 8d 7d 58          	lea    0x58(%rbp),%rdi
  4057a5:	c7 84 24 40 04 00 00 	movl   $0x0,0x440(%rsp)
  4057ac:	00 00 00 00 
  4057b0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  4057b5:	48 83 c0 10          	add    $0x10,%rax
  4057b9:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4057c0:	00 
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4057c1:	49 8b 76 28          	mov    0x28(%r14),%rsi
  4057c5:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  4057c9:	e8 82 e3 ff ff       	callq  403b50 <_ZNSsC1EPKcmRKSaIcE@plt>
      {
	_M_mode = __mode;
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  4057ce:	48 8b b4 24 48 04 00 	mov    0x448(%rsp),%rsi
  4057d5:	00 
  4057d6:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  4057da:	31 c9                	xor    %ecx,%ecx
  4057dc:	31 d2                	xor    %edx,%edx
    protected:
      // Common initialization code goes here.
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
	_M_mode = __mode;
  4057de:	c7 84 24 40 04 00 00 	movl   $0x8,0x440(%rsp)
  4057e5:	08 00 00 00 
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  4057e9:	e8 c2 e7 ff ff       	callq  403fb0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm@plt>
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
  4057ee:	48 8d 75 10          	lea    0x10(%rbp),%rsi
  4057f2:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  4057f6:	e8 05 e7 ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
        {
            istringstream iss(_m[name]);
            T num = 0;
            iss >> num;
  4057fb:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  405800:	48 89 ef             	mov    %rbp,%rdi
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
        {
            istringstream iss(_m[name]);
            T num = 0;
  405803:	c7 84 24 b0 03 00 00 	movl   $0x0,0x3b0(%rsp)
  40580a:	00 00 00 00 
            iss >> num;
  40580e:	e8 8d e7 ff ff       	callq  403fa0 <_ZNSirsERi@plt>
       *
       *  The buffer is deallocated by the stringbuf object, not the
       *  formatting stream.
      */
      ~basic_istringstream()
      { }
  405813:	49 8d 44 24 18       	lea    0x18(%r12),%rax
            return num;
  405818:	44 8b b4 24 b0 03 00 	mov    0x3b0(%rsp),%r14d
  40581f:	00 
  405820:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  405827:	00 
  405828:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  40582d:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405834:	00 
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  405835:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40583a:	48 83 c0 10          	add    $0x10,%rax
  40583e:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405845:	00 
  405846:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  40584d:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40584e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405852:	48 39 df             	cmp    %rbx,%rdi
  405855:	0f 85 6c 1f 00 00    	jne    4077c7 <_ZN6rocket6Config4loadEPKc+0x2f17>

  public:
      /// Destructor deallocates no buffer space.
      virtual 
      ~basic_streambuf() 
      { }
  40585b:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  405860:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  405864:	48 83 c0 10          	add    $0x10,%rax
  405868:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  40586f:	00 
  405870:	e8 3b e9 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
  405875:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  405879:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  40587e:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405882:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  405889:	00 
  40588a:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  405891:	00 
  405892:	49 8d 45 10          	lea    0x10(%r13),%rax
  405896:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  40589d:	00 
  40589e:	e8 bd e6 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4058a3:	48 8b 84 24 10 03 00 	mov    0x310(%rsp),%rax
  4058aa:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4058ab:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4058af:	48 39 df             	cmp    %rbx,%rdi
  4058b2:	0f 85 88 17 00 00    	jne    407040 <_ZN6rocket6Config4loadEPKc+0x2790>
  4058b8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4058bd:	44 89 70 08          	mov    %r14d,0x8(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4058c1:	48 8b 84 24 d0 01 00 	mov    0x1d0(%rsp),%rax
  4058c8:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4058c9:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4058cd:	48 39 df             	cmp    %rbx,%rdi
  4058d0:	0f 85 2a 17 00 00    	jne    407000 <_ZN6rocket6Config4loadEPKc+0x2750>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4058d6:	48 8b 84 24 e0 01 00 	mov    0x1e0(%rsp),%rax
  4058dd:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4058de:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4058e2:	48 39 df             	cmp    %rbx,%rdi
  4058e5:	0f 85 d5 16 00 00    	jne    406fc0 <_ZN6rocket6Config4loadEPKc+0x2710>
    if (_port <= 0)
  4058eb:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4058f0:	8b 78 08             	mov    0x8(%rax),%edi
  4058f3:	85 ff                	test   %edi,%edi
  4058f5:	0f 8e 9d 10 00 00    	jle    406998 <_ZN6rocket6Config4loadEPKc+0x20e8>
    {
        _port = 5555;
    }

    _net_nthreads = cr.GetNumber<int>("server", "net_nthreads", 10);
  4058fb:	48 8d ac 24 00 02 00 	lea    0x200(%rsp),%rbp
  405902:	00 
  405903:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  405908:	48 8d 35 bd aa 00 00 	lea    0xaabd(%rip),%rsi        # 4103cc <_IO_stdin_used+0x4c>
  40590f:	48 89 ef             	mov    %rbp,%rdi
  405912:	e8 09 e5 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  405917:	4c 8d a4 24 f0 01 00 	lea    0x1f0(%rsp),%r12
  40591e:	00 
  40591f:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  405924:	48 8d 35 6d b4 00 00 	lea    0xb46d(%rip),%rsi        # 410d98 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x78>
  40592b:	4c 89 e7             	mov    %r12,%rdi
  40592e:	e8 ed e4 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  405933:	48 8d 84 24 50 03 00 	lea    0x350(%rsp),%rax
  40593a:	00 
  40593b:	4c 89 e6             	mov    %r12,%rsi
  40593e:	48 89 c7             	mov    %rax,%rdi
  405941:	49 89 c6             	mov    %rax,%r14
  405944:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  405949:	e8 72 e3 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  40594e:	48 8d 35 5f aa 00 00 	lea    0xaa5f(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  405955:	ba 01 00 00 00       	mov    $0x1,%edx
  40595a:	4c 89 f7             	mov    %r14,%rdi
  40595d:	e8 ee e0 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  405962:	48 89 ee             	mov    %rbp,%rsi
  405965:	4c 89 f7             	mov    %r14,%rdi
  405968:	e8 d3 e8 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40596d:	48 8b 10             	mov    (%rax),%rdx
  405970:	48 89 94 24 40 03 00 	mov    %rdx,0x340(%rsp)
  405977:	00 
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  405978:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  40597c:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40597f:	48 8b 84 24 50 03 00 	mov    0x350(%rsp),%rax
  405986:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405987:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40598b:	48 39 df             	cmp    %rbx,%rdi
  40598e:	0f 85 74 13 00 00    	jne    406d08 <_ZN6rocket6Config4loadEPKc+0x2458>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  405994:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  405999:	48 8d 84 24 40 03 00 	lea    0x340(%rsp),%rax
  4059a0:	00 
  4059a1:	48 89 c6             	mov    %rax,%rsi
  4059a4:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  4059a9:	4c 89 f7             	mov    %r14,%rdi
                                     const string& key,
                                     T default_value = 0)
    {
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
  4059ac:	4d 8d 76 08          	lea    0x8(%r14),%r14
  4059b0:	e8 4b 2c 00 00       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
  4059b5:	49 39 c6             	cmp    %rax,%r14
  4059b8:	0f 84 9a 0f 00 00    	je     406958 <_ZN6rocket6Config4loadEPKc+0x20a8>
  4059be:	4c 8b bc 24 d0 03 00 	mov    0x3d0(%rsp),%r15
  4059c5:	00 
  4059c6:	4d 85 ff             	test   %r15,%r15
  4059c9:	0f 84 04 0e 00 00    	je     4067d3 <_ZN6rocket6Config4loadEPKc+0x1f23>
  4059cf:	48 8b ac 24 40 03 00 	mov    0x340(%rsp),%rbp
  4059d6:	00 
  4059d7:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
  4059db:	eb 16                	jmp    4059f3 <_ZN6rocket6Config4loadEPKc+0x1143>
  4059dd:	0f 1f 00             	nopl   (%rax)
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4059e0:	44 89 e8             	mov    %r13d,%eax
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  4059e3:	85 c0                	test   %eax,%eax
  4059e5:	78 3f                	js     405a26 <_ZN6rocket6Config4loadEPKc+0x1176>
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  4059e7:	4d 89 fe             	mov    %r15,%r14
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  4059ea:	4d 8b 7f 10          	mov    0x10(%r15),%r15
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  4059ee:	4d 85 ff             	test   %r15,%r15
  4059f1:	74 3c                	je     405a2f <_ZN6rocket6Config4loadEPKc+0x117f>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4059f3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4059f7:	4c 89 e2             	mov    %r12,%rdx
  4059fa:	48 89 ee             	mov    %rbp,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  4059fd:	4c 8b 6f e8          	mov    -0x18(%rdi),%r13
  405a01:	4d 39 e5             	cmp    %r12,%r13
  405a04:	49 0f 46 d5          	cmovbe %r13,%rdx
  405a08:	e8 e3 e5 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  405a0d:	85 c0                	test   %eax,%eax
  405a0f:	75 d2                	jne    4059e3 <_ZN6rocket6Config4loadEPKc+0x1133>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  405a11:	4d 29 e5             	sub    %r12,%r13

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  405a14:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  405a1b:	7f ca                	jg     4059e7 <_ZN6rocket6Config4loadEPKc+0x1137>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  405a1d:	49 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%r13
  405a24:	7d ba                	jge    4059e0 <_ZN6rocket6Config4loadEPKc+0x1130>
  405a26:	4d 8b 7f 18          	mov    0x18(%r15),%r15
  405a2a:	4d 85 ff             	test   %r15,%r15
  405a2d:	75 c4                	jne    4059f3 <_ZN6rocket6Config4loadEPKc+0x1143>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  405a2f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  405a34:	48 83 c0 08          	add    $0x8,%rax
  405a38:	49 39 c6             	cmp    %rax,%r14
  405a3b:	0f 84 92 0d 00 00    	je     4067d3 <_ZN6rocket6Config4loadEPKc+0x1f23>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405a41:	49 8b 76 20          	mov    0x20(%r14),%rsi
  405a45:	4c 89 e2             	mov    %r12,%rdx
  405a48:	48 89 ef             	mov    %rbp,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  405a4b:	4c 8b 6e e8          	mov    -0x18(%rsi),%r13
  405a4f:	4d 39 e5             	cmp    %r12,%r13
  405a52:	49 0f 46 d5          	cmovbe %r13,%rdx
  405a56:	e8 95 e5 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  405a5b:	85 c0                	test   %eax,%eax
  405a5d:	0f 85 68 0d 00 00    	jne    4067cb <_ZN6rocket6Config4loadEPKc+0x1f1b>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  405a63:	4c 89 e1             	mov    %r12,%rcx
  405a66:	4c 29 e9             	sub    %r13,%rcx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  405a69:	48 81 f9 ff ff ff 7f 	cmp    $0x7fffffff,%rcx
  405a70:	0f 8e 4a 0d 00 00    	jle    4067c0 <_ZN6rocket6Config4loadEPKc+0x1f10>
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
  405a76:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  405a7d:	00 
  405a7e:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405a82:	e8 99 e0 ff ff       	callq  403b20 <_ZNSt8ios_baseC2Ev@plt>
  405a87:	4c 8b 2d 22 e4 20 00 	mov    0x20e422(%rip),%r13        # 613eb0 <_DYNAMIC+0x228>
  405a8e:	c6 84 24 30 05 00 00 	movb   $0x0,0x530(%rsp)
  405a95:	00 
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
  405a96:	48 89 ef             	mov    %rbp,%rdi
  405a99:	48 c7 84 24 28 05 00 	movq   $0x0,0x528(%rsp)
  405aa0:	00 00 00 00 00 
  405aa5:	c6 84 24 31 05 00 00 	movb   $0x0,0x531(%rsp)
  405aac:	00 
  405aad:	31 f6                	xor    %esi,%esi
  405aaf:	48 c7 84 24 38 05 00 	movq   $0x0,0x538(%rsp)
  405ab6:	00 00 00 00 00 
  405abb:	48 c7 84 24 40 05 00 	movq   $0x0,0x540(%rsp)
  405ac2:	00 00 00 00 00 
  405ac7:	49 8d 45 10          	lea    0x10(%r13),%rax
  405acb:	48 c7 84 24 48 05 00 	movq   $0x0,0x548(%rsp)
  405ad2:	00 00 00 00 00 
  405ad7:	48 c7 84 24 50 05 00 	movq   $0x0,0x550(%rsp)
  405ade:	00 00 00 00 00 
  405ae3:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405aea:	00 
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
  405aeb:	48 8b 05 d6 e3 20 00 	mov    0x20e3d6(%rip),%rax        # 613ec8 <_DYNAMIC+0x240>
  405af2:	4c 8b 78 08          	mov    0x8(%rax),%r15
  405af6:	48 8b 40 10          	mov    0x10(%rax),%rax
  405afa:	48 89 c1             	mov    %rax,%rcx
  405afd:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  405b02:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  405b06:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  405b0d:	00 
  405b0e:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  405b15:	00 
  405b16:	48 c7 84 24 f8 03 00 	movq   $0x0,0x3f8(%rsp)
  405b1d:	00 00 00 00 00 
      { this->init(0); }
  405b22:	49 03 7f e8          	add    -0x18(%r15),%rdi
  405b26:	e8 d5 e3 ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  string class does its own memory management.
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
  405b2b:	4c 8b 25 36 e4 20 00 	mov    0x20e436(%rip),%r12        # 613f68 <_DYNAMIC+0x2e0>
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), 
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale()) 
  405b32:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  405b36:	48 c7 84 24 08 04 00 	movq   $0x0,0x408(%rsp)
  405b3d:	00 00 00 00 00 
  405b42:	48 c7 84 24 10 04 00 	movq   $0x0,0x410(%rsp)
  405b49:	00 00 00 00 00 
  405b4e:	48 c7 84 24 18 04 00 	movq   $0x0,0x418(%rsp)
  405b55:	00 00 00 00 00 
  405b5a:	48 c7 84 24 20 04 00 	movq   $0x0,0x420(%rsp)
  405b61:	00 00 00 00 00 
  405b66:	48 c7 84 24 28 04 00 	movq   $0x0,0x428(%rsp)
  405b6d:	00 00 00 00 00 
  405b72:	49 8d 44 24 18       	lea    0x18(%r12),%rax
  405b77:	48 c7 84 24 30 04 00 	movq   $0x0,0x430(%rsp)
  405b7e:	00 00 00 00 00 
  405b83:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  405b8a:	00 
  405b8b:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  405b90:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405b97:	00 
  405b98:	48 8b 05 b9 e3 20 00 	mov    0x20e3b9(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  405b9f:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  405ba4:	48 83 c0 10          	add    $0x10,%rax
  405ba8:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405baf:	00 
  405bb0:	e8 cb e2 ff ff       	callq  403e80 <_ZNSt6localeC1Ev@plt>
       *  own default ctor.
      */
      explicit
      basic_stringbuf(const __string_type& __str,
		      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
  405bb5:	48 8b 05 ec e2 20 00 	mov    0x20e2ec(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  405bbc:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  405bc1:	48 8d 7d 58          	lea    0x58(%rbp),%rdi
  405bc5:	c7 84 24 40 04 00 00 	movl   $0x0,0x440(%rsp)
  405bcc:	00 00 00 00 
  405bd0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  405bd5:	48 83 c0 10          	add    $0x10,%rax
  405bd9:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405be0:	00 
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405be1:	49 8b 76 28          	mov    0x28(%r14),%rsi
  405be5:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  405be9:	e8 62 df ff ff       	callq  403b50 <_ZNSsC1EPKcmRKSaIcE@plt>
      {
	_M_mode = __mode;
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  405bee:	48 8b b4 24 48 04 00 	mov    0x448(%rsp),%rsi
  405bf5:	00 
  405bf6:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  405bfa:	31 c9                	xor    %ecx,%ecx
  405bfc:	31 d2                	xor    %edx,%edx
    protected:
      // Common initialization code goes here.
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
	_M_mode = __mode;
  405bfe:	c7 84 24 40 04 00 00 	movl   $0x8,0x440(%rsp)
  405c05:	08 00 00 00 
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  405c09:	e8 a2 e3 ff ff       	callq  403fb0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm@plt>
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
  405c0e:	48 8d 75 10          	lea    0x10(%rbp),%rsi
  405c12:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405c16:	e8 e5 e2 ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
        {
            istringstream iss(_m[name]);
            T num = 0;
            iss >> num;
  405c1b:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  405c20:	48 89 ef             	mov    %rbp,%rdi
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
        {
            istringstream iss(_m[name]);
            T num = 0;
  405c23:	c7 84 24 b0 03 00 00 	movl   $0x0,0x3b0(%rsp)
  405c2a:	00 00 00 00 
            iss >> num;
  405c2e:	e8 6d e3 ff ff       	callq  403fa0 <_ZNSirsERi@plt>
       *
       *  The buffer is deallocated by the stringbuf object, not the
       *  formatting stream.
      */
      ~basic_istringstream()
      { }
  405c33:	49 8d 44 24 18       	lea    0x18(%r12),%rax
            return num;
  405c38:	44 8b b4 24 b0 03 00 	mov    0x3b0(%rsp),%r14d
  405c3f:	00 
  405c40:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  405c47:	00 
  405c48:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  405c4d:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405c54:	00 
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  405c55:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  405c5a:	48 83 c0 10          	add    $0x10,%rax
  405c5e:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405c65:	00 
  405c66:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  405c6d:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405c6e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405c72:	48 39 df             	cmp    %rbx,%rdi
  405c75:	0f 85 df 1b 00 00    	jne    40785a <_ZN6rocket6Config4loadEPKc+0x2faa>

  public:
      /// Destructor deallocates no buffer space.
      virtual 
      ~basic_streambuf() 
      { }
  405c7b:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  405c80:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  405c84:	48 83 c0 10          	add    $0x10,%rax
  405c88:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405c8f:	00 
  405c90:	e8 1b e5 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
  405c95:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  405c99:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  405c9e:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405ca2:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  405ca9:	00 
  405caa:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  405cb1:	00 
  405cb2:	49 8d 45 10          	lea    0x10(%r13),%rax
  405cb6:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405cbd:	00 
  405cbe:	e8 9d e2 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405cc3:	48 8b 84 24 40 03 00 	mov    0x340(%rsp),%rax
  405cca:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405ccb:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405ccf:	48 39 df             	cmp    %rbx,%rdi
  405cd2:	0f 85 e8 11 00 00    	jne    406ec0 <_ZN6rocket6Config4loadEPKc+0x2610>
  405cd8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  405cdd:	44 89 70 0c          	mov    %r14d,0xc(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405ce1:	48 8b 84 24 f0 01 00 	mov    0x1f0(%rsp),%rax
  405ce8:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405ce9:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405ced:	48 39 df             	cmp    %rbx,%rdi
  405cf0:	0f 85 8a 11 00 00    	jne    406e80 <_ZN6rocket6Config4loadEPKc+0x25d0>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405cf6:	48 8b 84 24 00 02 00 	mov    0x200(%rsp),%rax
  405cfd:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405cfe:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405d02:	48 39 df             	cmp    %rbx,%rdi
  405d05:	0f 85 35 11 00 00    	jne    406e40 <_ZN6rocket6Config4loadEPKc+0x2590>
    if (_net_nthreads <= 0)
  405d0b:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  405d10:	8b 70 0c             	mov    0xc(%rax),%esi
  405d13:	85 f6                	test   %esi,%esi
  405d15:	0f 8e 8d 0c 00 00    	jle    4069a8 <_ZN6rocket6Config4loadEPKc+0x20f8>
    {
        _net_nthreads = 3;
    }

    _work_nthreads = cr.GetNumber<int>("server", "work_nthreads", 10);
  405d1b:	48 8d ac 24 20 02 00 	lea    0x220(%rsp),%rbp
  405d22:	00 
  405d23:	48 8d 94 24 60 03 00 	lea    0x360(%rsp),%rdx
  405d2a:	00 
  405d2b:	48 8d 35 a7 a6 00 00 	lea    0xa6a7(%rip),%rsi        # 4103d9 <_IO_stdin_used+0x59>
  405d32:	48 89 ef             	mov    %rbp,%rdi
  405d35:	e8 e6 e0 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  405d3a:	4c 8d a4 24 10 02 00 	lea    0x210(%rsp),%r12
  405d41:	00 
  405d42:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
  405d47:	48 8d 35 4a b0 00 00 	lea    0xb04a(%rip),%rsi        # 410d98 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x78>
  405d4e:	4c 89 e7             	mov    %r12,%rdi
  405d51:	e8 ca e0 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  405d56:	4c 8b 74 24 40       	mov    0x40(%rsp),%r14
  405d5b:	4c 89 e6             	mov    %r12,%rsi
  405d5e:	4c 89 f7             	mov    %r14,%rdi
  405d61:	e8 5a df ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  405d66:	48 8d 35 47 a6 00 00 	lea    0xa647(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  405d6d:	ba 01 00 00 00       	mov    $0x1,%edx
  405d72:	4c 89 f7             	mov    %r14,%rdi
  405d75:	e8 d6 dc ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  405d7a:	48 89 ee             	mov    %rbp,%rsi
  405d7d:	4c 89 f7             	mov    %r14,%rdi
  405d80:	e8 bb e4 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  405d85:	48 8b 10             	mov    (%rax),%rdx
  405d88:	48 89 94 24 70 03 00 	mov    %rdx,0x370(%rsp)
  405d8f:	00 
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  405d90:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  405d94:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405d97:	48 8b 84 24 80 03 00 	mov    0x380(%rsp),%rax
  405d9e:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  405d9f:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  405da3:	48 39 df             	cmp    %rbx,%rdi
  405da6:	0f 85 d4 11 00 00    	jne    406f80 <_ZN6rocket6Config4loadEPKc+0x26d0>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  405dac:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  405db1:	48 8d 84 24 70 03 00 	lea    0x370(%rsp),%rax
  405db8:	00 
  405db9:	48 89 c6             	mov    %rax,%rsi
  405dbc:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  405dc1:	4c 89 f7             	mov    %r14,%rdi
                                     const string& key,
                                     T default_value = 0)
    {
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
  405dc4:	4d 8d 76 08          	lea    0x8(%r14),%r14
  405dc8:	e8 33 28 00 00       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
  405dcd:	49 39 c6             	cmp    %rax,%r14
  405dd0:	0f 84 92 0b 00 00    	je     406968 <_ZN6rocket6Config4loadEPKc+0x20b8>
  405dd6:	4c 8b ac 24 d0 03 00 	mov    0x3d0(%rsp),%r13
  405ddd:	00 
  405dde:	4d 85 ed             	test   %r13,%r13
  405de1:	0f 84 a5 09 00 00    	je     40678c <_ZN6rocket6Config4loadEPKc+0x1edc>
  405de7:	48 8b ac 24 70 03 00 	mov    0x370(%rsp),%rbp
  405dee:	00 
  405def:	4c 8b 7d e8          	mov    -0x18(%rbp),%r15
  405df3:	eb 16                	jmp    405e0b <_ZN6rocket6Config4loadEPKc+0x155b>
  405df5:	0f 1f 00             	nopl   (%rax)
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  405df8:	44 89 e0             	mov    %r12d,%eax
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  405dfb:	85 c0                	test   %eax,%eax
  405dfd:	78 3f                	js     405e3e <_ZN6rocket6Config4loadEPKc+0x158e>
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  405dff:	4d 89 ee             	mov    %r13,%r14
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  405e02:	4d 8b 6d 10          	mov    0x10(%r13),%r13
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  405e06:	4d 85 ed             	test   %r13,%r13
  405e09:	74 3c                	je     405e47 <_ZN6rocket6Config4loadEPKc+0x1597>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405e0b:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  405e0f:	4c 89 fa             	mov    %r15,%rdx
  405e12:	48 89 ee             	mov    %rbp,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  405e15:	4c 8b 67 e8          	mov    -0x18(%rdi),%r12
  405e19:	4d 39 fc             	cmp    %r15,%r12
  405e1c:	49 0f 46 d4          	cmovbe %r12,%rdx
  405e20:	e8 cb e1 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  405e25:	85 c0                	test   %eax,%eax
  405e27:	75 d2                	jne    405dfb <_ZN6rocket6Config4loadEPKc+0x154b>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  405e29:	4d 29 fc             	sub    %r15,%r12

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  405e2c:	49 81 fc ff ff ff 7f 	cmp    $0x7fffffff,%r12
  405e33:	7f ca                	jg     405dff <_ZN6rocket6Config4loadEPKc+0x154f>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  405e35:	49 81 fc 00 00 00 80 	cmp    $0xffffffff80000000,%r12
  405e3c:	7d ba                	jge    405df8 <_ZN6rocket6Config4loadEPKc+0x1548>
  405e3e:	4d 8b 6d 18          	mov    0x18(%r13),%r13
  405e42:	4d 85 ed             	test   %r13,%r13
  405e45:	75 c4                	jne    405e0b <_ZN6rocket6Config4loadEPKc+0x155b>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  405e47:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  405e4c:	48 83 c0 08          	add    $0x8,%rax
  405e50:	49 39 c6             	cmp    %rax,%r14
  405e53:	0f 84 33 09 00 00    	je     40678c <_ZN6rocket6Config4loadEPKc+0x1edc>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405e59:	49 8b 76 20          	mov    0x20(%r14),%rsi
  405e5d:	4c 89 fa             	mov    %r15,%rdx
  405e60:	48 89 ef             	mov    %rbp,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  405e63:	4c 8b 66 e8          	mov    -0x18(%rsi),%r12
  405e67:	4d 39 fc             	cmp    %r15,%r12
  405e6a:	49 0f 46 d4          	cmovbe %r12,%rdx
  405e6e:	e8 7d e1 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  405e73:	85 c0                	test   %eax,%eax
  405e75:	0f 85 09 09 00 00    	jne    406784 <_ZN6rocket6Config4loadEPKc+0x1ed4>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  405e7b:	4d 29 e7             	sub    %r12,%r15

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  405e7e:	49 81 ff ff ff ff 7f 	cmp    $0x7fffffff,%r15
  405e85:	0f 8e ed 08 00 00    	jle    406778 <_ZN6rocket6Config4loadEPKc+0x1ec8>
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
  405e8b:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  405e92:	00 
  405e93:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  405e97:	e8 84 dc ff ff       	callq  403b20 <_ZNSt8ios_baseC2Ev@plt>
  405e9c:	4c 8b 2d 0d e0 20 00 	mov    0x20e00d(%rip),%r13        # 613eb0 <_DYNAMIC+0x228>
  405ea3:	c6 84 24 30 05 00 00 	movb   $0x0,0x530(%rsp)
  405eaa:	00 
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
  405eab:	48 89 ef             	mov    %rbp,%rdi
  405eae:	48 c7 84 24 28 05 00 	movq   $0x0,0x528(%rsp)
  405eb5:	00 00 00 00 00 
  405eba:	c6 84 24 31 05 00 00 	movb   $0x0,0x531(%rsp)
  405ec1:	00 
  405ec2:	31 f6                	xor    %esi,%esi
  405ec4:	48 c7 84 24 38 05 00 	movq   $0x0,0x538(%rsp)
  405ecb:	00 00 00 00 00 
  405ed0:	48 c7 84 24 40 05 00 	movq   $0x0,0x540(%rsp)
  405ed7:	00 00 00 00 00 
  405edc:	49 8d 45 10          	lea    0x10(%r13),%rax
  405ee0:	48 c7 84 24 48 05 00 	movq   $0x0,0x548(%rsp)
  405ee7:	00 00 00 00 00 
  405eec:	48 c7 84 24 50 05 00 	movq   $0x0,0x550(%rsp)
  405ef3:	00 00 00 00 00 
  405ef8:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405eff:	00 
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
  405f00:	48 8b 05 c1 df 20 00 	mov    0x20dfc1(%rip),%rax        # 613ec8 <_DYNAMIC+0x240>
  405f07:	4c 8b 78 08          	mov    0x8(%rax),%r15
  405f0b:	48 8b 40 10          	mov    0x10(%rax),%rax
  405f0f:	48 89 c1             	mov    %rax,%rcx
  405f12:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  405f17:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  405f1b:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  405f22:	00 
  405f23:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  405f2a:	00 
  405f2b:	48 c7 84 24 f8 03 00 	movq   $0x0,0x3f8(%rsp)
  405f32:	00 00 00 00 00 
      { this->init(0); }
  405f37:	49 03 7f e8          	add    -0x18(%r15),%rdi
  405f3b:	e8 c0 df ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  string class does its own memory management.
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
  405f40:	4c 8b 25 21 e0 20 00 	mov    0x20e021(%rip),%r12        # 613f68 <_DYNAMIC+0x2e0>
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), 
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale()) 
  405f47:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  405f4b:	48 c7 84 24 08 04 00 	movq   $0x0,0x408(%rsp)
  405f52:	00 00 00 00 00 
  405f57:	48 c7 84 24 10 04 00 	movq   $0x0,0x410(%rsp)
  405f5e:	00 00 00 00 00 
  405f63:	48 c7 84 24 18 04 00 	movq   $0x0,0x418(%rsp)
  405f6a:	00 00 00 00 00 
  405f6f:	48 c7 84 24 20 04 00 	movq   $0x0,0x420(%rsp)
  405f76:	00 00 00 00 00 
  405f7b:	48 c7 84 24 28 04 00 	movq   $0x0,0x428(%rsp)
  405f82:	00 00 00 00 00 
  405f87:	49 8d 44 24 18       	lea    0x18(%r12),%rax
  405f8c:	48 c7 84 24 30 04 00 	movq   $0x0,0x430(%rsp)
  405f93:	00 00 00 00 00 
  405f98:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  405f9f:	00 
  405fa0:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  405fa5:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  405fac:	00 
  405fad:	48 8b 05 a4 df 20 00 	mov    0x20dfa4(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  405fb4:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  405fb9:	48 83 c0 10          	add    $0x10,%rax
  405fbd:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405fc4:	00 
  405fc5:	e8 b6 de ff ff       	callq  403e80 <_ZNSt6localeC1Ev@plt>
       *  own default ctor.
      */
      explicit
      basic_stringbuf(const __string_type& __str,
		      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
  405fca:	48 8b 05 d7 de 20 00 	mov    0x20ded7(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  405fd1:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  405fd6:	48 8d 7d 58          	lea    0x58(%rbp),%rdi
  405fda:	c7 84 24 40 04 00 00 	movl   $0x0,0x440(%rsp)
  405fe1:	00 00 00 00 
  405fe5:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  405fea:	48 83 c0 10          	add    $0x10,%rax
  405fee:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  405ff5:	00 
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  405ff6:	49 8b 76 28          	mov    0x28(%r14),%rsi
  405ffa:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  405ffe:	e8 4d db ff ff       	callq  403b50 <_ZNSsC1EPKcmRKSaIcE@plt>
      {
	_M_mode = __mode;
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  406003:	48 8b b4 24 48 04 00 	mov    0x448(%rsp),%rsi
  40600a:	00 
  40600b:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  40600f:	31 c9                	xor    %ecx,%ecx
  406011:	31 d2                	xor    %edx,%edx
    protected:
      // Common initialization code goes here.
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
	_M_mode = __mode;
  406013:	c7 84 24 40 04 00 00 	movl   $0x8,0x440(%rsp)
  40601a:	08 00 00 00 
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  40601e:	e8 8d df ff ff       	callq  403fb0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm@plt>
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
  406023:	48 8d 75 10          	lea    0x10(%rbp),%rsi
  406027:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  40602b:	e8 d0 de ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
        {
            istringstream iss(_m[name]);
            T num = 0;
            iss >> num;
  406030:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  406035:	48 89 ef             	mov    %rbp,%rdi
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
        {
            istringstream iss(_m[name]);
            T num = 0;
  406038:	c7 84 24 b0 03 00 00 	movl   $0x0,0x3b0(%rsp)
  40603f:	00 00 00 00 
            iss >> num;
  406043:	e8 58 df ff ff       	callq  403fa0 <_ZNSirsERi@plt>
       *
       *  The buffer is deallocated by the stringbuf object, not the
       *  formatting stream.
      */
      ~basic_istringstream()
      { }
  406048:	49 8d 44 24 18       	lea    0x18(%r12),%rax
            return num;
  40604d:	44 8b b4 24 b0 03 00 	mov    0x3b0(%rsp),%r14d
  406054:	00 
  406055:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  40605c:	00 
  40605d:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  406062:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  406069:	00 
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  40606a:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40606f:	48 83 c0 10          	add    $0x10,%rax
  406073:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  40607a:	00 
  40607b:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  406082:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  406083:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  406087:	48 39 df             	cmp    %rbx,%rdi
  40608a:	0f 85 fb 17 00 00    	jne    40788b <_ZN6rocket6Config4loadEPKc+0x2fdb>

  public:
      /// Destructor deallocates no buffer space.
      virtual 
      ~basic_streambuf() 
      { }
  406090:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  406095:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  406099:	48 83 c0 10          	add    $0x10,%rax
  40609d:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4060a4:	00 
  4060a5:	e8 06 e1 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
  4060aa:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  4060ae:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  4060b3:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  4060b7:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  4060be:	00 
  4060bf:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  4060c6:	00 
  4060c7:	49 8d 45 10          	lea    0x10(%r13),%rax
  4060cb:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  4060d2:	00 
  4060d3:	e8 88 de ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4060d8:	48 8b 84 24 70 03 00 	mov    0x370(%rsp),%rax
  4060df:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4060e0:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4060e4:	48 39 df             	cmp    %rbx,%rdi
  4060e7:	0f 85 13 0d 00 00    	jne    406e00 <_ZN6rocket6Config4loadEPKc+0x2550>
  4060ed:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4060f2:	44 89 70 10          	mov    %r14d,0x10(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4060f6:	48 8b 84 24 10 02 00 	mov    0x210(%rsp),%rax
  4060fd:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4060fe:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  406102:	48 39 df             	cmp    %rbx,%rdi
  406105:	0f 85 b5 0c 00 00    	jne    406dc0 <_ZN6rocket6Config4loadEPKc+0x2510>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40610b:	48 8b 84 24 20 02 00 	mov    0x220(%rsp),%rax
  406112:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  406113:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  406117:	48 39 df             	cmp    %rbx,%rdi
  40611a:	0f 85 60 0c 00 00    	jne    406d80 <_ZN6rocket6Config4loadEPKc+0x24d0>
    if (_work_nthreads <= 0)
  406120:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  406125:	8b 48 10             	mov    0x10(%rax),%ecx
  406128:	85 c9                	test   %ecx,%ecx
  40612a:	0f 8e 88 08 00 00    	jle    4069b8 <_ZN6rocket6Config4loadEPKc+0x2108>
    {
        _work_nthreads = 3;
    }

    _timeout = cr.GetNumber<int>("server", "timeout", 10);
  406130:	48 8d ac 24 40 02 00 	lea    0x240(%rsp),%rbp
  406137:	00 
  406138:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  40613d:	48 8d 35 a3 a2 00 00 	lea    0xa2a3(%rip),%rsi        # 4103e7 <_IO_stdin_used+0x67>
  406144:	48 89 ef             	mov    %rbp,%rdi
  406147:	e8 d4 dc ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40614c:	4c 8d a4 24 30 02 00 	lea    0x230(%rsp),%r12
  406153:	00 
  406154:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
  406159:	48 8d 35 38 ac 00 00 	lea    0xac38(%rip),%rsi        # 410d98 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x78>
  406160:	4c 89 e7             	mov    %r12,%rdi
  406163:	e8 b8 dc ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  406168:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14
  40616d:	4c 89 e6             	mov    %r12,%rsi
  406170:	4c 89 f7             	mov    %r14,%rdi
  406173:	e8 48 db ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  406178:	48 8d 35 35 a2 00 00 	lea    0xa235(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  40617f:	ba 01 00 00 00       	mov    $0x1,%edx
  406184:	4c 89 f7             	mov    %r14,%rdi
  406187:	e8 c4 d8 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  40618c:	48 89 ee             	mov    %rbp,%rsi
  40618f:	4c 89 f7             	mov    %r14,%rdi
  406192:	e8 a9 e0 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  406197:	48 8b 10             	mov    (%rax),%rdx
  40619a:	48 89 94 24 a0 03 00 	mov    %rdx,0x3a0(%rsp)
  4061a1:	00 
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  4061a2:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  4061a6:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4061a9:	48 8b 84 24 b0 03 00 	mov    0x3b0(%rsp),%rax
  4061b0:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4061b1:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4061b5:	48 39 df             	cmp    %rbx,%rdi
  4061b8:	0f 85 82 0b 00 00    	jne    406d40 <_ZN6rocket6Config4loadEPKc+0x2490>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  4061be:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  4061c3:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  4061c8:	4c 89 f7             	mov    %r14,%rdi
                                     const string& key,
                                     T default_value = 0)
    {
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
  4061cb:	4d 8d 76 08          	lea    0x8(%r14),%r14
  4061cf:	e8 2c 24 00 00       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
  4061d4:	49 39 c6             	cmp    %rax,%r14
  4061d7:	0f 84 6b 07 00 00    	je     406948 <_ZN6rocket6Config4loadEPKc+0x2098>
  4061dd:	4c 8b ac 24 d0 03 00 	mov    0x3d0(%rsp),%r13
  4061e4:	00 
  4061e5:	4d 85 ed             	test   %r13,%r13
  4061e8:	0f 84 4e 05 00 00    	je     40673c <_ZN6rocket6Config4loadEPKc+0x1e8c>
  4061ee:	48 8b ac 24 a0 03 00 	mov    0x3a0(%rsp),%rbp
  4061f5:	00 
  4061f6:	4c 8b 7d e8          	mov    -0x18(%rbp),%r15
  4061fa:	eb 17                	jmp    406213 <_ZN6rocket6Config4loadEPKc+0x1963>
  4061fc:	0f 1f 40 00          	nopl   0x0(%rax)
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  406200:	44 89 e0             	mov    %r12d,%eax
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  406203:	85 c0                	test   %eax,%eax
  406205:	78 3f                	js     406246 <_ZN6rocket6Config4loadEPKc+0x1996>
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  406207:	4d 89 ee             	mov    %r13,%r14
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  40620a:	4d 8b 6d 10          	mov    0x10(%r13),%r13
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  40620e:	4d 85 ed             	test   %r13,%r13
  406211:	74 3c                	je     40624f <_ZN6rocket6Config4loadEPKc+0x199f>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  406213:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  406217:	4c 89 fa             	mov    %r15,%rdx
  40621a:	48 89 ee             	mov    %rbp,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40621d:	4c 8b 67 e8          	mov    -0x18(%rdi),%r12
  406221:	4d 39 fc             	cmp    %r15,%r12
  406224:	49 0f 46 d4          	cmovbe %r12,%rdx
  406228:	e8 c3 dd ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40622d:	85 c0                	test   %eax,%eax
  40622f:	75 d2                	jne    406203 <_ZN6rocket6Config4loadEPKc+0x1953>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  406231:	4d 29 fc             	sub    %r15,%r12

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  406234:	49 81 fc ff ff ff 7f 	cmp    $0x7fffffff,%r12
  40623b:	7f ca                	jg     406207 <_ZN6rocket6Config4loadEPKc+0x1957>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  40623d:	49 81 fc 00 00 00 80 	cmp    $0xffffffff80000000,%r12
  406244:	7d ba                	jge    406200 <_ZN6rocket6Config4loadEPKc+0x1950>
  406246:	4d 8b 6d 18          	mov    0x18(%r13),%r13
  40624a:	4d 85 ed             	test   %r13,%r13
  40624d:	75 c4                	jne    406213 <_ZN6rocket6Config4loadEPKc+0x1963>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40624f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  406254:	48 83 c0 08          	add    $0x8,%rax
  406258:	49 39 c6             	cmp    %rax,%r14
  40625b:	0f 84 db 04 00 00    	je     40673c <_ZN6rocket6Config4loadEPKc+0x1e8c>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  406261:	49 8b 76 20          	mov    0x20(%r14),%rsi
  406265:	4c 89 fa             	mov    %r15,%rdx
  406268:	48 89 ef             	mov    %rbp,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40626b:	4c 8b 66 e8          	mov    -0x18(%rsi),%r12
  40626f:	4d 39 fc             	cmp    %r15,%r12
  406272:	49 0f 46 d4          	cmovbe %r12,%rdx
  406276:	e8 75 dd ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40627b:	85 c0                	test   %eax,%eax
  40627d:	0f 85 b1 04 00 00    	jne    406734 <_ZN6rocket6Config4loadEPKc+0x1e84>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  406283:	4d 29 e7             	sub    %r12,%r15

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  406286:	49 81 ff ff ff ff 7f 	cmp    $0x7fffffff,%r15
  40628d:	0f 8e 95 04 00 00    	jle    406728 <_ZN6rocket6Config4loadEPKc+0x1e78>
  406293:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  40629a:	00 
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
  40629b:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  40629f:	e8 7c d8 ff ff       	callq  403b20 <_ZNSt8ios_baseC2Ev@plt>
  4062a4:	4c 8b 2d 05 dc 20 00 	mov    0x20dc05(%rip),%r13        # 613eb0 <_DYNAMIC+0x228>
  4062ab:	c6 84 24 30 05 00 00 	movb   $0x0,0x530(%rsp)
  4062b2:	00 
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
  4062b3:	48 89 ef             	mov    %rbp,%rdi
  4062b6:	48 c7 84 24 28 05 00 	movq   $0x0,0x528(%rsp)
  4062bd:	00 00 00 00 00 
  4062c2:	c6 84 24 31 05 00 00 	movb   $0x0,0x531(%rsp)
  4062c9:	00 
  4062ca:	31 f6                	xor    %esi,%esi
  4062cc:	48 c7 84 24 38 05 00 	movq   $0x0,0x538(%rsp)
  4062d3:	00 00 00 00 00 
  4062d8:	48 c7 84 24 40 05 00 	movq   $0x0,0x540(%rsp)
  4062df:	00 00 00 00 00 
  4062e4:	49 8d 45 10          	lea    0x10(%r13),%rax
  4062e8:	48 c7 84 24 48 05 00 	movq   $0x0,0x548(%rsp)
  4062ef:	00 00 00 00 00 
  4062f4:	48 c7 84 24 50 05 00 	movq   $0x0,0x550(%rsp)
  4062fb:	00 00 00 00 00 
  406300:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  406307:	00 
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
  406308:	48 8b 05 b9 db 20 00 	mov    0x20dbb9(%rip),%rax        # 613ec8 <_DYNAMIC+0x240>
  40630f:	4c 8b 78 08          	mov    0x8(%rax),%r15
  406313:	48 8b 40 10          	mov    0x10(%rax),%rax
  406317:	48 89 c1             	mov    %rax,%rcx
  40631a:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  40631f:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  406323:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  40632a:	00 
  40632b:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  406332:	00 
  406333:	48 c7 84 24 f8 03 00 	movq   $0x0,0x3f8(%rsp)
  40633a:	00 00 00 00 00 
      { this->init(0); }
  40633f:	49 03 7f e8          	add    -0x18(%r15),%rdi
  406343:	e8 b8 db ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  string class does its own memory management.
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
  406348:	4c 8b 25 19 dc 20 00 	mov    0x20dc19(%rip),%r12        # 613f68 <_DYNAMIC+0x2e0>
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), 
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale()) 
  40634f:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  406353:	48 c7 84 24 08 04 00 	movq   $0x0,0x408(%rsp)
  40635a:	00 00 00 00 00 
  40635f:	48 c7 84 24 10 04 00 	movq   $0x0,0x410(%rsp)
  406366:	00 00 00 00 00 
  40636b:	48 c7 84 24 18 04 00 	movq   $0x0,0x418(%rsp)
  406372:	00 00 00 00 00 
  406377:	48 c7 84 24 20 04 00 	movq   $0x0,0x420(%rsp)
  40637e:	00 00 00 00 00 
  406383:	48 c7 84 24 28 04 00 	movq   $0x0,0x428(%rsp)
  40638a:	00 00 00 00 00 
  40638f:	49 8d 44 24 18       	lea    0x18(%r12),%rax
  406394:	48 c7 84 24 30 04 00 	movq   $0x0,0x430(%rsp)
  40639b:	00 00 00 00 00 
  4063a0:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  4063a7:	00 
  4063a8:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  4063ad:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  4063b4:	00 
  4063b5:	48 8b 05 9c db 20 00 	mov    0x20db9c(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  4063bc:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  4063c1:	48 83 c0 10          	add    $0x10,%rax
  4063c5:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4063cc:	00 
  4063cd:	e8 ae da ff ff       	callq  403e80 <_ZNSt6localeC1Ev@plt>
       *  own default ctor.
      */
      explicit
      basic_stringbuf(const __string_type& __str,
		      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
  4063d2:	48 8b 05 cf da 20 00 	mov    0x20dacf(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  4063d9:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  4063de:	48 8d 7d 58          	lea    0x58(%rbp),%rdi
  4063e2:	c7 84 24 40 04 00 00 	movl   $0x0,0x440(%rsp)
  4063e9:	00 00 00 00 
  4063ed:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  4063f2:	48 83 c0 10          	add    $0x10,%rax
  4063f6:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4063fd:	00 
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4063fe:	49 8b 76 28          	mov    0x28(%r14),%rsi
  406402:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  406406:	e8 45 d7 ff ff       	callq  403b50 <_ZNSsC1EPKcmRKSaIcE@plt>
      {
	_M_mode = __mode;
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  40640b:	48 8b b4 24 48 04 00 	mov    0x448(%rsp),%rsi
  406412:	00 
  406413:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  406417:	31 c9                	xor    %ecx,%ecx
  406419:	31 d2                	xor    %edx,%edx
    protected:
      // Common initialization code goes here.
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
	_M_mode = __mode;
  40641b:	c7 84 24 40 04 00 00 	movl   $0x8,0x440(%rsp)
  406422:	08 00 00 00 
	__size_type __len = 0;
	if (_M_mode & (ios_base::ate | ios_base::app))
	  __len = _M_string.size();
	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
  406426:	e8 85 db ff ff       	callq  403fb0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm@plt>
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
  40642b:	48 8d 75 10          	lea    0x10(%rbp),%rsi
  40642f:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  406433:	e8 c8 da ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
        {
            istringstream iss(_m[name]);
            T num = 0;
            iss >> num;
  406438:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40643d:	48 89 ef             	mov    %rbp,%rdi
        string name = section + "." + key;

        if (_m.find(name) != _m.end())
        {
            istringstream iss(_m[name]);
            T num = 0;
  406440:	c7 84 24 b0 03 00 00 	movl   $0x0,0x3b0(%rsp)
  406447:	00 00 00 00 
            iss >> num;
  40644b:	e8 50 db ff ff       	callq  403fa0 <_ZNSirsERi@plt>
       *
       *  The buffer is deallocated by the stringbuf object, not the
       *  formatting stream.
      */
      ~basic_istringstream()
      { }
  406450:	49 8d 44 24 18       	lea    0x18(%r12),%rax
            return num;
  406455:	44 8b b4 24 b0 03 00 	mov    0x3b0(%rsp),%r14d
  40645c:	00 
  40645d:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  406464:	00 
  406465:	49 8d 44 24 40       	lea    0x40(%r12),%rax
  40646a:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  406471:	00 
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  406472:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  406477:	48 83 c0 10          	add    $0x10,%rax
  40647b:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  406482:	00 
  406483:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  40648a:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40648b:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40648f:	48 39 df             	cmp    %rbx,%rdi
  406492:	0f 85 60 13 00 00    	jne    4077f8 <_ZN6rocket6Config4loadEPKc+0x2f48>

  public:
      /// Destructor deallocates no buffer space.
      virtual 
      ~basic_streambuf() 
      { }
  406498:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40649d:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  4064a1:	48 83 c0 10          	add    $0x10,%rax
  4064a5:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4064ac:	00 
  4064ad:	e8 fe dc ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
  4064b2:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  4064b6:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  4064bb:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  4064bf:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  4064c6:	00 
  4064c7:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  4064ce:	00 
  4064cf:	49 8d 45 10          	lea    0x10(%r13),%rax
  4064d3:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  4064da:	00 
  4064db:	e8 80 da ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4064e0:	48 8b 84 24 a0 03 00 	mov    0x3a0(%rsp),%rax
  4064e7:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4064e8:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4064ec:	48 39 df             	cmp    %rbx,%rdi
  4064ef:	0f 85 cb 0e 00 00    	jne    4073c0 <_ZN6rocket6Config4loadEPKc+0x2b10>
  4064f5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4064fa:	44 89 70 14          	mov    %r14d,0x14(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4064fe:	48 8b 84 24 30 02 00 	mov    0x230(%rsp),%rax
  406505:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  406506:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40650a:	48 39 df             	cmp    %rbx,%rdi
  40650d:	0f 85 35 05 00 00    	jne    406a48 <_ZN6rocket6Config4loadEPKc+0x2198>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  406513:	48 8b 84 24 40 02 00 	mov    0x240(%rsp),%rax
  40651a:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40651b:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40651f:	48 39 df             	cmp    %rbx,%rdi
  406522:	0f 85 e8 04 00 00    	jne    406a10 <_ZN6rocket6Config4loadEPKc+0x2160>
    if (_timeout < 0)
  406528:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  40652d:	8b 50 14             	mov    0x14(%rax),%edx
  406530:	85 d2                	test   %edx,%edx
  406532:	0f 88 90 04 00 00    	js     4069c8 <_ZN6rocket6Config4loadEPKc+0x2118>
    {
        _timeout = 0; // 永不超时
    }

    _enable_thread_name = cr.GetBool("server", "enable_thread_name", false);
  406538:	4c 8d a4 24 60 02 00 	lea    0x260(%rsp),%r12
  40653f:	00 
  406540:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  406545:	48 8d 35 a3 9e 00 00 	lea    0x9ea3(%rip),%rsi        # 4103ef <_IO_stdin_used+0x6f>
  40654c:	4c 89 e7             	mov    %r12,%rdi
  40654f:	e8 cc d8 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  406554:	48 8d ac 24 50 02 00 	lea    0x250(%rsp),%rbp
  40655b:	00 
  40655c:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
  406561:	48 8d 35 30 a8 00 00 	lea    0xa830(%rip),%rsi        # 410d98 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x78>
  406568:	48 89 ef             	mov    %rbp,%rdi
  40656b:	e8 b0 d8 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  406570:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  406575:	31 c9                	xor    %ecx,%ecx
  406577:	4c 89 e2             	mov    %r12,%rdx
  40657a:	48 89 ee             	mov    %rbp,%rsi
  40657d:	e8 ee 2b 00 00       	callq  409170 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b>
  406582:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  406587:	88 41 18             	mov    %al,0x18(%rcx)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40658a:	48 8b 84 24 50 02 00 	mov    0x250(%rsp),%rax
  406591:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  406592:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  406596:	48 39 df             	cmp    %rbx,%rdi
  406599:	0f 85 19 05 00 00    	jne    406ab8 <_ZN6rocket6Config4loadEPKc+0x2208>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40659f:	48 8b 84 24 60 02 00 	mov    0x260(%rsp),%rax
  4065a6:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4065a7:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4065ab:	48 39 df             	cmp    %rbx,%rdi
  4065ae:	0f 85 cc 04 00 00    	jne    406a80 <_ZN6rocket6Config4loadEPKc+0x21d0>

    _daemonize = cr.GetBool("server", "daemonize", false);
  4065b4:	4c 8d a4 24 80 02 00 	lea    0x280(%rsp),%r12
  4065bb:	00 
  4065bc:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  4065c1:	48 8d 35 3a 9e 00 00 	lea    0x9e3a(%rip),%rsi        # 410402 <_IO_stdin_used+0x82>
  4065c8:	4c 89 e7             	mov    %r12,%rdi
  4065cb:	e8 50 d8 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  4065d0:	48 8d ac 24 70 02 00 	lea    0x270(%rsp),%rbp
  4065d7:	00 
  4065d8:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
  4065dd:	48 8d 35 b4 a7 00 00 	lea    0xa7b4(%rip),%rsi        # 410d98 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x78>
  4065e4:	48 89 ef             	mov    %rbp,%rdi
  4065e7:	e8 34 d8 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  4065ec:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4065f1:	31 c9                	xor    %ecx,%ecx
  4065f3:	4c 89 e2             	mov    %r12,%rdx
  4065f6:	48 89 ee             	mov    %rbp,%rsi
  4065f9:	e8 72 2b 00 00       	callq  409170 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b>
  4065fe:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  406603:	88 41 19             	mov    %al,0x19(%rcx)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  406606:	48 8b 84 24 70 02 00 	mov    0x270(%rsp),%rax
  40660d:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40660e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  406612:	48 39 df             	cmp    %rbx,%rdi
  406615:	0f 85 b5 06 00 00    	jne    406cd0 <_ZN6rocket6Config4loadEPKc+0x2420>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40661b:	48 8b 84 24 80 02 00 	mov    0x280(%rsp),%rax
  406622:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  406623:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  406627:	48 39 df             	cmp    %rbx,%rdi
  40662a:	0f 85 68 06 00 00    	jne    406c98 <_ZN6rocket6Config4loadEPKc+0x23e8>

    // app config
    _app_so = cr["app.so"];
  406630:	48 8d ac 24 90 02 00 	lea    0x290(%rsp),%rbp
  406637:	00 
  406638:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40663d:	48 8d 35 c8 9d 00 00 	lea    0x9dc8(%rip),%rsi        # 41040c <_IO_stdin_used+0x8c>
  406644:	48 89 ef             	mov    %rbp,%rdi
  406647:	e8 d4 d7 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40664c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  406651:	48 89 ee             	mov    %rbp,%rsi
  406654:	e8 67 38 00 00       	callq  409ec0 <_ZN6rocket12ConfigReaderixERKSs>
  406659:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  40665e:	48 89 c6             	mov    %rax,%rsi
  406661:	48 8d 79 20          	lea    0x20(%rcx),%rdi
  406665:	e8 56 d9 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40666a:	48 8b 84 24 90 02 00 	mov    0x290(%rsp),%rax
  406671:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  406672:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  406676:	48 39 df             	cmp    %rbx,%rdi
  406679:	0f 85 e1 05 00 00    	jne    406c60 <_ZN6rocket6Config4loadEPKc+0x23b0>
    _app_conf = cr["app.conf"];
  40667f:	48 8d ac 24 a0 02 00 	lea    0x2a0(%rsp),%rbp
  406686:	00 
  406687:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40668c:	48 8d 35 80 9d 00 00 	lea    0x9d80(%rip),%rsi        # 410413 <_IO_stdin_used+0x93>
  406693:	48 89 ef             	mov    %rbp,%rdi
  406696:	e8 85 d7 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40669b:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4066a0:	48 89 ee             	mov    %rbp,%rsi
  4066a3:	e8 18 38 00 00       	callq  409ec0 <_ZN6rocket12ConfigReaderixERKSs>
  4066a8:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  4066ad:	48 89 c6             	mov    %rax,%rsi
  4066b0:	48 83 c7 28          	add    $0x28,%rdi
  4066b4:	e8 07 d9 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4066b9:	48 8b 84 24 a0 02 00 	mov    0x2a0(%rsp),%rax
  4066c0:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4066c1:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4066c5:	48 39 df             	cmp    %rbx,%rdi
  4066c8:	0f 85 5a 05 00 00    	jne    406c28 <_ZN6rocket6Config4loadEPKc+0x2378>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4066ce:	48 8b 84 24 d0 00 00 	mov    0xd0(%rsp),%rax
  4066d5:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4066d6:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4066da:	48 39 df             	cmp    %rbx,%rdi
  4066dd:	0f 85 0d 05 00 00    	jne    406bf0 <_ZN6rocket6Config4loadEPKc+0x2340>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4066e3:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  4066ea:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4066eb:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4066ef:	48 39 df             	cmp    %rbx,%rdi
  4066f2:	0f 85 18 02 00 00    	jne    406910 <_ZN6rocket6Config4loadEPKc+0x2060>

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);
#endif

      ~_Rb_tree() _GLIBCXX_NOEXCEPT
      { _M_erase(_M_begin()); }
  4066f8:	48 8b b4 24 d0 03 00 	mov    0x3d0(%rsp),%rsi
  4066ff:	00 
  406700:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  406705:	e8 c6 1c 00 00       	callq  4083d0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E>

    return true;
}
  40670a:	0f b6 44 24 4f       	movzbl 0x4f(%rsp),%eax
  40670f:	48 81 c4 68 05 00 00 	add    $0x568,%rsp
  406716:	5b                   	pop    %rbx
  406717:	5d                   	pop    %rbp
  406718:	41 5c                	pop    %r12
  40671a:	41 5d                	pop    %r13
  40671c:	41 5e                	pop    %r14
  40671e:	41 5f                	pop    %r15
  406720:	c3                   	retq   
  406721:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  406728:	49 81 ff 00 00 00 80 	cmp    $0xffffffff80000000,%r15
  40672f:	7c 0b                	jl     40673c <_ZN6rocket6Config4loadEPKc+0x1e8c>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  406731:	44 89 f8             	mov    %r15d,%eax
  406734:	85 c0                	test   %eax,%eax
  406736:	0f 89 57 fb ff ff    	jns    406293 <_ZN6rocket6Config4loadEPKc+0x19e3>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }
  40673c:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
#if __cplusplus >= 201103L
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
  406741:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406748:	00 
  406749:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  40674e:	4c 8d 44 24 7f       	lea    0x7f(%rsp),%r8
  406753:	48 8d 15 c2 9c 00 00 	lea    0x9cc2(%rip),%rdx        # 41041c <_ZStL19piecewise_construct>
  40675a:	4c 89 f6             	mov    %r14,%rsi
  40675d:	48 89 e9             	mov    %rbp,%rcx
  406760:	48 89 84 24 f0 03 00 	mov    %rax,0x3f0(%rsp)
  406767:	00 
  406768:	e8 43 23 00 00       	callq  408ab0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_>
  40676d:	49 89 c6             	mov    %rax,%r14
  406770:	e9 26 fb ff ff       	jmpq   40629b <_ZN6rocket6Config4loadEPKc+0x19eb>
  406775:	0f 1f 00             	nopl   (%rax)
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  406778:	49 81 ff 00 00 00 80 	cmp    $0xffffffff80000000,%r15
  40677f:	7c 0b                	jl     40678c <_ZN6rocket6Config4loadEPKc+0x1edc>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  406781:	44 89 f8             	mov    %r15d,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  406784:	85 c0                	test   %eax,%eax
  406786:	0f 89 ff f6 ff ff    	jns    405e8b <_ZN6rocket6Config4loadEPKc+0x15db>
  40678c:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
#if __cplusplus >= 201103L
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
  406791:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
  406796:	4c 8d 44 24 7e       	lea    0x7e(%rsp),%r8
  40679b:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4067a0:	48 8d 15 75 9c 00 00 	lea    0x9c75(%rip),%rdx        # 41041c <_ZStL19piecewise_construct>
  4067a7:	4c 89 f6             	mov    %r14,%rsi
  4067aa:	48 89 84 24 90 03 00 	mov    %rax,0x390(%rsp)
  4067b1:	00 
  4067b2:	e8 f9 22 00 00       	callq  408ab0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_>
  4067b7:	49 89 c6             	mov    %rax,%r14
  4067ba:	e9 cc f6 ff ff       	jmpq   405e8b <_ZN6rocket6Config4loadEPKc+0x15db>
  4067bf:	90                   	nop
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  4067c0:	48 81 f9 00 00 00 80 	cmp    $0xffffffff80000000,%rcx
  4067c7:	7c 0a                	jl     4067d3 <_ZN6rocket6Config4loadEPKc+0x1f23>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4067c9:	89 c8                	mov    %ecx,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  4067cb:	85 c0                	test   %eax,%eax
  4067cd:	0f 89 a3 f2 ff ff    	jns    405a76 <_ZN6rocket6Config4loadEPKc+0x11c6>
  4067d3:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
#if __cplusplus >= 201103L
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
  4067d8:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4067dd:	48 8d 8c 24 60 03 00 	lea    0x360(%rsp),%rcx
  4067e4:	00 
  4067e5:	4c 8d 44 24 7d       	lea    0x7d(%rsp),%r8
  4067ea:	48 8d 15 2b 9c 00 00 	lea    0x9c2b(%rip),%rdx        # 41041c <_ZStL19piecewise_construct>
  4067f1:	4c 89 f6             	mov    %r14,%rsi
  4067f4:	48 89 84 24 60 03 00 	mov    %rax,0x360(%rsp)
  4067fb:	00 
  4067fc:	e8 af 22 00 00       	callq  408ab0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_>
  406801:	49 89 c6             	mov    %rax,%r14
  406804:	e9 6d f2 ff ff       	jmpq   405a76 <_ZN6rocket6Config4loadEPKc+0x11c6>
  406809:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  406810:	48 81 f9 00 00 00 80 	cmp    $0xffffffff80000000,%rcx
  406817:	7c 0a                	jl     406823 <_ZN6rocket6Config4loadEPKc+0x1f73>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  406819:	89 c8                	mov    %ecx,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40681b:	85 c0                	test   %eax,%eax
  40681d:	0f 89 33 ee ff ff    	jns    405656 <_ZN6rocket6Config4loadEPKc+0xda6>
  406823:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
#if __cplusplus >= 201103L
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
  406828:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  40682d:	48 8d 8c 24 30 03 00 	lea    0x330(%rsp),%rcx
  406834:	00 
  406835:	4c 8d 44 24 7c       	lea    0x7c(%rsp),%r8
  40683a:	48 8d 15 db 9b 00 00 	lea    0x9bdb(%rip),%rdx        # 41041c <_ZStL19piecewise_construct>
  406841:	4c 89 f6             	mov    %r14,%rsi
  406844:	48 89 84 24 30 03 00 	mov    %rax,0x330(%rsp)
  40684b:	00 
  40684c:	e8 5f 22 00 00       	callq  408ab0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_>
  406851:	49 89 c6             	mov    %rax,%r14
  406854:	e9 fd ed ff ff       	jmpq   405656 <_ZN6rocket6Config4loadEPKc+0xda6>
  406859:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  406860:	48 81 f9 00 00 00 80 	cmp    $0xffffffff80000000,%rcx
  406867:	7c 0a                	jl     406873 <_ZN6rocket6Config4loadEPKc+0x1fc3>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  406869:	89 c8                	mov    %ecx,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40686b:	85 c0                	test   %eax,%eax
  40686d:	0f 89 03 e9 ff ff    	jns    405176 <_ZN6rocket6Config4loadEPKc+0x8c6>
  406873:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
#if __cplusplus >= 201103L
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
  406878:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  40687d:	48 8d 8c 24 00 03 00 	lea    0x300(%rsp),%rcx
  406884:	00 
  406885:	4c 8d 44 24 7b       	lea    0x7b(%rsp),%r8
  40688a:	48 8d 15 8b 9b 00 00 	lea    0x9b8b(%rip),%rdx        # 41041c <_ZStL19piecewise_construct>
  406891:	4c 89 f6             	mov    %r14,%rsi
  406894:	48 89 84 24 00 03 00 	mov    %rax,0x300(%rsp)
  40689b:	00 
  40689c:	e8 0f 22 00 00       	callq  408ab0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_>
  4068a1:	49 89 c6             	mov    %rax,%r14
  4068a4:	e9 cd e8 ff ff       	jmpq   405176 <_ZN6rocket6Config4loadEPKc+0x8c6>
  4068a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  4068b0:	48 81 f9 00 00 00 80 	cmp    $0xffffffff80000000,%rcx
  4068b7:	7c 0a                	jl     4068c3 <_ZN6rocket6Config4loadEPKc+0x2013>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4068b9:	89 c8                	mov    %ecx,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  4068bb:	85 c0                	test   %eax,%eax
  4068bd:	0f 89 a3 e4 ff ff    	jns    404d66 <_ZN6rocket6Config4loadEPKc+0x4b6>
  4068c3:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
#if __cplusplus >= 201103L
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
  4068c8:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4068cd:	48 8d 8c 24 d0 02 00 	lea    0x2d0(%rsp),%rcx
  4068d4:	00 
  4068d5:	4c 8d 44 24 7a       	lea    0x7a(%rsp),%r8
  4068da:	48 8d 15 3b 9b 00 00 	lea    0x9b3b(%rip),%rdx        # 41041c <_ZStL19piecewise_construct>
  4068e1:	4c 89 f6             	mov    %r14,%rsi
  4068e4:	48 89 84 24 d0 02 00 	mov    %rax,0x2d0(%rsp)
  4068eb:	00 
  4068ec:	e8 bf 21 00 00       	callq  408ab0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_>
  4068f1:	49 89 c6             	mov    %rax,%r14
  4068f4:	e9 6d e4 ff ff       	jmpq   404d66 <_ZN6rocket6Config4loadEPKc+0x4b6>
  4068f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        }

        return default_value;
  406900:	41 be 00 00 40 06    	mov    $0x6400000,%r14d
  406906:	e9 a9 e6 ff ff       	jmpq   404fb4 <_ZN6rocket6Config4loadEPKc+0x704>
  40690b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406910:	48 83 3d 60 d6 20 00 	cmpq   $0x0,0x20d660(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406917:	00 
  406918:	0f 84 49 0c 00 00    	je     407567 <_ZN6rocket6Config4loadEPKc+0x2cb7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40691e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406923:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406928:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40692a:	85 c0                	test   %eax,%eax
  40692c:	0f 8f c6 fd ff ff    	jg     4066f8 <_ZN6rocket6Config4loadEPKc+0x1e48>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406932:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406939:	00 
  40693a:	e8 31 d4 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40693f:	e9 b4 fd ff ff       	jmpq   4066f8 <_ZN6rocket6Config4loadEPKc+0x1e48>
  406944:	0f 1f 40 00          	nopl   0x0(%rax)
  406948:	41 be 0a 00 00 00    	mov    $0xa,%r14d
  40694e:	e9 8d fb ff ff       	jmpq   4064e0 <_ZN6rocket6Config4loadEPKc+0x1c30>
  406953:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  406958:	41 be 0a 00 00 00    	mov    $0xa,%r14d
  40695e:	e9 60 f3 ff ff       	jmpq   405cc3 <_ZN6rocket6Config4loadEPKc+0x1413>
  406963:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  406968:	41 be 0a 00 00 00    	mov    $0xa,%r14d
  40696e:	e9 65 f7 ff ff       	jmpq   4060d8 <_ZN6rocket6Config4loadEPKc+0x1828>
  406973:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  406978:	41 be b3 15 00 00    	mov    $0x15b3,%r14d
  40697e:	e9 20 ef ff ff       	jmpq   4058a3 <_ZN6rocket6Config4loadEPKc+0xff3>
  406983:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  406988:	41 be 32 00 00 00    	mov    $0x32,%r14d
  40698e:	e9 30 ea ff ff       	jmpq   4053c3 <_ZN6rocket6Config4loadEPKc+0xb13>
  406993:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    _ip = cr.GetString("server", "ip", "0.0.0.0");

    _port = cr.GetNumber<int>("server", "port", 5555);
    if (_port <= 0)
    {
        _port = 5555;
  406998:	c7 40 08 b3 15 00 00 	movl   $0x15b3,0x8(%rax)
  40699f:	e9 57 ef ff ff       	jmpq   4058fb <_ZN6rocket6Config4loadEPKc+0x104b>
  4069a4:	0f 1f 40 00          	nopl   0x0(%rax)
    }

    _net_nthreads = cr.GetNumber<int>("server", "net_nthreads", 10);
    if (_net_nthreads <= 0)
    {
        _net_nthreads = 3;
  4069a8:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%rax)
  4069af:	e9 67 f3 ff ff       	jmpq   405d1b <_ZN6rocket6Config4loadEPKc+0x146b>
  4069b4:	0f 1f 40 00          	nopl   0x0(%rax)
    }

    _work_nthreads = cr.GetNumber<int>("server", "work_nthreads", 10);
    if (_work_nthreads <= 0)
    {
        _work_nthreads = 3;
  4069b8:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%rax)
  4069bf:	e9 6c f7 ff ff       	jmpq   406130 <_ZN6rocket6Config4loadEPKc+0x1880>
  4069c4:	0f 1f 40 00          	nopl   0x0(%rax)
    }

    _timeout = cr.GetNumber<int>("server", "timeout", 10);
    if (_timeout < 0)
    {
        _timeout = 0; // 永不超时
  4069c8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  4069cf:	e9 64 fb ff ff       	jmpq   406538 <_ZN6rocket6Config4loadEPKc+0x1c88>
  4069d4:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4069d8:	48 83 3d 98 d5 20 00 	cmpq   $0x0,0x20d598(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4069df:	00 
  4069e0:	0f 84 07 0f 00 00    	je     4078ed <_ZN6rocket6Config4loadEPKc+0x303d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4069e6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4069eb:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4069f0:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4069f2:	85 c0                	test   %eax,%eax
  4069f4:	0f 8f 62 df ff ff    	jg     40495c <_ZN6rocket6Config4loadEPKc+0xac>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4069fa:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406a01:	00 
  406a02:	48 89 ee             	mov    %rbp,%rsi
  406a05:	e8 66 d3 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406a0a:	e9 4d df ff ff       	jmpq   40495c <_ZN6rocket6Config4loadEPKc+0xac>
  406a0f:	90                   	nop
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406a10:	48 83 3d 60 d5 20 00 	cmpq   $0x0,0x20d560(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406a17:	00 
  406a18:	0f 84 69 0b 00 00    	je     407587 <_ZN6rocket6Config4loadEPKc+0x2cd7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406a1e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406a23:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406a28:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406a2a:	85 c0                	test   %eax,%eax
  406a2c:	0f 8f f6 fa ff ff    	jg     406528 <_ZN6rocket6Config4loadEPKc+0x1c78>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406a32:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406a39:	00 
  406a3a:	e8 31 d3 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406a3f:	e9 e4 fa ff ff       	jmpq   406528 <_ZN6rocket6Config4loadEPKc+0x1c78>
  406a44:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406a48:	48 83 3d 28 d5 20 00 	cmpq   $0x0,0x20d528(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406a4f:	00 
  406a50:	0f 84 21 0b 00 00    	je     407577 <_ZN6rocket6Config4loadEPKc+0x2cc7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406a56:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406a5b:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406a60:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406a62:	85 c0                	test   %eax,%eax
  406a64:	0f 8f a9 fa ff ff    	jg     406513 <_ZN6rocket6Config4loadEPKc+0x1c63>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406a6a:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406a71:	00 
  406a72:	e8 f9 d2 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406a77:	e9 97 fa ff ff       	jmpq   406513 <_ZN6rocket6Config4loadEPKc+0x1c63>
  406a7c:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406a80:	48 83 3d f0 d4 20 00 	cmpq   $0x0,0x20d4f0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406a87:	00 
  406a88:	0f 84 19 0b 00 00    	je     4075a7 <_ZN6rocket6Config4loadEPKc+0x2cf7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406a8e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406a93:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406a98:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406a9a:	85 c0                	test   %eax,%eax
  406a9c:	0f 8f 12 fb ff ff    	jg     4065b4 <_ZN6rocket6Config4loadEPKc+0x1d04>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406aa2:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406aa9:	00 
  406aaa:	e8 c1 d2 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406aaf:	e9 00 fb ff ff       	jmpq   4065b4 <_ZN6rocket6Config4loadEPKc+0x1d04>
  406ab4:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406ab8:	48 83 3d b8 d4 20 00 	cmpq   $0x0,0x20d4b8(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406abf:	00 
  406ac0:	0f 84 d1 0a 00 00    	je     407597 <_ZN6rocket6Config4loadEPKc+0x2ce7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406ac6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406acb:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406ad0:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406ad2:	85 c0                	test   %eax,%eax
  406ad4:	0f 8f c5 fa ff ff    	jg     40659f <_ZN6rocket6Config4loadEPKc+0x1cef>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406ada:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406ae1:	00 
  406ae2:	e8 89 d2 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406ae7:	e9 b3 fa ff ff       	jmpq   40659f <_ZN6rocket6Config4loadEPKc+0x1cef>
  406aec:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406af0:	48 83 3d 80 d4 20 00 	cmpq   $0x0,0x20d480(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406af7:	00 
  406af8:	0f 84 f9 09 00 00    	je     4074f7 <_ZN6rocket6Config4loadEPKc+0x2c47>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406afe:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406b03:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406b08:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406b0a:	85 c0                	test   %eax,%eax
  406b0c:	0f 8f 71 e1 ff ff    	jg     404c83 <_ZN6rocket6Config4loadEPKc+0x3d3>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406b12:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406b19:	00 
  406b1a:	48 89 ee             	mov    %rbp,%rsi
  406b1d:	e8 4e d2 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406b22:	e9 5c e1 ff ff       	jmpq   404c83 <_ZN6rocket6Config4loadEPKc+0x3d3>
  406b27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406b2e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406b30:	48 83 3d 40 d4 20 00 	cmpq   $0x0,0x20d440(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406b37:	00 
  406b38:	0f 84 a9 09 00 00    	je     4074e7 <_ZN6rocket6Config4loadEPKc+0x2c37>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406b3e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406b43:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406b48:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406b4a:	85 c0                	test   %eax,%eax
  406b4c:	0f 8f cf de ff ff    	jg     404a21 <_ZN6rocket6Config4loadEPKc+0x171>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406b52:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406b59:	00 
  406b5a:	48 89 ee             	mov    %rbp,%rsi
  406b5d:	e8 0e d2 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406b62:	e9 ba de ff ff       	jmpq   404a21 <_ZN6rocket6Config4loadEPKc+0x171>
  406b67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406b6e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406b70:	48 83 3d 00 d4 20 00 	cmpq   $0x0,0x20d400(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406b77:	00 
  406b78:	0f 84 99 09 00 00    	je     407517 <_ZN6rocket6Config4loadEPKc+0x2c67>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406b7e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406b83:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406b88:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406b8a:	85 c0                	test   %eax,%eax
  406b8c:	0f 8f a4 de ff ff    	jg     404a36 <_ZN6rocket6Config4loadEPKc+0x186>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406b92:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406b99:	00 
  406b9a:	48 89 ee             	mov    %rbp,%rsi
  406b9d:	e8 ce d1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406ba2:	e9 8f de ff ff       	jmpq   404a36 <_ZN6rocket6Config4loadEPKc+0x186>
  406ba7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406bae:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406bb0:	48 83 3d c0 d3 20 00 	cmpq   $0x0,0x20d3c0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406bb7:	00 
  406bb8:	0f 84 49 09 00 00    	je     407507 <_ZN6rocket6Config4loadEPKc+0x2c57>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406bbe:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406bc3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406bc8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406bca:	85 c0                	test   %eax,%eax
  406bcc:	0f 8f f3 de ff ff    	jg     404ac5 <_ZN6rocket6Config4loadEPKc+0x215>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406bd2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406bd9:	00 
  406bda:	48 89 ee             	mov    %rbp,%rsi
  406bdd:	e8 8e d1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406be2:	e9 de de ff ff       	jmpq   404ac5 <_ZN6rocket6Config4loadEPKc+0x215>
  406be7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406bee:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406bf0:	48 83 3d 80 d3 20 00 	cmpq   $0x0,0x20d380(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406bf7:	00 
  406bf8:	0f 84 39 09 00 00    	je     407537 <_ZN6rocket6Config4loadEPKc+0x2c87>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406bfe:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406c03:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406c08:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406c0a:	85 c0                	test   %eax,%eax
  406c0c:	0f 8f d1 fa ff ff    	jg     4066e3 <_ZN6rocket6Config4loadEPKc+0x1e33>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406c12:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406c19:	00 
  406c1a:	e8 51 d1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406c1f:	e9 bf fa ff ff       	jmpq   4066e3 <_ZN6rocket6Config4loadEPKc+0x1e33>
  406c24:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406c28:	48 83 3d 48 d3 20 00 	cmpq   $0x0,0x20d348(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406c2f:	00 
  406c30:	0f 84 f1 08 00 00    	je     407527 <_ZN6rocket6Config4loadEPKc+0x2c77>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406c36:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406c3b:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406c40:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406c42:	85 c0                	test   %eax,%eax
  406c44:	0f 8f 84 fa ff ff    	jg     4066ce <_ZN6rocket6Config4loadEPKc+0x1e1e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406c4a:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406c51:	00 
  406c52:	e8 19 d1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406c57:	e9 72 fa ff ff       	jmpq   4066ce <_ZN6rocket6Config4loadEPKc+0x1e1e>
  406c5c:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406c60:	48 83 3d 10 d3 20 00 	cmpq   $0x0,0x20d310(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406c67:	00 
  406c68:	0f 84 e9 08 00 00    	je     407557 <_ZN6rocket6Config4loadEPKc+0x2ca7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406c6e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406c73:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406c78:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406c7a:	85 c0                	test   %eax,%eax
  406c7c:	0f 8f fd f9 ff ff    	jg     40667f <_ZN6rocket6Config4loadEPKc+0x1dcf>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406c82:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406c89:	00 
  406c8a:	e8 e1 d0 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406c8f:	e9 eb f9 ff ff       	jmpq   40667f <_ZN6rocket6Config4loadEPKc+0x1dcf>
  406c94:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406c98:	48 83 3d d8 d2 20 00 	cmpq   $0x0,0x20d2d8(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406c9f:	00 
  406ca0:	0f 84 a1 08 00 00    	je     407547 <_ZN6rocket6Config4loadEPKc+0x2c97>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406ca6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406cab:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406cb0:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406cb2:	85 c0                	test   %eax,%eax
  406cb4:	0f 8f 76 f9 ff ff    	jg     406630 <_ZN6rocket6Config4loadEPKc+0x1d80>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406cba:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406cc1:	00 
  406cc2:	e8 a9 d0 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406cc7:	e9 64 f9 ff ff       	jmpq   406630 <_ZN6rocket6Config4loadEPKc+0x1d80>
  406ccc:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406cd0:	48 83 3d a0 d2 20 00 	cmpq   $0x0,0x20d2a0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406cd7:	00 
  406cd8:	0f 84 69 0a 00 00    	je     407747 <_ZN6rocket6Config4loadEPKc+0x2e97>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406cde:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406ce3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406ce8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406cea:	85 c0                	test   %eax,%eax
  406cec:	0f 8f 29 f9 ff ff    	jg     40661b <_ZN6rocket6Config4loadEPKc+0x1d6b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406cf2:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  406cf9:	00 
  406cfa:	e8 71 d0 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406cff:	e9 17 f9 ff ff       	jmpq   40661b <_ZN6rocket6Config4loadEPKc+0x1d6b>
  406d04:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406d08:	48 83 3d 68 d2 20 00 	cmpq   $0x0,0x20d268(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406d0f:	00 
  406d10:	0f 84 21 0a 00 00    	je     407737 <_ZN6rocket6Config4loadEPKc+0x2e87>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406d16:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406d1b:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406d20:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406d22:	85 c0                	test   %eax,%eax
  406d24:	0f 8f 6a ec ff ff    	jg     405994 <_ZN6rocket6Config4loadEPKc+0x10e4>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406d2a:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406d31:	00 
  406d32:	48 89 ee             	mov    %rbp,%rsi
  406d35:	e8 36 d0 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406d3a:	e9 55 ec ff ff       	jmpq   405994 <_ZN6rocket6Config4loadEPKc+0x10e4>
  406d3f:	90                   	nop
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406d40:	48 83 3d 30 d2 20 00 	cmpq   $0x0,0x20d230(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406d47:	00 
  406d48:	0f 84 19 0a 00 00    	je     407767 <_ZN6rocket6Config4loadEPKc+0x2eb7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406d4e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406d53:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406d58:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406d5a:	85 c0                	test   %eax,%eax
  406d5c:	0f 8f 5c f4 ff ff    	jg     4061be <_ZN6rocket6Config4loadEPKc+0x190e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406d62:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406d69:	00 
  406d6a:	48 89 ee             	mov    %rbp,%rsi
  406d6d:	e8 fe cf ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406d72:	e9 47 f4 ff ff       	jmpq   4061be <_ZN6rocket6Config4loadEPKc+0x190e>
  406d77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406d7e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406d80:	48 83 3d f0 d1 20 00 	cmpq   $0x0,0x20d1f0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406d87:	00 
  406d88:	0f 84 c9 09 00 00    	je     407757 <_ZN6rocket6Config4loadEPKc+0x2ea7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406d8e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406d93:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406d98:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406d9a:	85 c0                	test   %eax,%eax
  406d9c:	0f 8f 7e f3 ff ff    	jg     406120 <_ZN6rocket6Config4loadEPKc+0x1870>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406da2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406da9:	00 
  406daa:	48 89 ee             	mov    %rbp,%rsi
  406dad:	e8 be cf ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406db2:	e9 69 f3 ff ff       	jmpq   406120 <_ZN6rocket6Config4loadEPKc+0x1870>
  406db7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406dbe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406dc0:	48 83 3d b0 d1 20 00 	cmpq   $0x0,0x20d1b0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406dc7:	00 
  406dc8:	0f 84 b9 09 00 00    	je     407787 <_ZN6rocket6Config4loadEPKc+0x2ed7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406dce:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406dd3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406dd8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406dda:	85 c0                	test   %eax,%eax
  406ddc:	0f 8f 29 f3 ff ff    	jg     40610b <_ZN6rocket6Config4loadEPKc+0x185b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406de2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406de9:	00 
  406dea:	48 89 ee             	mov    %rbp,%rsi
  406ded:	e8 7e cf ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406df2:	e9 14 f3 ff ff       	jmpq   40610b <_ZN6rocket6Config4loadEPKc+0x185b>
  406df7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406dfe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406e00:	48 83 3d 70 d1 20 00 	cmpq   $0x0,0x20d170(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406e07:	00 
  406e08:	0f 84 69 09 00 00    	je     407777 <_ZN6rocket6Config4loadEPKc+0x2ec7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406e0e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406e13:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406e18:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406e1a:	85 c0                	test   %eax,%eax
  406e1c:	0f 8f cb f2 ff ff    	jg     4060ed <_ZN6rocket6Config4loadEPKc+0x183d>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406e22:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406e29:	00 
  406e2a:	48 89 ee             	mov    %rbp,%rsi
  406e2d:	e8 3e cf ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406e32:	e9 b6 f2 ff ff       	jmpq   4060ed <_ZN6rocket6Config4loadEPKc+0x183d>
  406e37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406e3e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406e40:	48 83 3d 30 d1 20 00 	cmpq   $0x0,0x20d130(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406e47:	00 
  406e48:	0f 84 59 09 00 00    	je     4077a7 <_ZN6rocket6Config4loadEPKc+0x2ef7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406e4e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406e53:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406e58:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406e5a:	85 c0                	test   %eax,%eax
  406e5c:	0f 8f a9 ee ff ff    	jg     405d0b <_ZN6rocket6Config4loadEPKc+0x145b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406e62:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406e69:	00 
  406e6a:	48 89 ee             	mov    %rbp,%rsi
  406e6d:	e8 fe ce ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406e72:	e9 94 ee ff ff       	jmpq   405d0b <_ZN6rocket6Config4loadEPKc+0x145b>
  406e77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406e7e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406e80:	48 83 3d f0 d0 20 00 	cmpq   $0x0,0x20d0f0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406e87:	00 
  406e88:	0f 84 09 09 00 00    	je     407797 <_ZN6rocket6Config4loadEPKc+0x2ee7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406e8e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406e93:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406e98:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406e9a:	85 c0                	test   %eax,%eax
  406e9c:	0f 8f 54 ee ff ff    	jg     405cf6 <_ZN6rocket6Config4loadEPKc+0x1446>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406ea2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406ea9:	00 
  406eaa:	48 89 ee             	mov    %rbp,%rsi
  406ead:	e8 be ce ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406eb2:	e9 3f ee ff ff       	jmpq   405cf6 <_ZN6rocket6Config4loadEPKc+0x1446>
  406eb7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406ebe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406ec0:	48 83 3d b0 d0 20 00 	cmpq   $0x0,0x20d0b0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406ec7:	00 
  406ec8:	0f 84 f9 07 00 00    	je     4076c7 <_ZN6rocket6Config4loadEPKc+0x2e17>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406ece:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406ed3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406ed8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406eda:	85 c0                	test   %eax,%eax
  406edc:	0f 8f f6 ed ff ff    	jg     405cd8 <_ZN6rocket6Config4loadEPKc+0x1428>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406ee2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406ee9:	00 
  406eea:	48 89 ee             	mov    %rbp,%rsi
  406eed:	e8 7e ce ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406ef2:	e9 e1 ed ff ff       	jmpq   405cd8 <_ZN6rocket6Config4loadEPKc+0x1428>
  406ef7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406efe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406f00:	48 83 3d 70 d0 20 00 	cmpq   $0x0,0x20d070(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406f07:	00 
  406f08:	0f 84 a9 07 00 00    	je     4076b7 <_ZN6rocket6Config4loadEPKc+0x2e07>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406f0e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406f13:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406f18:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406f1a:	85 c0                	test   %eax,%eax
  406f1c:	0f 8f b8 db ff ff    	jg     404ada <_ZN6rocket6Config4loadEPKc+0x22a>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406f22:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406f29:	00 
  406f2a:	48 89 ee             	mov    %rbp,%rsi
  406f2d:	e8 3e ce ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406f32:	e9 a3 db ff ff       	jmpq   404ada <_ZN6rocket6Config4loadEPKc+0x22a>
  406f37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406f3e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406f40:	48 83 3d 30 d0 20 00 	cmpq   $0x0,0x20d030(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406f47:	00 
  406f48:	0f 84 99 07 00 00    	je     4076e7 <_ZN6rocket6Config4loadEPKc+0x2e37>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406f4e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406f53:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406f58:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406f5a:	85 c0                	test   %eax,%eax
  406f5c:	0f 8f aa da ff ff    	jg     404a0c <_ZN6rocket6Config4loadEPKc+0x15c>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406f62:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406f69:	00 
  406f6a:	48 89 ee             	mov    %rbp,%rsi
  406f6d:	e8 fe cd ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406f72:	e9 95 da ff ff       	jmpq   404a0c <_ZN6rocket6Config4loadEPKc+0x15c>
  406f77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406f7e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406f80:	48 83 3d f0 cf 20 00 	cmpq   $0x0,0x20cff0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406f87:	00 
  406f88:	0f 84 49 07 00 00    	je     4076d7 <_ZN6rocket6Config4loadEPKc+0x2e27>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406f8e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406f93:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406f98:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406f9a:	85 c0                	test   %eax,%eax
  406f9c:	0f 8f 0a ee ff ff    	jg     405dac <_ZN6rocket6Config4loadEPKc+0x14fc>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406fa2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406fa9:	00 
  406faa:	48 89 ee             	mov    %rbp,%rsi
  406fad:	e8 be cd ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406fb2:	e9 f5 ed ff ff       	jmpq   405dac <_ZN6rocket6Config4loadEPKc+0x14fc>
  406fb7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406fbe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  406fc0:	48 83 3d b0 cf 20 00 	cmpq   $0x0,0x20cfb0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  406fc7:	00 
  406fc8:	0f 84 39 07 00 00    	je     407707 <_ZN6rocket6Config4loadEPKc+0x2e57>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  406fce:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  406fd3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  406fd8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  406fda:	85 c0                	test   %eax,%eax
  406fdc:	0f 8f 09 e9 ff ff    	jg     4058eb <_ZN6rocket6Config4loadEPKc+0x103b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  406fe2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  406fe9:	00 
  406fea:	48 89 ee             	mov    %rbp,%rsi
  406fed:	e8 7e cd ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  406ff2:	e9 f4 e8 ff ff       	jmpq   4058eb <_ZN6rocket6Config4loadEPKc+0x103b>
  406ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406ffe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407000:	48 83 3d 70 cf 20 00 	cmpq   $0x0,0x20cf70(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407007:	00 
  407008:	0f 84 e9 06 00 00    	je     4076f7 <_ZN6rocket6Config4loadEPKc+0x2e47>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40700e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407013:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407018:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40701a:	85 c0                	test   %eax,%eax
  40701c:	0f 8f b4 e8 ff ff    	jg     4058d6 <_ZN6rocket6Config4loadEPKc+0x1026>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407022:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407029:	00 
  40702a:	48 89 ee             	mov    %rbp,%rsi
  40702d:	e8 3e cd ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407032:	e9 9f e8 ff ff       	jmpq   4058d6 <_ZN6rocket6Config4loadEPKc+0x1026>
  407037:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40703e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407040:	48 83 3d 30 cf 20 00 	cmpq   $0x0,0x20cf30(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407047:	00 
  407048:	0f 84 d9 06 00 00    	je     407727 <_ZN6rocket6Config4loadEPKc+0x2e77>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40704e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407053:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407058:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40705a:	85 c0                	test   %eax,%eax
  40705c:	0f 8f 56 e8 ff ff    	jg     4058b8 <_ZN6rocket6Config4loadEPKc+0x1008>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407062:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407069:	00 
  40706a:	48 89 ee             	mov    %rbp,%rsi
  40706d:	e8 fe cc ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407072:	e9 41 e8 ff ff       	jmpq   4058b8 <_ZN6rocket6Config4loadEPKc+0x1008>
  407077:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40707e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407080:	48 83 3d f0 ce 20 00 	cmpq   $0x0,0x20cef0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407087:	00 
  407088:	0f 84 89 06 00 00    	je     407717 <_ZN6rocket6Config4loadEPKc+0x2e67>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40708e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407093:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407098:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40709a:	85 c0                	test   %eax,%eax
  40709c:	0f 8f cd e4 ff ff    	jg     40556f <_ZN6rocket6Config4loadEPKc+0xcbf>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4070a2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4070a9:	00 
  4070aa:	48 89 ee             	mov    %rbp,%rsi
  4070ad:	e8 be cc ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4070b2:	e9 b8 e4 ff ff       	jmpq   40556f <_ZN6rocket6Config4loadEPKc+0xcbf>
  4070b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4070be:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4070c0:	48 83 3d b0 ce 20 00 	cmpq   $0x0,0x20ceb0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4070c7:	00 
  4070c8:	0f 84 79 05 00 00    	je     407647 <_ZN6rocket6Config4loadEPKc+0x2d97>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4070ce:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4070d3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4070d8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4070da:	85 c0                	test   %eax,%eax
  4070dc:	0f 8f fc e3 ff ff    	jg     4054de <_ZN6rocket6Config4loadEPKc+0xc2e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4070e2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4070e9:	00 
  4070ea:	48 89 ee             	mov    %rbp,%rsi
  4070ed:	e8 7e cc ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4070f2:	e9 e7 e3 ff ff       	jmpq   4054de <_ZN6rocket6Config4loadEPKc+0xc2e>
  4070f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4070fe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407100:	48 83 3d 70 ce 20 00 	cmpq   $0x0,0x20ce70(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407107:	00 
  407108:	0f 84 29 05 00 00    	je     407637 <_ZN6rocket6Config4loadEPKc+0x2d87>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40710e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407113:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407118:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40711a:	85 c0                	test   %eax,%eax
  40711c:	0f 8f a7 e3 ff ff    	jg     4054c9 <_ZN6rocket6Config4loadEPKc+0xc19>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407122:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407129:	00 
  40712a:	48 89 ee             	mov    %rbp,%rsi
  40712d:	e8 3e cc ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407132:	e9 92 e3 ff ff       	jmpq   4054c9 <_ZN6rocket6Config4loadEPKc+0xc19>
  407137:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40713e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407140:	48 83 3d 30 ce 20 00 	cmpq   $0x0,0x20ce30(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407147:	00 
  407148:	0f 84 19 05 00 00    	je     407667 <_ZN6rocket6Config4loadEPKc+0x2db7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40714e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407153:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407158:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40715a:	85 c0                	test   %eax,%eax
  40715c:	0f 8f 52 e3 ff ff    	jg     4054b4 <_ZN6rocket6Config4loadEPKc+0xc04>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407162:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407169:	00 
  40716a:	48 89 ee             	mov    %rbp,%rsi
  40716d:	e8 fe cb ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407172:	e9 3d e3 ff ff       	jmpq   4054b4 <_ZN6rocket6Config4loadEPKc+0xc04>
  407177:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40717e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407180:	48 83 3d f0 cd 20 00 	cmpq   $0x0,0x20cdf0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407187:	00 
  407188:	0f 84 c9 04 00 00    	je     407657 <_ZN6rocket6Config4loadEPKc+0x2da7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40718e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407193:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407198:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40719a:	85 c0                	test   %eax,%eax
  40719c:	0f 8f 4d d9 ff ff    	jg     404aef <_ZN6rocket6Config4loadEPKc+0x23f>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4071a2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4071a9:	00 
  4071aa:	48 89 ee             	mov    %rbp,%rsi
  4071ad:	e8 be cb ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4071b2:	e9 38 d9 ff ff       	jmpq   404aef <_ZN6rocket6Config4loadEPKc+0x23f>
  4071b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4071be:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4071c0:	48 83 3d b0 cd 20 00 	cmpq   $0x0,0x20cdb0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4071c7:	00 
  4071c8:	0f 84 b9 04 00 00    	je     407687 <_ZN6rocket6Config4loadEPKc+0x2dd7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4071ce:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4071d3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4071d8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4071da:	85 c0                	test   %eax,%eax
  4071dc:	0f 8f c6 d9 ff ff    	jg     404ba8 <_ZN6rocket6Config4loadEPKc+0x2f8>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4071e2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4071e9:	00 
  4071ea:	48 89 ee             	mov    %rbp,%rsi
  4071ed:	e8 7e cb ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4071f2:	e9 b1 d9 ff ff       	jmpq   404ba8 <_ZN6rocket6Config4loadEPKc+0x2f8>
  4071f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4071fe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407200:	48 83 3d 70 cd 20 00 	cmpq   $0x0,0x20cd70(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407207:	00 
  407208:	0f 84 69 04 00 00    	je     407677 <_ZN6rocket6Config4loadEPKc+0x2dc7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40720e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407213:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407218:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40721a:	85 c0                	test   %eax,%eax
  40721c:	0f 8f 9b d9 ff ff    	jg     404bbd <_ZN6rocket6Config4loadEPKc+0x30d>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407222:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407229:	00 
  40722a:	48 89 ee             	mov    %rbp,%rsi
  40722d:	e8 3e cb ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407232:	e9 86 d9 ff ff       	jmpq   404bbd <_ZN6rocket6Config4loadEPKc+0x30d>
  407237:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40723e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407240:	48 83 3d 30 cd 20 00 	cmpq   $0x0,0x20cd30(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407247:	00 
  407248:	0f 84 59 04 00 00    	je     4076a7 <_ZN6rocket6Config4loadEPKc+0x2df7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40724e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407253:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407258:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40725a:	85 c0                	test   %eax,%eax
  40725c:	0f 8f 70 d9 ff ff    	jg     404bd2 <_ZN6rocket6Config4loadEPKc+0x322>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407262:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407269:	00 
  40726a:	48 89 ee             	mov    %rbp,%rsi
  40726d:	e8 fe ca ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407272:	e9 5b d9 ff ff       	jmpq   404bd2 <_ZN6rocket6Config4loadEPKc+0x322>
  407277:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40727e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407280:	48 83 3d f0 cc 20 00 	cmpq   $0x0,0x20ccf0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407287:	00 
  407288:	0f 84 09 04 00 00    	je     407697 <_ZN6rocket6Config4loadEPKc+0x2de7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40728e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407293:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407298:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40729a:	85 c0                	test   %eax,%eax
  40729c:	0f 8f 45 d9 ff ff    	jg     404be7 <_ZN6rocket6Config4loadEPKc+0x337>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4072a2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4072a9:	00 
  4072aa:	48 89 ee             	mov    %rbp,%rsi
  4072ad:	e8 be ca ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4072b2:	e9 30 d9 ff ff       	jmpq   404be7 <_ZN6rocket6Config4loadEPKc+0x337>
  4072b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4072be:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4072c0:	48 83 3d b0 cc 20 00 	cmpq   $0x0,0x20ccb0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4072c7:	00 
  4072c8:	0f 84 f9 02 00 00    	je     4075c7 <_ZN6rocket6Config4loadEPKc+0x2d17>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4072ce:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4072d3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4072d8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4072da:	85 c0                	test   %eax,%eax
  4072dc:	0f 8f ab dd ff ff    	jg     40508d <_ZN6rocket6Config4loadEPKc+0x7dd>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4072e2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4072e9:	00 
  4072ea:	48 89 ee             	mov    %rbp,%rsi
  4072ed:	e8 7e ca ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4072f2:	e9 96 dd ff ff       	jmpq   40508d <_ZN6rocket6Config4loadEPKc+0x7dd>
  4072f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4072fe:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407300:	48 83 3d 70 cc 20 00 	cmpq   $0x0,0x20cc70(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407307:	00 
  407308:	0f 84 a9 02 00 00    	je     4075b7 <_ZN6rocket6Config4loadEPKc+0x2d07>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40730e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407313:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407318:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40731a:	85 c0                	test   %eax,%eax
  40731c:	0f 8f da dc ff ff    	jg     404ffc <_ZN6rocket6Config4loadEPKc+0x74c>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407322:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407329:	00 
  40732a:	48 89 ee             	mov    %rbp,%rsi
  40732d:	e8 3e ca ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407332:	e9 c5 dc ff ff       	jmpq   404ffc <_ZN6rocket6Config4loadEPKc+0x74c>
  407337:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40733e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407340:	48 83 3d 30 cc 20 00 	cmpq   $0x0,0x20cc30(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407347:	00 
  407348:	0f 84 99 02 00 00    	je     4075e7 <_ZN6rocket6Config4loadEPKc+0x2d37>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40734e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407353:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407358:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40735a:	85 c0                	test   %eax,%eax
  40735c:	0f 8f 85 dc ff ff    	jg     404fe7 <_ZN6rocket6Config4loadEPKc+0x737>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407362:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407369:	00 
  40736a:	48 89 ee             	mov    %rbp,%rsi
  40736d:	e8 fe c9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407372:	e9 70 dc ff ff       	jmpq   404fe7 <_ZN6rocket6Config4loadEPKc+0x737>
  407377:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40737e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407380:	48 83 3d f0 cb 20 00 	cmpq   $0x0,0x20cbf0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407387:	00 
  407388:	0f 84 49 02 00 00    	je     4075d7 <_ZN6rocket6Config4loadEPKc+0x2d27>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40738e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407393:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407398:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40739a:	85 c0                	test   %eax,%eax
  40739c:	0f 8f 27 dc ff ff    	jg     404fc9 <_ZN6rocket6Config4loadEPKc+0x719>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4073a2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4073a9:	00 
  4073aa:	48 89 ee             	mov    %rbp,%rsi
  4073ad:	e8 be c9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4073b2:	e9 12 dc ff ff       	jmpq   404fc9 <_ZN6rocket6Config4loadEPKc+0x719>
  4073b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4073be:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4073c0:	48 83 3d b0 cb 20 00 	cmpq   $0x0,0x20cbb0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4073c7:	00 
  4073c8:	0f 84 39 02 00 00    	je     407607 <_ZN6rocket6Config4loadEPKc+0x2d57>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4073ce:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4073d3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4073d8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4073da:	85 c0                	test   %eax,%eax
  4073dc:	0f 8f 13 f1 ff ff    	jg     4064f5 <_ZN6rocket6Config4loadEPKc+0x1c45>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4073e2:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  4073e9:	00 
  4073ea:	e8 81 c9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4073ef:	e9 01 f1 ff ff       	jmpq   4064f5 <_ZN6rocket6Config4loadEPKc+0x1c45>
  4073f4:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4073f8:	48 83 3d 78 cb 20 00 	cmpq   $0x0,0x20cb78(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4073ff:	00 
  407400:	0f 84 f1 01 00 00    	je     4075f7 <_ZN6rocket6Config4loadEPKc+0x2d47>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  407406:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40740b:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407410:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  407412:	85 c0                	test   %eax,%eax
  407414:	0f 8f 85 e0 ff ff    	jg     40549f <_ZN6rocket6Config4loadEPKc+0xbef>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40741a:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407421:	00 
  407422:	48 89 ee             	mov    %rbp,%rsi
  407425:	e8 46 c9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40742a:	e9 70 e0 ff ff       	jmpq   40549f <_ZN6rocket6Config4loadEPKc+0xbef>
  40742f:	90                   	nop
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407430:	48 83 3d 40 cb 20 00 	cmpq   $0x0,0x20cb40(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407437:	00 
  407438:	0f 84 e9 01 00 00    	je     407627 <_ZN6rocket6Config4loadEPKc+0x2d77>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40743e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407443:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407448:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40744a:	85 c0                	test   %eax,%eax
  40744c:	0f 8f b9 df ff ff    	jg     40540b <_ZN6rocket6Config4loadEPKc+0xb5b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407452:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407459:	00 
  40745a:	48 89 ee             	mov    %rbp,%rsi
  40745d:	e8 0e c9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407462:	e9 a4 df ff ff       	jmpq   40540b <_ZN6rocket6Config4loadEPKc+0xb5b>
  407467:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40746e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407470:	48 83 3d 00 cb 20 00 	cmpq   $0x0,0x20cb00(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407477:	00 
  407478:	0f 84 99 01 00 00    	je     407617 <_ZN6rocket6Config4loadEPKc+0x2d67>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40747e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  407483:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407488:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40748a:	85 c0                	test   %eax,%eax
  40748c:	0f 8f 64 df ff ff    	jg     4053f6 <_ZN6rocket6Config4loadEPKc+0xb46>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  407492:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  407499:	00 
  40749a:	48 89 ee             	mov    %rbp,%rsi
  40749d:	e8 ce c8 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4074a2:	e9 4f df ff ff       	jmpq   4053f6 <_ZN6rocket6Config4loadEPKc+0xb46>
  4074a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4074ae:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4074b0:	48 83 3d c0 ca 20 00 	cmpq   $0x0,0x20cac0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4074b7:	00 
  4074b8:	0f 84 f9 02 00 00    	je     4077b7 <_ZN6rocket6Config4loadEPKc+0x2f07>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4074be:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4074c3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4074c8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4074ca:	85 c0                	test   %eax,%eax
  4074cc:	0f 8f 06 df ff ff    	jg     4053d8 <_ZN6rocket6Config4loadEPKc+0xb28>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4074d2:	48 8d ac 24 f0 03 00 	lea    0x3f0(%rsp),%rbp
  4074d9:	00 
  4074da:	48 89 ee             	mov    %rbp,%rsi
  4074dd:	e8 8e c8 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4074e2:	e9 f1 de ff ff       	jmpq   4053d8 <_ZN6rocket6Config4loadEPKc+0xb28>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4074e7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4074ea:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4074ed:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4074f0:	89 d0                	mov    %edx,%eax
  4074f2:	e9 53 f6 ff ff       	jmpq   406b4a <_ZN6rocket6Config4loadEPKc+0x229a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4074f7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4074fa:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4074fd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407500:	89 d0                	mov    %edx,%eax
  407502:	e9 03 f6 ff ff       	jmpq   406b0a <_ZN6rocket6Config4loadEPKc+0x225a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407507:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40750a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40750d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407510:	89 d0                	mov    %edx,%eax
  407512:	e9 b3 f6 ff ff       	jmpq   406bca <_ZN6rocket6Config4loadEPKc+0x231a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407517:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40751a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40751d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407520:	89 d0                	mov    %edx,%eax
  407522:	e9 63 f6 ff ff       	jmpq   406b8a <_ZN6rocket6Config4loadEPKc+0x22da>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407527:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40752a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40752d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407530:	89 d0                	mov    %edx,%eax
  407532:	e9 0b f7 ff ff       	jmpq   406c42 <_ZN6rocket6Config4loadEPKc+0x2392>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407537:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40753a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40753d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407540:	89 d0                	mov    %edx,%eax
  407542:	e9 c3 f6 ff ff       	jmpq   406c0a <_ZN6rocket6Config4loadEPKc+0x235a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407547:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40754a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40754d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407550:	89 d0                	mov    %edx,%eax
  407552:	e9 5b f7 ff ff       	jmpq   406cb2 <_ZN6rocket6Config4loadEPKc+0x2402>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407557:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40755a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40755d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407560:	89 d0                	mov    %edx,%eax
  407562:	e9 13 f7 ff ff       	jmpq   406c7a <_ZN6rocket6Config4loadEPKc+0x23ca>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407567:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40756a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40756d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407570:	89 d0                	mov    %edx,%eax
  407572:	e9 b3 f3 ff ff       	jmpq   40692a <_ZN6rocket6Config4loadEPKc+0x207a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407577:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40757a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40757d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407580:	89 d0                	mov    %edx,%eax
  407582:	e9 db f4 ff ff       	jmpq   406a62 <_ZN6rocket6Config4loadEPKc+0x21b2>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407587:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40758a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40758d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407590:	89 d0                	mov    %edx,%eax
  407592:	e9 93 f4 ff ff       	jmpq   406a2a <_ZN6rocket6Config4loadEPKc+0x217a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407597:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40759a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40759d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4075a0:	89 d0                	mov    %edx,%eax
  4075a2:	e9 2b f5 ff ff       	jmpq   406ad2 <_ZN6rocket6Config4loadEPKc+0x2222>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4075a7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4075aa:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4075ad:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4075b0:	89 d0                	mov    %edx,%eax
  4075b2:	e9 e3 f4 ff ff       	jmpq   406a9a <_ZN6rocket6Config4loadEPKc+0x21ea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4075b7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4075ba:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4075bd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4075c0:	89 d0                	mov    %edx,%eax
  4075c2:	e9 53 fd ff ff       	jmpq   40731a <_ZN6rocket6Config4loadEPKc+0x2a6a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4075c7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4075ca:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4075cd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4075d0:	89 d0                	mov    %edx,%eax
  4075d2:	e9 03 fd ff ff       	jmpq   4072da <_ZN6rocket6Config4loadEPKc+0x2a2a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4075d7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4075da:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4075dd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4075e0:	89 d0                	mov    %edx,%eax
  4075e2:	e9 b3 fd ff ff       	jmpq   40739a <_ZN6rocket6Config4loadEPKc+0x2aea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4075e7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4075ea:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4075ed:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4075f0:	89 d0                	mov    %edx,%eax
  4075f2:	e9 63 fd ff ff       	jmpq   40735a <_ZN6rocket6Config4loadEPKc+0x2aaa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4075f7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4075fa:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4075fd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407600:	89 d0                	mov    %edx,%eax
  407602:	e9 0b fe ff ff       	jmpq   407412 <_ZN6rocket6Config4loadEPKc+0x2b62>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407607:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40760a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40760d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407610:	89 d0                	mov    %edx,%eax
  407612:	e9 c3 fd ff ff       	jmpq   4073da <_ZN6rocket6Config4loadEPKc+0x2b2a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407617:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40761a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40761d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407620:	89 d0                	mov    %edx,%eax
  407622:	e9 63 fe ff ff       	jmpq   40748a <_ZN6rocket6Config4loadEPKc+0x2bda>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407627:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40762a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40762d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407630:	89 d0                	mov    %edx,%eax
  407632:	e9 13 fe ff ff       	jmpq   40744a <_ZN6rocket6Config4loadEPKc+0x2b9a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407637:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40763a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40763d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407640:	89 d0                	mov    %edx,%eax
  407642:	e9 d3 fa ff ff       	jmpq   40711a <_ZN6rocket6Config4loadEPKc+0x286a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407647:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40764a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40764d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407650:	89 d0                	mov    %edx,%eax
  407652:	e9 83 fa ff ff       	jmpq   4070da <_ZN6rocket6Config4loadEPKc+0x282a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407657:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40765a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40765d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407660:	89 d0                	mov    %edx,%eax
  407662:	e9 33 fb ff ff       	jmpq   40719a <_ZN6rocket6Config4loadEPKc+0x28ea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407667:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40766a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40766d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407670:	89 d0                	mov    %edx,%eax
  407672:	e9 e3 fa ff ff       	jmpq   40715a <_ZN6rocket6Config4loadEPKc+0x28aa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407677:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40767a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40767d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407680:	89 d0                	mov    %edx,%eax
  407682:	e9 93 fb ff ff       	jmpq   40721a <_ZN6rocket6Config4loadEPKc+0x296a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407687:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40768a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40768d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407690:	89 d0                	mov    %edx,%eax
  407692:	e9 43 fb ff ff       	jmpq   4071da <_ZN6rocket6Config4loadEPKc+0x292a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407697:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40769a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40769d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4076a0:	89 d0                	mov    %edx,%eax
  4076a2:	e9 f3 fb ff ff       	jmpq   40729a <_ZN6rocket6Config4loadEPKc+0x29ea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4076a7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4076aa:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4076ad:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4076b0:	89 d0                	mov    %edx,%eax
  4076b2:	e9 a3 fb ff ff       	jmpq   40725a <_ZN6rocket6Config4loadEPKc+0x29aa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4076b7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4076ba:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4076bd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4076c0:	89 d0                	mov    %edx,%eax
  4076c2:	e9 53 f8 ff ff       	jmpq   406f1a <_ZN6rocket6Config4loadEPKc+0x266a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4076c7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4076ca:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4076cd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4076d0:	89 d0                	mov    %edx,%eax
  4076d2:	e9 03 f8 ff ff       	jmpq   406eda <_ZN6rocket6Config4loadEPKc+0x262a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4076d7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4076da:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4076dd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4076e0:	89 d0                	mov    %edx,%eax
  4076e2:	e9 b3 f8 ff ff       	jmpq   406f9a <_ZN6rocket6Config4loadEPKc+0x26ea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4076e7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4076ea:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4076ed:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4076f0:	89 d0                	mov    %edx,%eax
  4076f2:	e9 63 f8 ff ff       	jmpq   406f5a <_ZN6rocket6Config4loadEPKc+0x26aa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4076f7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4076fa:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4076fd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407700:	89 d0                	mov    %edx,%eax
  407702:	e9 13 f9 ff ff       	jmpq   40701a <_ZN6rocket6Config4loadEPKc+0x276a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407707:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40770a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40770d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407710:	89 d0                	mov    %edx,%eax
  407712:	e9 c3 f8 ff ff       	jmpq   406fda <_ZN6rocket6Config4loadEPKc+0x272a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407717:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40771a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40771d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407720:	89 d0                	mov    %edx,%eax
  407722:	e9 73 f9 ff ff       	jmpq   40709a <_ZN6rocket6Config4loadEPKc+0x27ea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407727:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40772a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40772d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407730:	89 d0                	mov    %edx,%eax
  407732:	e9 23 f9 ff ff       	jmpq   40705a <_ZN6rocket6Config4loadEPKc+0x27aa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407737:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40773a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40773d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407740:	89 d0                	mov    %edx,%eax
  407742:	e9 db f5 ff ff       	jmpq   406d22 <_ZN6rocket6Config4loadEPKc+0x2472>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407747:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40774a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40774d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407750:	89 d0                	mov    %edx,%eax
  407752:	e9 93 f5 ff ff       	jmpq   406cea <_ZN6rocket6Config4loadEPKc+0x243a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407757:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40775a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40775d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407760:	89 d0                	mov    %edx,%eax
  407762:	e9 33 f6 ff ff       	jmpq   406d9a <_ZN6rocket6Config4loadEPKc+0x24ea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407767:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40776a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40776d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407770:	89 d0                	mov    %edx,%eax
  407772:	e9 e3 f5 ff ff       	jmpq   406d5a <_ZN6rocket6Config4loadEPKc+0x24aa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407777:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40777a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40777d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407780:	89 d0                	mov    %edx,%eax
  407782:	e9 93 f6 ff ff       	jmpq   406e1a <_ZN6rocket6Config4loadEPKc+0x256a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407787:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40778a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40778d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407790:	89 d0                	mov    %edx,%eax
  407792:	e9 43 f6 ff ff       	jmpq   406dda <_ZN6rocket6Config4loadEPKc+0x252a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  407797:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40779a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40779d:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4077a0:	89 d0                	mov    %edx,%eax
  4077a2:	e9 f3 f6 ff ff       	jmpq   406e9a <_ZN6rocket6Config4loadEPKc+0x25ea>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4077a7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4077aa:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4077ad:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4077b0:	89 d0                	mov    %edx,%eax
  4077b2:	e9 a3 f6 ff ff       	jmpq   406e5a <_ZN6rocket6Config4loadEPKc+0x25aa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4077b7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4077ba:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4077bd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4077c0:	89 d0                	mov    %edx,%eax
  4077c2:	e9 03 fd ff ff       	jmpq   4074ca <_ZN6rocket6Config4loadEPKc+0x2c1a>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4077c7:	48 83 3d a9 c7 20 00 	cmpq   $0x0,0x20c7a9(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4077ce:	00 
  4077cf:	0f 84 28 01 00 00    	je     4078fd <_ZN6rocket6Config4loadEPKc+0x304d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4077d5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4077da:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4077df:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4077e1:	85 c0                	test   %eax,%eax
  4077e3:	0f 8f 72 e0 ff ff    	jg     40585b <_ZN6rocket6Config4loadEPKc+0xfab>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4077e9:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  4077ee:	e8 7d c5 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4077f3:	e9 63 e0 ff ff       	jmpq   40585b <_ZN6rocket6Config4loadEPKc+0xfab>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4077f8:	48 83 3d 78 c7 20 00 	cmpq   $0x0,0x20c778(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4077ff:	00 
  407800:	0f 84 07 01 00 00    	je     40790d <_ZN6rocket6Config4loadEPKc+0x305d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  407806:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40780b:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407810:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  407812:	85 c0                	test   %eax,%eax
  407814:	0f 8f 7e ec ff ff    	jg     406498 <_ZN6rocket6Config4loadEPKc+0x1be8>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40781a:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
  40781f:	e8 4c c5 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407824:	e9 6f ec ff ff       	jmpq   406498 <_ZN6rocket6Config4loadEPKc+0x1be8>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  407829:	48 83 3d 47 c7 20 00 	cmpq   $0x0,0x20c747(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407830:	00 
  407831:	0f 84 e6 00 00 00    	je     40791d <_ZN6rocket6Config4loadEPKc+0x306d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  407837:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40783c:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407841:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  407843:	85 c0                	test   %eax,%eax
  407845:	0f 8f 21 d7 ff ff    	jg     404f6c <_ZN6rocket6Config4loadEPKc+0x6bc>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40784b:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  407850:	e8 1b c5 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407855:	e9 12 d7 ff ff       	jmpq   404f6c <_ZN6rocket6Config4loadEPKc+0x6bc>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40785a:	48 83 3d 16 c7 20 00 	cmpq   $0x0,0x20c716(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407861:	00 
  407862:	0f 84 c5 00 00 00    	je     40792d <_ZN6rocket6Config4loadEPKc+0x307d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  407868:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40786d:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  407872:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  407874:	85 c0                	test   %eax,%eax
  407876:	0f 8f ff e3 ff ff    	jg     405c7b <_ZN6rocket6Config4loadEPKc+0x13cb>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40787c:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  407881:	e8 ea c4 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  407886:	e9 f0 e3 ff ff       	jmpq   405c7b <_ZN6rocket6Config4loadEPKc+0x13cb>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40788b:	48 83 3d e5 c6 20 00 	cmpq   $0x0,0x20c6e5(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  407892:	00 
  407893:	0f 84 a4 00 00 00    	je     40793d <_ZN6rocket6Config4loadEPKc+0x308d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  407899:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40789e:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4078a3:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4078a5:	85 c0                	test   %eax,%eax
  4078a7:	0f 8f e3 e7 ff ff    	jg     406090 <_ZN6rocket6Config4loadEPKc+0x17e0>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4078ad:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  4078b2:	e8 b9 c4 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4078b7:	e9 d4 e7 ff ff       	jmpq   406090 <_ZN6rocket6Config4loadEPKc+0x17e0>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4078bc:	48 83 3d b4 c6 20 00 	cmpq   $0x0,0x20c6b4(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4078c3:	00 
  4078c4:	0f 84 83 00 00 00    	je     40794d <_ZN6rocket6Config4loadEPKc+0x309d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4078ca:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4078cf:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4078d4:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4078d6:	85 c0                	test   %eax,%eax
  4078d8:	0f 8f 9d da ff ff    	jg     40537b <_ZN6rocket6Config4loadEPKc+0xacb>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4078de:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  4078e3:	e8 88 c4 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4078e8:	e9 8e da ff ff       	jmpq   40537b <_ZN6rocket6Config4loadEPKc+0xacb>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4078ed:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4078f0:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4078f3:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4078f6:	89 d0                	mov    %edx,%eax
  4078f8:	e9 f5 f0 ff ff       	jmpq   4069f2 <_ZN6rocket6Config4loadEPKc+0x2142>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4078fd:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  407900:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  407903:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407906:	89 d0                	mov    %edx,%eax
  407908:	e9 d4 fe ff ff       	jmpq   4077e1 <_ZN6rocket6Config4loadEPKc+0x2f31>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40790d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  407910:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  407913:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407916:	89 d0                	mov    %edx,%eax
  407918:	e9 f5 fe ff ff       	jmpq   407812 <_ZN6rocket6Config4loadEPKc+0x2f62>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40791d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  407920:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  407923:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407926:	89 d0                	mov    %edx,%eax
  407928:	e9 16 ff ff ff       	jmpq   407843 <_ZN6rocket6Config4loadEPKc+0x2f93>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40792d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  407930:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  407933:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407936:	89 d0                	mov    %edx,%eax
  407938:	e9 37 ff ff ff       	jmpq   407874 <_ZN6rocket6Config4loadEPKc+0x2fc4>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40793d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  407940:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  407943:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407946:	89 d0                	mov    %edx,%eax
  407948:	e9 58 ff ff ff       	jmpq   4078a5 <_ZN6rocket6Config4loadEPKc+0x2ff5>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40794d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  407950:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  407953:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  407956:	89 d0                	mov    %edx,%eax
  407958:	e9 79 ff ff ff       	jmpq   4078d6 <_ZN6rocket6Config4loadEPKc+0x3026>
  40795d:	49 89 c4             	mov    %rax,%r12
        if (_m.find(name) != _m.end())
        {
            istringstream iss(_m[name]);
            T num = 0;
            iss >> num;
            return num;
  407960:	48 89 ef             	mov    %rbp,%rdi
  407963:	4c 89 e5             	mov    %r12,%rbp
  407966:	e8 45 c5 ff ff       	callq  403eb0 <_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@plt>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40796b:	48 8b 84 24 40 03 00 	mov    0x340(%rsp),%rax
  407972:	00 
  407973:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407977:	48 39 df             	cmp    %rbx,%rdi
  40797a:	0f 85 13 01 00 00    	jne    407a93 <_ZN6rocket6Config4loadEPKc+0x31e3>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407980:	48 8b 84 24 f0 01 00 	mov    0x1f0(%rsp),%rax
  407987:	00 
  407988:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40798c:	48 39 df             	cmp    %rbx,%rdi
  40798f:	74 0d                	je     40799e <_ZN6rocket6Config4loadEPKc+0x30ee>
  407991:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407998:	00 
  407999:	e8 32 c9 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40799e:	48 8b 84 24 00 02 00 	mov    0x200(%rsp),%rax
  4079a5:	00 
  4079a6:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4079aa:	48 39 df             	cmp    %rbx,%rdi
  4079ad:	0f 85 b6 00 00 00    	jne    407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4079b3:	48 8b 84 24 d0 00 00 	mov    0xd0(%rsp),%rax
  4079ba:	00 
  4079bb:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4079bf:	48 39 df             	cmp    %rbx,%rdi
  4079c2:	74 0a                	je     4079ce <_ZN6rocket6Config4loadEPKc+0x311e>
  4079c4:	48 8b 74 24 68       	mov    0x68(%rsp),%rsi
  4079c9:	e8 02 c9 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4079ce:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  4079d5:	00 
  4079d6:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4079da:	48 39 df             	cmp    %rbx,%rdi
  4079dd:	74 0a                	je     4079e9 <_ZN6rocket6Config4loadEPKc+0x3139>
  4079df:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
  4079e4:	e8 e7 c8 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  4079e9:	48 89 eb             	mov    %rbp,%rbx
  4079ec:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4079f1:	48 8b b4 24 d0 03 00 	mov    0x3d0(%rsp),%rsi
  4079f8:	00 
  4079f9:	e8 d2 09 00 00       	callq  4083d0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E>
  4079fe:	48 89 df             	mov    %rbx,%rdi
  407a01:	e8 9a c7 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  407a06:	49 89 c4             	mov    %rax,%r12
  407a09:	49 8d 45 10          	lea    0x10(%r13),%rax
  407a0d:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  407a11:	4c 89 e5             	mov    %r12,%rbp
  407a14:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  407a1b:	00 
  407a1c:	e8 3f c5 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407a21:	48 8b 84 24 e0 02 00 	mov    0x2e0(%rsp),%rax
  407a28:	00 
  407a29:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407a2d:	48 39 df             	cmp    %rbx,%rdi
  407a30:	0f 85 c3 02 00 00    	jne    407cf9 <_ZN6rocket6Config4loadEPKc+0x3449>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407a36:	48 8b 84 24 70 01 00 	mov    0x170(%rsp),%rax
  407a3d:	00 
  407a3e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407a42:	48 39 df             	cmp    %rbx,%rdi
  407a45:	74 0d                	je     407a54 <_ZN6rocket6Config4loadEPKc+0x31a4>
  407a47:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407a4e:	00 
  407a4f:	e8 7c c8 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407a54:	48 8b 84 24 80 01 00 	mov    0x180(%rsp),%rax
  407a5b:	00 
  407a5c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407a60:	48 39 df             	cmp    %rbx,%rdi
  407a63:	0f 84 4a ff ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407a69:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407a70:	00 
  407a71:	e8 5a c8 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407a76:	e9 38 ff ff ff       	jmpq   4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407a7b:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407a7e:	48 8b 84 24 50 03 00 	mov    0x350(%rsp),%rax
  407a85:	00 
  407a86:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407a8a:	48 39 df             	cmp    %rbx,%rdi
  407a8d:	0f 84 ed fe ff ff    	je     407980 <_ZN6rocket6Config4loadEPKc+0x30d0>
  407a93:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407a9a:	00 
  407a9b:	e8 30 c8 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407aa0:	e9 db fe ff ff       	jmpq   407980 <_ZN6rocket6Config4loadEPKc+0x30d0>
  407aa5:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407aa8:	48 8b 84 24 b0 02 00 	mov    0x2b0(%rsp),%rax
  407aaf:	00 
  407ab0:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407ab4:	48 39 df             	cmp    %rbx,%rdi
  407ab7:	75 4c                	jne    407b05 <_ZN6rocket6Config4loadEPKc+0x3255>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407ab9:	48 8b 84 24 50 01 00 	mov    0x150(%rsp),%rax
  407ac0:	00 
  407ac1:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407ac5:	48 39 df             	cmp    %rbx,%rdi
  407ac8:	74 0d                	je     407ad7 <_ZN6rocket6Config4loadEPKc+0x3227>
  407aca:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407ad1:	00 
  407ad2:	e8 f9 c7 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407ad7:	48 8b 84 24 60 01 00 	mov    0x160(%rsp),%rax
  407ade:	00 
  407adf:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407ae3:	48 39 df             	cmp    %rbx,%rdi
  407ae6:	0f 84 c7 fe ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407aec:	e9 78 ff ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407af1:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407af4:	48 8b 84 24 c0 02 00 	mov    0x2c0(%rsp),%rax
  407afb:	00 
  407afc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407b00:	48 39 df             	cmp    %rbx,%rdi
  407b03:	74 b4                	je     407ab9 <_ZN6rocket6Config4loadEPKc+0x3209>
  407b05:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407b0c:	00 
  407b0d:	e8 be c7 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407b12:	eb a5                	jmp    407ab9 <_ZN6rocket6Config4loadEPKc+0x3209>
  407b14:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407b17:	48 8b 84 24 a0 03 00 	mov    0x3a0(%rsp),%rax
  407b1e:	00 
  407b1f:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407b23:	48 39 df             	cmp    %rbx,%rdi
  407b26:	74 0a                	je     407b32 <_ZN6rocket6Config4loadEPKc+0x3282>
  407b28:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  407b2d:	e8 9e c7 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407b32:	48 8b 84 24 30 02 00 	mov    0x230(%rsp),%rax
  407b39:	00 
  407b3a:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407b3e:	48 39 df             	cmp    %rbx,%rdi
  407b41:	74 0a                	je     407b4d <_ZN6rocket6Config4loadEPKc+0x329d>
  407b43:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
  407b48:	e8 83 c7 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407b4d:	48 8b 84 24 40 02 00 	mov    0x240(%rsp),%rax
  407b54:	00 
  407b55:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407b59:	48 39 df             	cmp    %rbx,%rdi
  407b5c:	0f 84 51 fe ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407b62:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
  407b67:	e8 64 c7 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407b6c:	e9 42 fe ff ff       	jmpq   4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407b71:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407b74:	48 8b 84 24 70 03 00 	mov    0x370(%rsp),%rax
  407b7b:	00 
  407b7c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407b80:	48 39 df             	cmp    %rbx,%rdi
  407b83:	75 4c                	jne    407bd1 <_ZN6rocket6Config4loadEPKc+0x3321>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407b85:	48 8b 84 24 10 02 00 	mov    0x210(%rsp),%rax
  407b8c:	00 
  407b8d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407b91:	48 39 df             	cmp    %rbx,%rdi
  407b94:	74 0d                	je     407ba3 <_ZN6rocket6Config4loadEPKc+0x32f3>
  407b96:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407b9d:	00 
  407b9e:	e8 2d c7 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407ba3:	48 8b 84 24 20 02 00 	mov    0x220(%rsp),%rax
  407baa:	00 
  407bab:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407baf:	48 39 df             	cmp    %rbx,%rdi
  407bb2:	0f 84 fb fd ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407bb8:	e9 ac fe ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407bbd:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407bc0:	48 8b 84 24 80 03 00 	mov    0x380(%rsp),%rax
  407bc7:	00 
  407bc8:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407bcc:	48 39 df             	cmp    %rbx,%rdi
  407bcf:	74 b4                	je     407b85 <_ZN6rocket6Config4loadEPKc+0x32d5>
  407bd1:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407bd8:	00 
  407bd9:	e8 f2 c6 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407bde:	eb a5                	jmp    407b85 <_ZN6rocket6Config4loadEPKc+0x32d5>
  407be0:	48 89 c3             	mov    %rax,%rbx
  407be3:	e9 04 fe ff ff       	jmpq   4079ec <_ZN6rocket6Config4loadEPKc+0x313c>
  407be8:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407beb:	48 8b 84 24 e0 01 00 	mov    0x1e0(%rsp),%rax
  407bf2:	00 
  407bf3:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407bf7:	48 39 df             	cmp    %rbx,%rdi
  407bfa:	0f 84 b3 fd ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407c00:	e9 64 fe ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407c05:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407c08:	48 8b 84 24 20 03 00 	mov    0x320(%rsp),%rax
  407c0f:	00 
  407c10:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407c14:	48 39 df             	cmp    %rbx,%rdi
  407c17:	0f 85 8b 00 00 00    	jne    407ca8 <_ZN6rocket6Config4loadEPKc+0x33f8>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407c1d:	48 8b 84 24 d0 01 00 	mov    0x1d0(%rsp),%rax
  407c24:	00 
  407c25:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407c29:	48 39 df             	cmp    %rbx,%rdi
  407c2c:	74 bd                	je     407beb <_ZN6rocket6Config4loadEPKc+0x333b>
  407c2e:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407c35:	00 
  407c36:	e8 95 c6 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407c3b:	eb ae                	jmp    407beb <_ZN6rocket6Config4loadEPKc+0x333b>
  407c3d:	49 89 c4             	mov    %rax,%r12
  407c40:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  407c45:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  407c49:	48 83 c0 10          	add    $0x10,%rax
  407c4d:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  407c54:	00 
  407c55:	e8 56 c5 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  407c5a:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  407c5e:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
  407c63:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  407c6a:	00 
  407c6b:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  407c72:	00 
  407c73:	49 8d 45 10          	lea    0x10(%r13),%rax
  407c77:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  407c7b:	4c 89 e5             	mov    %r12,%rbp
  407c7e:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  407c85:	00 
  407c86:	e8 d5 c2 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
  407c8b:	e9 18 fe ff ff       	jmpq   407aa8 <_ZN6rocket6Config4loadEPKc+0x31f8>
  407c90:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407c93:	48 8b 84 24 10 03 00 	mov    0x310(%rsp),%rax
  407c9a:	00 
  407c9b:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407c9f:	48 39 df             	cmp    %rbx,%rdi
  407ca2:	0f 84 75 ff ff ff    	je     407c1d <_ZN6rocket6Config4loadEPKc+0x336d>
  407ca8:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407caf:	00 
  407cb0:	e8 1b c6 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407cb5:	e9 63 ff ff ff       	jmpq   407c1d <_ZN6rocket6Config4loadEPKc+0x336d>
  407cba:	49 89 c4             	mov    %rax,%r12
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407cbd:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  407cc4:	00 
  407cc5:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407cc9:	48 39 df             	cmp    %rbx,%rdi
  407ccc:	0f 84 6e ff ff ff    	je     407c40 <_ZN6rocket6Config4loadEPKc+0x3390>
  407cd2:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  407cd7:	e8 f4 c5 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407cdc:	e9 5f ff ff ff       	jmpq   407c40 <_ZN6rocket6Config4loadEPKc+0x3390>
  407ce1:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407ce4:	48 8b 84 24 f0 02 00 	mov    0x2f0(%rsp),%rax
  407ceb:	00 
  407cec:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407cf0:	48 39 df             	cmp    %rbx,%rdi
  407cf3:	0f 84 3d fd ff ff    	je     407a36 <_ZN6rocket6Config4loadEPKc+0x3186>
  407cf9:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407d00:	00 
  407d01:	e8 ca c5 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407d06:	e9 2b fd ff ff       	jmpq   407a36 <_ZN6rocket6Config4loadEPKc+0x3186>
  407d0b:	49 89 c4             	mov    %rax,%r12
  407d0e:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  407d13:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  407d17:	48 83 c0 10          	add    $0x10,%rax
  407d1b:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  407d22:	00 
  407d23:	e8 88 c4 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  407d28:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  407d2c:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
  407d31:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  407d38:	00 
  407d39:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  407d40:	00 
  407d41:	e9 c3 fc ff ff       	jmpq   407a09 <_ZN6rocket6Config4loadEPKc+0x3159>
       *  string class does its own memory management.
      */
      explicit
      basic_istringstream(const __string_type& __str,
			  ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
  407d46:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  407d4a:	49 89 c4             	mov    %rax,%r12
  407d4d:	e8 9e 07 00 00       	callq  4084f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev>
  407d52:	e9 03 ff ff ff       	jmpq   407c5a <_ZN6rocket6Config4loadEPKc+0x33aa>
  407d57:	49 89 c4             	mov    %rax,%r12
  407d5a:	48 89 ef             	mov    %rbp,%rdi
  407d5d:	e8 4e c1 ff ff       	callq  403eb0 <_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@plt>
  407d62:	4c 89 e5             	mov    %r12,%rbp
  407d65:	e9 3e fd ff ff       	jmpq   407aa8 <_ZN6rocket6Config4loadEPKc+0x31f8>
  407d6a:	48 89 c5             	mov    %rax,%rbp
  407d6d:	e9 e2 fc ff ff       	jmpq   407a54 <_ZN6rocket6Config4loadEPKc+0x31a4>
  407d72:	48 89 c5             	mov    %rax,%rbp
  407d75:	e9 bc fc ff ff       	jmpq   407a36 <_ZN6rocket6Config4loadEPKc+0x3186>
  407d7a:	48 89 c5             	mov    %rax,%rbp
  407d7d:	e9 31 fc ff ff       	jmpq   4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407d82:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407d85:	48 8b 84 24 20 01 00 	mov    0x120(%rsp),%rax
  407d8c:	00 
  407d8d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407d91:	48 39 df             	cmp    %rbx,%rdi
  407d94:	74 0d                	je     407da3 <_ZN6rocket6Config4loadEPKc+0x34f3>
  407d96:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407d9d:	00 
  407d9e:	e8 2d c5 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407da3:	48 8b 84 24 30 01 00 	mov    0x130(%rsp),%rax
  407daa:	00 
  407dab:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407daf:	48 39 df             	cmp    %rbx,%rdi
  407db2:	0f 84 fb fb ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407db8:	e9 ac fc ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407dbd:	48 89 c5             	mov    %rax,%rbp
  407dc0:	eb e1                	jmp    407da3 <_ZN6rocket6Config4loadEPKc+0x34f3>
  407dc2:	e9 2a fd ff ff       	jmpq   407af1 <_ZN6rocket6Config4loadEPKc+0x3241>
  407dc7:	48 89 c5             	mov    %rax,%rbp
  407dca:	e9 9c fb ff ff       	jmpq   40796b <_ZN6rocket6Config4loadEPKc+0x30bb>
  407dcf:	48 89 c5             	mov    %rax,%rbp
  407dd2:	e9 4a fc ff ff       	jmpq   407a21 <_ZN6rocket6Config4loadEPKc+0x3171>
  407dd7:	e9 05 ff ff ff       	jmpq   407ce1 <_ZN6rocket6Config4loadEPKc+0x3431>
  407ddc:	49 89 c4             	mov    %rax,%r12
  407ddf:	e9 8f fe ff ff       	jmpq   407c73 <_ZN6rocket6Config4loadEPKc+0x33c3>
  407de4:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407de7:	48 8b 84 24 40 01 00 	mov    0x140(%rsp),%rax
  407dee:	00 
  407def:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407df3:	48 39 df             	cmp    %rbx,%rdi
  407df6:	74 0d                	je     407e05 <_ZN6rocket6Config4loadEPKc+0x3555>
  407df8:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407dff:	00 
  407e00:	e8 cb c4 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407e05:	48 8b 84 24 10 01 00 	mov    0x110(%rsp),%rax
  407e0c:	00 
  407e0d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407e11:	48 39 df             	cmp    %rbx,%rdi
  407e14:	0f 84 6b ff ff ff    	je     407d85 <_ZN6rocket6Config4loadEPKc+0x34d5>
  407e1a:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407e21:	00 
  407e22:	e8 a9 c4 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407e27:	e9 59 ff ff ff       	jmpq   407d85 <_ZN6rocket6Config4loadEPKc+0x34d5>
  407e2c:	48 89 c5             	mov    %rax,%rbp
  407e2f:	eb d4                	jmp    407e05 <_ZN6rocket6Config4loadEPKc+0x3555>
  407e31:	49 89 c4             	mov    %rax,%r12
  407e34:	49 8d 45 10          	lea    0x10(%r13),%rax
  407e38:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  407e3c:	4c 89 e5             	mov    %r12,%rbp
  407e3f:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  407e46:	00 
  407e47:	e8 14 c1 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
  407e4c:	e9 23 fd ff ff       	jmpq   407b74 <_ZN6rocket6Config4loadEPKc+0x32c4>
  407e51:	49 89 c4             	mov    %rax,%r12
  407e54:	49 8d 45 10          	lea    0x10(%r13),%rax
  407e58:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  407e5c:	4c 89 e5             	mov    %r12,%rbp
  407e5f:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  407e66:	00 
  407e67:	e8 f4 c0 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
  407e6c:	e9 a6 fc ff ff       	jmpq   407b17 <_ZN6rocket6Config4loadEPKc+0x3267>
  407e71:	48 89 c5             	mov    %rax,%rbp
  407e74:	e9 2a fd ff ff       	jmpq   407ba3 <_ZN6rocket6Config4loadEPKc+0x32f3>
  407e79:	48 89 c5             	mov    %rax,%rbp
  407e7c:	e9 1d fb ff ff       	jmpq   40799e <_ZN6rocket6Config4loadEPKc+0x30ee>
  407e81:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407e84:	48 8b 84 24 b0 03 00 	mov    0x3b0(%rsp),%rax
  407e8b:	00 
  407e8c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407e90:	48 39 df             	cmp    %rbx,%rdi
  407e93:	0f 84 99 fc ff ff    	je     407b32 <_ZN6rocket6Config4loadEPKc+0x3282>
  407e99:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407ea0:	00 
  407ea1:	e8 2a c4 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  407ea6:	e9 87 fc ff ff       	jmpq   407b32 <_ZN6rocket6Config4loadEPKc+0x3282>
  407eab:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  407eaf:	49 89 c4             	mov    %rax,%r12
  407eb2:	e8 39 06 00 00       	callq  4084f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev>
  407eb7:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  407ebb:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
  407ec0:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  407ec7:	00 
  407ec8:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  407ecf:	00 
  407ed0:	49 8d 45 10          	lea    0x10(%r13),%rax
  407ed4:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  407ed8:	4c 89 e5             	mov    %r12,%rbp
  407edb:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  407ee2:	00 
  407ee3:	e8 78 c0 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
  407ee8:	e9 7e fa ff ff       	jmpq   40796b <_ZN6rocket6Config4loadEPKc+0x30bb>
  407eed:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407ef0:	48 8b 84 24 50 02 00 	mov    0x250(%rsp),%rax
  407ef7:	00 
  407ef8:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407efc:	48 39 df             	cmp    %rbx,%rdi
  407eff:	74 0d                	je     407f0e <_ZN6rocket6Config4loadEPKc+0x365e>
  407f01:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407f08:	00 
  407f09:	e8 c2 c3 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407f0e:	48 8b 84 24 60 02 00 	mov    0x260(%rsp),%rax
  407f15:	00 
  407f16:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407f1a:	48 39 df             	cmp    %rbx,%rdi
  407f1d:	0f 84 90 fa ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407f23:	e9 41 fb ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407f28:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407f2b:	48 8b 84 24 70 02 00 	mov    0x270(%rsp),%rax
  407f32:	00 
  407f33:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407f37:	48 39 df             	cmp    %rbx,%rdi
  407f3a:	74 0d                	je     407f49 <_ZN6rocket6Config4loadEPKc+0x3699>
  407f3c:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407f43:	00 
  407f44:	e8 87 c3 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407f49:	48 8b 84 24 80 02 00 	mov    0x280(%rsp),%rax
  407f50:	00 
  407f51:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407f55:	48 39 df             	cmp    %rbx,%rdi
  407f58:	0f 84 55 fa ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407f5e:	e9 06 fb ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407f63:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407f66:	48 8b 84 24 90 02 00 	mov    0x290(%rsp),%rax
  407f6d:	00 
  407f6e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407f72:	48 39 df             	cmp    %rbx,%rdi
  407f75:	0f 84 38 fa ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407f7b:	e9 e9 fa ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407f80:	48 89 c5             	mov    %rax,%rbp
  407f83:	e9 f8 f9 ff ff       	jmpq   407980 <_ZN6rocket6Config4loadEPKc+0x30d0>
  407f88:	e9 ee fa ff ff       	jmpq   407a7b <_ZN6rocket6Config4loadEPKc+0x31cb>
  407f8d:	49 89 c4             	mov    %rax,%r12
  407f90:	49 8d 45 10          	lea    0x10(%r13),%rax
  407f94:	48 8d 7d 60          	lea    0x60(%rbp),%rdi
  407f98:	4c 89 e5             	mov    %r12,%rbp
  407f9b:	48 89 84 24 50 04 00 	mov    %rax,0x450(%rsp)
  407fa2:	00 
  407fa3:	e8 b8 bf ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
  407fa8:	e9 e6 fc ff ff       	jmpq   407c93 <_ZN6rocket6Config4loadEPKc+0x33e3>
  407fad:	49 89 c4             	mov    %rax,%r12
  407fb0:	e9 1b ff ff ff       	jmpq   407ed0 <_ZN6rocket6Config4loadEPKc+0x3620>
  407fb5:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407fb8:	48 8b 84 24 b0 01 00 	mov    0x1b0(%rsp),%rax
  407fbf:	00 
  407fc0:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407fc4:	48 39 df             	cmp    %rbx,%rdi
  407fc7:	0f 84 e6 f9 ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  407fcd:	e9 97 fa ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  407fd2:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407fd5:	48 8b 84 24 c0 01 00 	mov    0x1c0(%rsp),%rax
  407fdc:	00 
  407fdd:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407fe1:	48 39 df             	cmp    %rbx,%rdi
  407fe4:	74 0d                	je     407ff3 <_ZN6rocket6Config4loadEPKc+0x3743>
  407fe6:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  407fed:	00 
  407fee:	e8 dd c2 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  407ff3:	48 8b 84 24 90 01 00 	mov    0x190(%rsp),%rax
  407ffa:	00 
  407ffb:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  407fff:	48 39 df             	cmp    %rbx,%rdi
  408002:	74 0d                	je     408011 <_ZN6rocket6Config4loadEPKc+0x3761>
  408004:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  40800b:	00 
  40800c:	e8 bf c2 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408011:	48 8b 84 24 a0 01 00 	mov    0x1a0(%rsp),%rax
  408018:	00 
  408019:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40801d:	48 39 df             	cmp    %rbx,%rdi
  408020:	74 96                	je     407fb8 <_ZN6rocket6Config4loadEPKc+0x3708>
  408022:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  408029:	00 
  40802a:	e8 a1 c2 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  40802f:	eb 87                	jmp    407fb8 <_ZN6rocket6Config4loadEPKc+0x3708>
  408031:	48 89 c5             	mov    %rax,%rbp
  408034:	eb db                	jmp    408011 <_ZN6rocket6Config4loadEPKc+0x3761>
  408036:	48 89 c5             	mov    %rax,%rbp
  408039:	eb b8                	jmp    407ff3 <_ZN6rocket6Config4loadEPKc+0x3743>
  40803b:	49 89 c4             	mov    %rax,%r12
  40803e:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  408043:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  408047:	48 83 c0 10          	add    $0x10,%rax
  40804b:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  408052:	00 
  408053:	e8 58 c1 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  408058:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  40805c:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
  408061:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  408068:	00 
  408069:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  408070:	00 
  408071:	e9 be fd ff ff       	jmpq   407e34 <_ZN6rocket6Config4loadEPKc+0x3584>
  408076:	49 89 c4             	mov    %rax,%r12
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408079:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  408080:	00 
  408081:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408085:	48 39 df             	cmp    %rbx,%rdi
  408088:	74 b4                	je     40803e <_ZN6rocket6Config4loadEPKc+0x378e>
  40808a:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40808f:	e8 3c c2 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  408094:	eb a8                	jmp    40803e <_ZN6rocket6Config4loadEPKc+0x378e>
  408096:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  40809a:	49 89 c4             	mov    %rax,%r12
  40809d:	e8 4e 04 00 00       	callq  4084f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev>
  4080a2:	eb b4                	jmp    408058 <_ZN6rocket6Config4loadEPKc+0x37a8>
  4080a4:	49 89 c4             	mov    %rax,%r12
  4080a7:	48 89 ef             	mov    %rbp,%rdi
  4080aa:	e8 01 be ff ff       	callq  403eb0 <_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@plt>
  4080af:	4c 89 e5             	mov    %r12,%rbp
  4080b2:	e9 bd fa ff ff       	jmpq   407b74 <_ZN6rocket6Config4loadEPKc+0x32c4>
  4080b7:	48 89 c5             	mov    %rax,%rbp
  4080ba:	e9 c6 fa ff ff       	jmpq   407b85 <_ZN6rocket6Config4loadEPKc+0x32d5>
  4080bf:	48 89 c5             	mov    %rax,%rbp
  4080c2:	e9 f2 f9 ff ff       	jmpq   407ab9 <_ZN6rocket6Config4loadEPKc+0x3209>
  4080c7:	48 89 c5             	mov    %rax,%rbp
  4080ca:	e9 08 fa ff ff       	jmpq   407ad7 <_ZN6rocket6Config4loadEPKc+0x3227>
  4080cf:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4080d2:	48 8b 84 24 e0 00 00 	mov    0xe0(%rsp),%rax
  4080d9:	00 
  4080da:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4080de:	48 39 df             	cmp    %rbx,%rdi
  4080e1:	74 0d                	je     4080f0 <_ZN6rocket6Config4loadEPKc+0x3840>
  4080e3:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  4080ea:	00 
  4080eb:	e8 e0 c1 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4080f0:	48 8b 84 24 f0 00 00 	mov    0xf0(%rsp),%rax
  4080f7:	00 
  4080f8:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4080fc:	48 39 df             	cmp    %rbx,%rdi
  4080ff:	74 0d                	je     40810e <_ZN6rocket6Config4loadEPKc+0x385e>
  408101:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  408108:	00 
  408109:	e8 c2 c1 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40810e:	48 8b 84 24 00 01 00 	mov    0x100(%rsp),%rax
  408115:	00 
  408116:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40811a:	48 39 df             	cmp    %rbx,%rdi
  40811d:	0f 84 ab f8 ff ff    	je     4079ce <_ZN6rocket6Config4loadEPKc+0x311e>
  408123:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  40812a:	00 
  40812b:	e8 a0 c1 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  408130:	e9 99 f8 ff ff       	jmpq   4079ce <_ZN6rocket6Config4loadEPKc+0x311e>
  408135:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  408139:	49 89 c4             	mov    %rax,%r12
  40813c:	e8 af 03 00 00       	callq  4084f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev>
  408141:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  408145:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
  40814a:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  408151:	00 
  408152:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  408159:	00 
  40815a:	e9 f5 fc ff ff       	jmpq   407e54 <_ZN6rocket6Config4loadEPKc+0x35a4>
  40815f:	49 89 c4             	mov    %rax,%r12
  408162:	48 89 ef             	mov    %rbp,%rdi
  408165:	e8 46 bd ff ff       	callq  403eb0 <_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@plt>
  40816a:	4c 89 e5             	mov    %r12,%rbp
  40816d:	e9 a5 f9 ff ff       	jmpq   407b17 <_ZN6rocket6Config4loadEPKc+0x3267>
  408172:	48 89 c5             	mov    %rax,%rbp
  408175:	e9 a3 fa ff ff       	jmpq   407c1d <_ZN6rocket6Config4loadEPKc+0x336d>
  40817a:	e9 86 fa ff ff       	jmpq   407c05 <_ZN6rocket6Config4loadEPKc+0x3355>
  40817f:	49 89 c4             	mov    %rax,%r12
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408182:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  408189:	00 
  40818a:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40818e:	48 39 df             	cmp    %rbx,%rdi
  408191:	0f 84 77 fb ff ff    	je     407d0e <_ZN6rocket6Config4loadEPKc+0x345e>
  408197:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40819c:	e8 2f c1 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  4081a1:	e9 68 fb ff ff       	jmpq   407d0e <_ZN6rocket6Config4loadEPKc+0x345e>
  4081a6:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  4081aa:	49 89 c4             	mov    %rax,%r12
  4081ad:	e8 3e 03 00 00       	callq  4084f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev>
  4081b2:	e9 71 fb ff ff       	jmpq   407d28 <_ZN6rocket6Config4loadEPKc+0x3478>
  4081b7:	49 89 c4             	mov    %rax,%r12
  4081ba:	48 89 ef             	mov    %rbp,%rdi
  4081bd:	e8 ee bc ff ff       	callq  403eb0 <_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@plt>
  4081c2:	4c 89 e5             	mov    %r12,%rbp
  4081c5:	e9 57 f8 ff ff       	jmpq   407a21 <_ZN6rocket6Config4loadEPKc+0x3171>
  4081ca:	e9 ee f9 ff ff       	jmpq   407bbd <_ZN6rocket6Config4loadEPKc+0x330d>
  4081cf:	49 89 c4             	mov    %rax,%r12
  4081d2:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  4081d7:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  4081db:	48 83 c0 10          	add    $0x10,%rax
  4081df:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  4081e6:	00 
  4081e7:	e8 c4 bf ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  4081ec:	e9 c6 fc ff ff       	jmpq   407eb7 <_ZN6rocket6Config4loadEPKc+0x3607>
  4081f1:	49 89 c4             	mov    %rax,%r12
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4081f4:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  4081fb:	00 
  4081fc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408200:	48 39 df             	cmp    %rbx,%rdi
  408203:	74 cd                	je     4081d2 <_ZN6rocket6Config4loadEPKc+0x3922>
  408205:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40820a:	e8 c1 c0 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  40820f:	eb c1                	jmp    4081d2 <_ZN6rocket6Config4loadEPKc+0x3922>
  408211:	49 89 c4             	mov    %rax,%r12
  408214:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  408219:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  40821d:	48 83 c0 10          	add    $0x10,%rax
  408221:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  408228:	00 
  408229:	e8 82 bf ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  40822e:	e9 0e ff ff ff       	jmpq   408141 <_ZN6rocket6Config4loadEPKc+0x3891>
  408233:	49 89 c4             	mov    %rax,%r12
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408236:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  40823d:	00 
  40823e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408242:	48 39 df             	cmp    %rbx,%rdi
  408245:	74 cd                	je     408214 <_ZN6rocket6Config4loadEPKc+0x3964>
  408247:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40824c:	e8 7f c0 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  408251:	eb c1                	jmp    408214 <_ZN6rocket6Config4loadEPKc+0x3964>
  408253:	48 89 c5             	mov    %rax,%rbp
  408256:	e9 ee fc ff ff       	jmpq   407f49 <_ZN6rocket6Config4loadEPKc+0x3699>
  40825b:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40825e:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
  408265:	00 
  408266:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40826a:	48 39 df             	cmp    %rbx,%rdi
  40826d:	0f 84 76 f7 ff ff    	je     4079e9 <_ZN6rocket6Config4loadEPKc+0x3139>
  408273:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  40827a:	00 
  40827b:	e8 50 c0 ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  408280:	e9 64 f7 ff ff       	jmpq   4079e9 <_ZN6rocket6Config4loadEPKc+0x3139>
  408285:	48 89 c5             	mov    %rax,%rbp
  408288:	e9 81 fc ff ff       	jmpq   407f0e <_ZN6rocket6Config4loadEPKc+0x365e>
  40828d:	48 89 c5             	mov    %rax,%rbp
  408290:	e9 b8 f8 ff ff       	jmpq   407b4d <_ZN6rocket6Config4loadEPKc+0x329d>
  408295:	48 89 c5             	mov    %rax,%rbp
  408298:	e9 53 fe ff ff       	jmpq   4080f0 <_ZN6rocket6Config4loadEPKc+0x3840>
  40829d:	48 89 c5             	mov    %rax,%rbp
  4082a0:	e9 69 fe ff ff       	jmpq   40810e <_ZN6rocket6Config4loadEPKc+0x385e>
  4082a5:	48 89 c5             	mov    %rax,%rbp
  4082a8:	e9 21 f7 ff ff       	jmpq   4079ce <_ZN6rocket6Config4loadEPKc+0x311e>
  4082ad:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4082b0:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  4082b7:	00 
  4082b8:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4082bc:	48 3b 3d 9d bc 20 00 	cmp    0x20bc9d(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  4082c3:	0f 84 23 f7 ff ff    	je     4079ec <_ZN6rocket6Config4loadEPKc+0x313c>
  4082c9:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  4082d0:	00 
  4082d1:	e8 fa bf ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  4082d6:	e9 11 f7 ff ff       	jmpq   4079ec <_ZN6rocket6Config4loadEPKc+0x313c>
  4082db:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4082de:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
  4082e5:	00 
  4082e6:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4082ea:	48 39 df             	cmp    %rbx,%rdi
  4082ed:	74 0d                	je     4082fc <_ZN6rocket6Config4loadEPKc+0x3a4c>
  4082ef:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  4082f6:	00 
  4082f7:	e8 d4 bf ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4082fc:	48 8b 84 24 b0 00 00 	mov    0xb0(%rsp),%rax
  408303:	00 
  408304:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408308:	48 39 df             	cmp    %rbx,%rdi
  40830b:	0f 84 4d ff ff ff    	je     40825e <_ZN6rocket6Config4loadEPKc+0x39ae>
  408311:	48 8d b4 24 f0 03 00 	lea    0x3f0(%rsp),%rsi
  408318:	00 
  408319:	e8 b2 bf ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  40831e:	e9 3b ff ff ff       	jmpq   40825e <_ZN6rocket6Config4loadEPKc+0x39ae>
  408323:	48 89 c5             	mov    %rax,%rbp
  408326:	eb d4                	jmp    4082fc <_ZN6rocket6Config4loadEPKc+0x3a4c>
  408328:	48 89 c5             	mov    %rax,%rbp
  40832b:	e9 02 f8 ff ff       	jmpq   407b32 <_ZN6rocket6Config4loadEPKc+0x3282>
  408330:	e9 4c fb ff ff       	jmpq   407e81 <_ZN6rocket6Config4loadEPKc+0x35d1>
  408335:	49 89 c4             	mov    %rax,%r12
  408338:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40833d:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
  408341:	48 83 c0 10          	add    $0x10,%rax
  408345:	48 89 84 24 00 04 00 	mov    %rax,0x400(%rsp)
  40834c:	00 
  40834d:	e8 5e be ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  408352:	49 8b 47 e8          	mov    -0x18(%r15),%rax
  408356:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
  40835b:	4c 89 bc 24 f0 03 00 	mov    %r15,0x3f0(%rsp)
  408362:	00 
  408363:	48 89 8c 04 f0 03 00 	mov    %rcx,0x3f0(%rsp,%rax,1)
  40836a:	00 
  40836b:	e9 20 fc ff ff       	jmpq   407f90 <_ZN6rocket6Config4loadEPKc+0x36e0>
  408370:	49 89 c4             	mov    %rax,%r12
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408373:	48 8b 84 24 48 04 00 	mov    0x448(%rsp),%rax
  40837a:	00 
  40837b:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40837f:	48 39 df             	cmp    %rbx,%rdi
  408382:	74 b4                	je     408338 <_ZN6rocket6Config4loadEPKc+0x3a88>
  408384:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  408389:	e8 42 bf ff ff       	callq  4042d0 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  40838e:	eb a8                	jmp    408338 <_ZN6rocket6Config4loadEPKc+0x3a88>
  408390:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  408394:	49 89 c4             	mov    %rax,%r12
  408397:	e8 54 01 00 00       	callq  4084f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev>
  40839c:	eb b4                	jmp    408352 <_ZN6rocket6Config4loadEPKc+0x3aa2>
  40839e:	49 89 c4             	mov    %rax,%r12
  4083a1:	48 89 ef             	mov    %rbp,%rdi
  4083a4:	e8 07 bb ff ff       	callq  403eb0 <_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@plt>
  4083a9:	4c 89 e5             	mov    %r12,%rbp
  4083ac:	e9 e2 f8 ff ff       	jmpq   407c93 <_ZN6rocket6Config4loadEPKc+0x33e3>
  4083b1:	48 89 c5             	mov    %rax,%rbp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4083b4:	48 8b 84 24 a0 02 00 	mov    0x2a0(%rsp),%rax
  4083bb:	00 
  4083bc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4083c0:	48 39 df             	cmp    %rbx,%rdi
  4083c3:	0f 84 ea f5 ff ff    	je     4079b3 <_ZN6rocket6Config4loadEPKc+0x3103>
  4083c9:	e9 9b f6 ff ff       	jmpq   407a69 <_ZN6rocket6Config4loadEPKc+0x31b9>
  4083ce:	90                   	nop
  4083cf:	90                   	nop

00000000004083d0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E>:
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  4083d0:	41 56                	push   %r14
  4083d2:	41 55                	push   %r13
  4083d4:	41 54                	push   %r12
  4083d6:	55                   	push   %rbp
  4083d7:	53                   	push   %rbx
  4083d8:	48 89 f3             	mov    %rsi,%rbx
  4083db:	48 83 ec 10          	sub    $0x10,%rsp
    _M_erase(_Link_type __x)
    {
      // Erase without rebalancing.
      while (__x != 0)
  4083df:	48 85 f6             	test   %rsi,%rsi
  4083e2:	0f 84 d0 00 00 00    	je     4084b8 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0xe8>
  4083e8:	49 89 fd             	mov    %rdi,%r13
  4083eb:	48 8b 2d 6e bb 20 00 	mov    0x20bb6e(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4083f2:	4c 8d 74 24 0f       	lea    0xf(%rsp),%r14
  4083f7:	eb 28                	jmp    408421 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x51>
  4083f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408400:	48 8b 43 20          	mov    0x20(%rbx),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408404:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408408:	48 39 ef             	cmp    %rbp,%rdi
  40840b:	75 6b                	jne    408478 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0xa8>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40840d:	48 89 df             	mov    %rbx,%rdi
  408410:	4c 89 e3             	mov    %r12,%rbx
  408413:	e8 98 b7 ff ff       	callq  403bb0 <_ZdlPv@plt>
  408418:	4d 85 e4             	test   %r12,%r12
  40841b:	0f 84 97 00 00 00    	je     4084b8 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0xe8>
	{
	  _M_erase(_S_right(__x));
  408421:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  408425:	4c 89 ef             	mov    %r13,%rdi
  408428:	e8 a3 ff ff ff       	callq  4083d0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40842d:	48 8b 43 28          	mov    0x28(%rbx),%rax
  408431:	4c 8b 63 10          	mov    0x10(%rbx),%r12
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408435:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408439:	48 39 ef             	cmp    %rbp,%rdi
  40843c:	74 c2                	je     408400 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x30>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40843e:	48 83 3d 32 bb 20 00 	cmpq   $0x0,0x20bb32(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  408445:	00 
  408446:	0f 84 8c 00 00 00    	je     4084d8 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x108>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40844c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  408451:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  408456:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  408458:	85 c0                	test   %eax,%eax
  40845a:	7f a4                	jg     408400 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x30>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40845c:	4c 89 f6             	mov    %r14,%rsi
  40845f:	e8 0c b9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408464:	48 8b 43 20          	mov    0x20(%rbx),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408468:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40846c:	48 39 ef             	cmp    %rbp,%rdi
  40846f:	74 9c                	je     40840d <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x3d>
  408471:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  408478:	48 83 3d f8 ba 20 00 	cmpq   $0x0,0x20baf8(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40847f:	00 
  408480:	74 46                	je     4084c8 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0xf8>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  408482:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  408487:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40848c:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40848e:	85 c0                	test   %eax,%eax
  408490:	0f 8f 77 ff ff ff    	jg     40840d <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x3d>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  408496:	4c 89 f6             	mov    %r14,%rsi
  408499:	e8 d2 b8 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40849e:	48 89 df             	mov    %rbx,%rdi
  4084a1:	4c 89 e3             	mov    %r12,%rbx
  4084a4:	e8 07 b7 ff ff       	callq  403bb0 <_ZdlPv@plt>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {
      // Erase without rebalancing.
      while (__x != 0)
  4084a9:	4d 85 e4             	test   %r12,%r12
  4084ac:	0f 85 6f ff ff ff    	jne    408421 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x51>
  4084b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	  _M_erase(_S_right(__x));
	  _Link_type __y = _S_left(__x);
	  _M_destroy_node(__x);
	  __x = __y;
	}
    }
  4084b8:	48 83 c4 10          	add    $0x10,%rsp
  4084bc:	5b                   	pop    %rbx
  4084bd:	5d                   	pop    %rbp
  4084be:	41 5c                	pop    %r12
  4084c0:	41 5d                	pop    %r13
  4084c2:	41 5e                	pop    %r14
  4084c4:	c3                   	retq   
  4084c5:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4084c8:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4084cb:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4084ce:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4084d1:	89 d0                	mov    %edx,%eax
  4084d3:	eb b9                	jmp    40848e <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0xbe>
  4084d5:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4084d8:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4084db:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4084de:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4084e1:	89 d0                	mov    %edx,%eax
  4084e3:	e9 70 ff ff ff       	jmpq   408458 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E+0x88>
  4084e8:	90                   	nop
  4084e9:	90                   	nop
  4084ea:	90                   	nop
  4084eb:	90                   	nop
  4084ec:	90                   	nop
  4084ed:	90                   	nop
  4084ee:	90                   	nop
  4084ef:	90                   	nop

00000000004084f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev>:
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  4084f0:	53                   	push   %rbx
  4084f1:	48 89 fb             	mov    %rdi,%rbx
  4084f4:	48 83 ec 10          	sub    $0x10,%rsp
  4084f8:	48 8b 05 a9 b9 20 00 	mov    0x20b9a9(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  4084ff:	48 83 c0 10          	add    $0x10,%rax
  408503:	48 89 07             	mov    %rax,(%rdi)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408506:	48 8b 47 48          	mov    0x48(%rdi),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40850a:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40850e:	48 3b 3d 4b ba 20 00 	cmp    0x20ba4b(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  408515:	75 21                	jne    408538 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev+0x48>
  408517:	48 8b 05 3a ba 20 00 	mov    0x20ba3a(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  40851e:	48 8d 7b 38          	lea    0x38(%rbx),%rdi
  408522:	48 83 c0 10          	add    $0x10,%rax
  408526:	48 89 03             	mov    %rax,(%rbx)
  408529:	e8 82 bc ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  40852e:	48 83 c4 10          	add    $0x10,%rsp
  408532:	5b                   	pop    %rbx
  408533:	c3                   	retq   
  408534:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  408538:	48 83 3d 38 ba 20 00 	cmpq   $0x0,0x20ba38(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40853f:	00 
  408540:	74 1e                	je     408560 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev+0x70>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  408542:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  408547:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40854c:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40854e:	85 c0                	test   %eax,%eax
  408550:	7f c5                	jg     408517 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev+0x27>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  408552:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  408557:	e8 14 b8 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40855c:	eb b9                	jmp    408517 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev+0x27>
  40855e:	66 90                	xchg   %ax,%ax
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  408560:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  408563:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  408566:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  408569:	89 d0                	mov    %edx,%eax
  40856b:	eb e1                	jmp    40854e <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev+0x5e>
  40856d:	90                   	nop
  40856e:	90                   	nop
  40856f:	90                   	nop

0000000000408570 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev>:
  408570:	53                   	push   %rbx
  408571:	48 89 fb             	mov    %rdi,%rbx
  408574:	48 83 ec 10          	sub    $0x10,%rsp
  408578:	48 8b 05 29 b9 20 00 	mov    0x20b929(%rip),%rax        # 613ea8 <_DYNAMIC+0x220>
  40857f:	48 83 c0 10          	add    $0x10,%rax
  408583:	48 89 07             	mov    %rax,(%rdi)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408586:	48 8b 47 48          	mov    0x48(%rdi),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40858a:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40858e:	48 3b 3d cb b9 20 00 	cmp    0x20b9cb(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  408595:	75 29                	jne    4085c0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev+0x50>
  408597:	48 8b 05 ba b9 20 00 	mov    0x20b9ba(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  40859e:	48 8d 7b 38          	lea    0x38(%rbx),%rdi
  4085a2:	48 83 c0 10          	add    $0x10,%rax
  4085a6:	48 89 03             	mov    %rax,(%rbx)
  4085a9:	e8 02 bc ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
  4085ae:	48 89 df             	mov    %rbx,%rdi
  4085b1:	e8 fa b5 ff ff       	callq  403bb0 <_ZdlPv@plt>
  4085b6:	48 83 c4 10          	add    $0x10,%rsp
  4085ba:	5b                   	pop    %rbx
  4085bb:	c3                   	retq   
  4085bc:	0f 1f 40 00          	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4085c0:	48 83 3d b0 b9 20 00 	cmpq   $0x0,0x20b9b0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4085c7:	00 
  4085c8:	74 26                	je     4085f0 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev+0x80>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4085ca:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4085cf:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4085d4:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4085d6:	85 c0                	test   %eax,%eax
  4085d8:	7f bd                	jg     408597 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev+0x27>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4085da:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  4085df:	e8 8c b7 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4085e4:	eb b1                	jmp    408597 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev+0x27>
  4085e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4085ed:	00 00 00 
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4085f0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4085f3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4085f6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4085f9:	89 d0                	mov    %edx,%eax
  4085fb:	eb d9                	jmp    4085d6 <_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev+0x66>
  4085fd:	90                   	nop
  4085fe:	90                   	nop
  4085ff:	90                   	nop

0000000000408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>:

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408600:	41 57                	push   %r15
  408602:	41 56                	push   %r14
	  (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
  408604:	4c 8d 77 08          	lea    0x8(%rdi),%r14

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408608:	41 55                	push   %r13
  40860a:	41 54                	push   %r12
  40860c:	55                   	push   %rbp
  40860d:	53                   	push   %rbx
  40860e:	48 83 ec 08          	sub    $0x8,%rsp
  408612:	48 8b 6f 10          	mov    0x10(%rdi),%rbp
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  408616:	48 85 ed             	test   %rbp,%rbp
  408619:	0f 84 aa 00 00 00    	je     4086c9 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0xc9>
  40861f:	4c 8b 26             	mov    (%rsi),%r12
	  (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
  408622:	4d 89 f5             	mov    %r14,%r13
  408625:	4d 8b 7c 24 e8       	mov    -0x18(%r12),%r15
  40862a:	eb 16                	jmp    408642 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0x42>
  40862c:	0f 1f 40 00          	nopl   0x0(%rax)
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  408630:	89 d8                	mov    %ebx,%eax
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  408632:	85 c0                	test   %eax,%eax
  408634:	78 3f                	js     408675 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0x75>
	  (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
  408636:	49 89 ed             	mov    %rbp,%r13
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  408639:	48 8b 6d 10          	mov    0x10(%rbp),%rbp
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  40863d:	48 85 ed             	test   %rbp,%rbp
  408640:	74 3c                	je     40867e <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0x7e>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408642:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  408646:	4c 89 fa             	mov    %r15,%rdx
  408649:	4c 89 e6             	mov    %r12,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40864c:	48 8b 5f e8          	mov    -0x18(%rdi),%rbx
  408650:	4c 39 fb             	cmp    %r15,%rbx
  408653:	48 0f 46 d3          	cmovbe %rbx,%rdx
  408657:	e8 94 b9 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40865c:	85 c0                	test   %eax,%eax
  40865e:	75 d2                	jne    408632 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0x32>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  408660:	4c 29 fb             	sub    %r15,%rbx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  408663:	48 81 fb ff ff ff 7f 	cmp    $0x7fffffff,%rbx
  40866a:	7f ca                	jg     408636 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0x36>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  40866c:	48 81 fb 00 00 00 80 	cmp    $0xffffffff80000000,%rbx
  408673:	7d bb                	jge    408630 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0x30>
  408675:	48 8b 6d 18          	mov    0x18(%rbp),%rbp
  408679:	48 85 ed             	test   %rbp,%rbp
  40867c:	75 c4                	jne    408642 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0x42>
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
	      || _M_impl._M_key_compare(__k,
					_S_key(__j._M_node))) ? end() : __j;
  40867e:	4d 39 ee             	cmp    %r13,%r14
  408681:	74 46                	je     4086c9 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0xc9>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408683:	49 8b 75 20          	mov    0x20(%r13),%rsi
  408687:	4c 89 fa             	mov    %r15,%rdx
  40868a:	4c 89 e7             	mov    %r12,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40868d:	48 8b 5e e8          	mov    -0x18(%rsi),%rbx
  408691:	4c 39 fb             	cmp    %r15,%rbx
  408694:	48 0f 46 d3          	cmovbe %rbx,%rdx
  408698:	e8 53 b9 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40869d:	85 c0                	test   %eax,%eax
  40869f:	75 42                	jne    4086e3 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0xe3>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  4086a1:	49 29 df             	sub    %rbx,%r15

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  4086a4:	49 81 ff ff ff ff 7f 	cmp    $0x7fffffff,%r15
  4086ab:	7e 13                	jle    4086c0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0xc0>
    }
  4086ad:	48 83 c4 08          	add    $0x8,%rsp
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
	      || _M_impl._M_key_compare(__k,
					_S_key(__j._M_node))) ? end() : __j;
  4086b1:	4c 89 e8             	mov    %r13,%rax
    }
  4086b4:	5b                   	pop    %rbx
  4086b5:	5d                   	pop    %rbp
  4086b6:	41 5c                	pop    %r12
  4086b8:	41 5d                	pop    %r13
  4086ba:	41 5e                	pop    %r14
  4086bc:	41 5f                	pop    %r15
  4086be:	c3                   	retq   
  4086bf:	90                   	nop
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  4086c0:	49 81 ff 00 00 00 80 	cmp    $0xffffffff80000000,%r15
  4086c7:	7d 17                	jge    4086e0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0xe0>
  4086c9:	48 83 c4 08          	add    $0x8,%rsp
  4086cd:	4c 89 f0             	mov    %r14,%rax
  4086d0:	5b                   	pop    %rbx
  4086d1:	5d                   	pop    %rbp
  4086d2:	41 5c                	pop    %r12
  4086d4:	41 5d                	pop    %r13
  4086d6:	41 5e                	pop    %r14
  4086d8:	41 5f                	pop    %r15
  4086da:	c3                   	retq   
  4086db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4086e0:	44 89 f8             	mov    %r15d,%eax
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
	      || _M_impl._M_key_compare(__k,
					_S_key(__j._M_node))) ? end() : __j;
  4086e3:	85 c0                	test   %eax,%eax
  4086e5:	79 c6                	jns    4086ad <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0xad>
  4086e7:	eb e0                	jmp    4086c9 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_+0xc9>
  4086e9:	90                   	nop
  4086ea:	90                   	nop
  4086eb:	90                   	nop
  4086ec:	90                   	nop
  4086ed:	90                   	nop
  4086ee:	90                   	nop
  4086ef:	90                   	nop

00000000004086f0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_>:
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr,
	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  4086f0:	41 57                	push   %r15
  4086f2:	41 56                	push   %r14
  4086f4:	41 55                	push   %r13
  4086f6:	41 54                	push   %r12
  4086f8:	55                   	push   %rbp
  4086f9:	53                   	push   %rbx
  4086fa:	48 83 ec 18          	sub    $0x18,%rsp
  4086fe:	4c 8b 7f 10          	mov    0x10(%rdi),%r15
  408702:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  408707:	48 89 34 24          	mov    %rsi,(%rsp)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
  40870b:	4d 85 ff             	test   %r15,%r15
  40870e:	0f 84 d0 00 00 00    	je     4087e4 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0xf4>
  408714:	48 8b 04 24          	mov    (%rsp),%rax
  408718:	48 8b 28             	mov    (%rax),%rbp
  40871b:	4c 8b 6d e8          	mov    -0x18(%rbp),%r13
  40871f:	eb 24                	jmp    408745 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x55>
  408721:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  408728:	48 3d 00 00 00 80    	cmp    $0xffffffff80000000,%rax
  40872e:	7c 04                	jl     408734 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x44>
	{
	  __y = __x;
	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
	  __x = __comp ? _S_left(__x) : _S_right(__x);
  408730:	85 c0                	test   %eax,%eax
  408732:	79 44                	jns    408778 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x88>
  408734:	49 8b 47 10          	mov    0x10(%r15),%rax
  408738:	be 01 00 00 00       	mov    $0x1,%esi
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
  40873d:	48 85 c0             	test   %rax,%rax
  408740:	74 41                	je     408783 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x93>
  408742:	49 89 c7             	mov    %rax,%r15
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408745:	4d 8b 67 20          	mov    0x20(%r15),%r12
  408749:	4c 89 eb             	mov    %r13,%rbx
  40874c:	48 89 ef             	mov    %rbp,%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40874f:	4d 8b 74 24 e8       	mov    -0x18(%r12),%r14
  408754:	4c 89 e6             	mov    %r12,%rsi
  408757:	4d 39 ee             	cmp    %r13,%r14
  40875a:	49 0f 46 de          	cmovbe %r14,%rbx
  40875e:	48 89 da             	mov    %rbx,%rdx
  408761:	e8 8a b8 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  408766:	85 c0                	test   %eax,%eax
  408768:	75 c6                	jne    408730 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x40>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  40876a:	4c 89 e8             	mov    %r13,%rax
  40876d:	4c 29 f0             	sub    %r14,%rax

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  408770:	48 3d ff ff ff 7f    	cmp    $0x7fffffff,%rax
  408776:	7e b0                	jle    408728 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x38>
  408778:	49 8b 47 18          	mov    0x18(%r15),%rax
  40877c:	31 f6                	xor    %esi,%esi
  40877e:	48 85 c0             	test   %rax,%rax
  408781:	75 bf                	jne    408742 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x52>
	  __y = __x;
	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
	  __x = __comp ? _S_left(__x) : _S_right(__x);
	}
      iterator __j = iterator(__y);
      if (__comp)
  408783:	40 84 f6             	test   %sil,%sil
  408786:	48 89 da             	mov    %rbx,%rdx
  408789:	4c 89 fb             	mov    %r15,%rbx
  40878c:	75 62                	jne    4087f0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x100>
  40878e:	48 89 ee             	mov    %rbp,%rsi
  408791:	4c 89 e7             	mov    %r12,%rdi
  408794:	e8 57 b8 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  408799:	85 c0                	test   %eax,%eax
  40879b:	75 2f                	jne    4087cc <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0xdc>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  40879d:	4d 29 ee             	sub    %r13,%r14

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  4087a0:	49 81 fe ff ff ff 7f 	cmp    $0x7fffffff,%r14
  4087a7:	7e 17                	jle    4087c0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0xd0>
	  else
	    --__j;
	}
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
	return _Res(__x, __y);
      return _Res(__j._M_node, 0);
  4087a9:	4c 89 f8             	mov    %r15,%rax
  4087ac:	31 d2                	xor    %edx,%edx
    }
  4087ae:	48 83 c4 18          	add    $0x18,%rsp
  4087b2:	5b                   	pop    %rbx
  4087b3:	5d                   	pop    %rbp
  4087b4:	41 5c                	pop    %r12
  4087b6:	41 5d                	pop    %r13
  4087b8:	41 5e                	pop    %r14
  4087ba:	41 5f                	pop    %r15
  4087bc:	c3                   	retq   
  4087bd:	0f 1f 00             	nopl   (%rax)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  4087c0:	49 81 fe 00 00 00 80 	cmp    $0xffffffff80000000,%r14
  4087c7:	7c 07                	jl     4087d0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0xe0>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4087c9:	44 89 f0             	mov    %r14d,%eax
	  if (__j == begin())
	    return _Res(__x, __y);
	  else
	    --__j;
	}
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
  4087cc:	85 c0                	test   %eax,%eax
  4087ce:	79 d9                	jns    4087a9 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0xb9>
	return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }
  4087d0:	48 83 c4 18          	add    $0x18,%rsp
	    return _Res(__x, __y);
	  else
	    --__j;
	}
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
	return _Res(__x, __y);
  4087d4:	48 89 da             	mov    %rbx,%rdx
  4087d7:	31 c0                	xor    %eax,%eax
      return _Res(__j._M_node, 0);
    }
  4087d9:	5b                   	pop    %rbx
  4087da:	5d                   	pop    %rbp
  4087db:	41 5c                	pop    %r12
  4087dd:	41 5d                	pop    %r13
  4087df:	41 5e                	pop    %r14
  4087e1:	41 5f                	pop    %r15
  4087e3:	c3                   	retq   
	  (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
  4087e4:	4c 8d 7f 08          	lea    0x8(%rdi),%r15
  4087e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4087ef:	00 
	  __x = __comp ? _S_left(__x) : _S_right(__x);
	}
      iterator __j = iterator(__y);
      if (__comp)
	{
	  if (__j == begin())
  4087f0:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  4087f5:	4c 39 78 18          	cmp    %r15,0x18(%rax)
  4087f9:	74 31                	je     40882c <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x13c>
      }

      _Self&
      operator--() _GLIBCXX_NOEXCEPT
      {
	_M_node = _Rb_tree_decrement(_M_node);
  4087fb:	4c 89 ff             	mov    %r15,%rdi
  4087fe:	4c 89 fb             	mov    %r15,%rbx
  408801:	e8 7a b4 ff ff       	callq  403c80 <_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base@plt>
  408806:	48 8b 0c 24          	mov    (%rsp),%rcx
  40880a:	4c 8b 60 20          	mov    0x20(%rax),%r12
  40880e:	49 89 c7             	mov    %rax,%r15
  408811:	48 8b 29             	mov    (%rcx),%rbp
  408814:	4d 8b 74 24 e8       	mov    -0x18(%r12),%r14
  408819:	4c 8b 6d e8          	mov    -0x18(%rbp),%r13
  40881d:	4d 39 ee             	cmp    %r13,%r14
  408820:	4c 89 ea             	mov    %r13,%rdx
  408823:	49 0f 46 d6          	cmovbe %r14,%rdx
  408827:	e9 62 ff ff ff       	jmpq   40878e <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0x9e>
	}
      iterator __j = iterator(__y);
      if (__comp)
	{
	  if (__j == begin())
	    return _Res(__x, __y);
  40882c:	31 c0                	xor    %eax,%eax
  40882e:	4c 89 fa             	mov    %r15,%rdx
  408831:	e9 78 ff ff ff       	jmpq   4087ae <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_+0xbe>
  408836:	90                   	nop
  408837:	90                   	nop
  408838:	90                   	nop
  408839:	90                   	nop
  40883a:	90                   	nop
  40883b:	90                   	nop
  40883c:	90                   	nop
  40883d:	90                   	nop
  40883e:	90                   	nop
  40883f:	90                   	nop

0000000000408840 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_>:
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408840:	41 57                	push   %r15
	  (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
  408842:	48 8d 47 08          	lea    0x8(%rdi),%rax
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408846:	41 56                	push   %r14
  408848:	41 55                	push   %r13
  40884a:	41 54                	push   %r12
  40884c:	49 89 d5             	mov    %rdx,%r13
  40884f:	55                   	push   %rbp
  408850:	53                   	push   %rbx
  408851:	49 89 fc             	mov    %rdi,%r12
  408854:	48 89 f3             	mov    %rsi,%rbx
  408857:	48 83 ec 18          	sub    $0x18,%rsp
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;

      // end()
      if (__pos._M_node == _M_end())
  40885b:	48 39 c6             	cmp    %rax,%rsi
  40885e:	0f 84 44 01 00 00    	je     4089a8 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x168>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408864:	48 8b 4e 20          	mov    0x20(%rsi),%rcx
  408868:	4c 8b 3a             	mov    (%rdx),%r15
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40886b:	4c 8b 71 e8          	mov    -0x18(%rcx),%r14
  40886f:	49 8b 6f e8          	mov    -0x18(%r15),%rbp
  408873:	48 89 ce             	mov    %rcx,%rsi
  408876:	4c 89 ff             	mov    %r15,%rdi
  408879:	48 89 0c 24          	mov    %rcx,(%rsp)
  40887d:	49 39 ee             	cmp    %rbp,%r14
  408880:	49 89 e8             	mov    %rbp,%r8
  408883:	4d 0f 46 c6          	cmovbe %r14,%r8
  408887:	4c 89 c2             	mov    %r8,%rdx
  40888a:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  40888f:	e8 5c b7 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  408894:	85 c0                	test   %eax,%eax
  408896:	48 8b 0c 24          	mov    (%rsp),%rcx
  40889a:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  40889f:	0f 85 f3 00 00 00    	jne    408998 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x158>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  4088a5:	48 89 e8             	mov    %rbp,%rax
  4088a8:	4c 29 f0             	sub    %r14,%rax

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  4088ab:	48 3d ff ff ff 7f    	cmp    $0x7fffffff,%rax
  4088b1:	7e 4d                	jle    408900 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0xc0>
  4088b3:	4c 89 c2             	mov    %r8,%rdx
  4088b6:	4c 89 fe             	mov    %r15,%rsi
  4088b9:	48 89 cf             	mov    %rcx,%rdi
  4088bc:	e8 2f b7 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  4088c1:	85 c0                	test   %eax,%eax
  4088c3:	75 1c                	jne    4088e1 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0xa1>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  4088c5:	49 29 ee             	sub    %rbp,%r14

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  4088c8:	49 81 fe ff ff ff 7f 	cmp    $0x7fffffff,%r14
  4088cf:	7f 18                	jg     4088e9 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0xa9>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  4088d1:	49 81 fe 00 00 00 80 	cmp    $0xffffffff80000000,%r14
  4088d8:	0f 8c 42 01 00 00    	jl     408a20 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1e0>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4088de:	44 89 f0             	mov    %r14d,%eax
		return _Res(__pos._M_node, __pos._M_node);
	    }
	  else
	    return _M_get_insert_unique_pos(__k);
	}
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
  4088e1:	85 c0                	test   %eax,%eax
  4088e3:	0f 88 37 01 00 00    	js     408a20 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1e0>
	  else
	    return _M_get_insert_unique_pos(__k);
	}
      else
	// Equivalent keys.
	return _Res(__pos._M_node, 0);
  4088e9:	48 89 d8             	mov    %rbx,%rax
  4088ec:	31 d2                	xor    %edx,%edx
    }
  4088ee:	48 83 c4 18          	add    $0x18,%rsp
  4088f2:	5b                   	pop    %rbx
  4088f3:	5d                   	pop    %rbp
  4088f4:	41 5c                	pop    %r12
  4088f6:	41 5d                	pop    %r13
  4088f8:	41 5e                	pop    %r14
  4088fa:	41 5f                	pop    %r15
  4088fc:	c3                   	retq   
  4088fd:	0f 1f 00             	nopl   (%rax)
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  408900:	48 3d 00 00 00 80    	cmp    $0xffffffff80000000,%rax
  408906:	0f 8d 8c 00 00 00    	jge    408998 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x158>
	}
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
	{
	  // First, try before...
	  iterator __before = __pos;
	  if (__pos._M_node == _M_leftmost()) // begin()
  40890c:	49 39 5c 24 18       	cmp    %rbx,0x18(%r12)
	    return _Res(_M_leftmost(), _M_leftmost());
  408911:	48 89 d8             	mov    %rbx,%rax
  408914:	48 89 da             	mov    %rbx,%rdx
	}
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
	{
	  // First, try before...
	  iterator __before = __pos;
	  if (__pos._M_node == _M_leftmost()) // begin()
  408917:	74 d5                	je     4088ee <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0xae>
      }

      _Self&
      operator--() _GLIBCXX_NOEXCEPT
      {
	_M_node = _Rb_tree_decrement(_M_node);
  408919:	48 89 df             	mov    %rbx,%rdi
  40891c:	e8 5f b3 ff ff       	callq  403c80 <_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408921:	48 8b 78 20          	mov    0x20(%rax),%rdi
  408925:	48 89 ea             	mov    %rbp,%rdx
  408928:	4c 89 fe             	mov    %r15,%rsi
  40892b:	48 89 04 24          	mov    %rax,(%rsp)
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40892f:	4c 8b 77 e8          	mov    -0x18(%rdi),%r14
  408933:	49 39 ee             	cmp    %rbp,%r14
  408936:	49 0f 46 d6          	cmovbe %r14,%rdx
  40893a:	e8 b1 b6 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40893f:	85 c0                	test   %eax,%eax
  408941:	4c 8b 04 24          	mov    (%rsp),%r8
  408945:	75 1c                	jne    408963 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x123>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  408947:	49 29 ee             	sub    %rbp,%r14

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  40894a:	49 81 fe ff ff ff 7f 	cmp    $0x7fffffff,%r14
  408951:	0f 8f a9 00 00 00    	jg     408a00 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1c0>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  408957:	49 81 fe 00 00 00 80 	cmp    $0xffffffff80000000,%r14
  40895e:	7c 0b                	jl     40896b <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x12b>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  408960:	44 89 f0             	mov    %r14d,%eax
	{
	  // First, try before...
	  iterator __before = __pos;
	  if (__pos._M_node == _M_leftmost()) // begin()
	    return _Res(_M_leftmost(), _M_leftmost());
	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
  408963:	85 c0                	test   %eax,%eax
  408965:	0f 89 95 00 00 00    	jns    408a00 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1c0>
	    {
	      if (_S_right(__before._M_node) == 0)
		return _Res(0, __before._M_node);
  40896b:	49 83 78 18 00       	cmpq   $0x0,0x18(%r8)
  408970:	b9 00 00 00 00       	mov    $0x0,%ecx
  408975:	48 89 c8             	mov    %rcx,%rax
  408978:	48 0f 45 c3          	cmovne %rbx,%rax
  40897c:	49 0f 44 d8          	cmove  %r8,%rbx
	    return _M_get_insert_unique_pos(__k);
	}
      else
	// Equivalent keys.
	return _Res(__pos._M_node, 0);
    }
  408980:	48 83 c4 18          	add    $0x18,%rsp
	  if (__pos._M_node == _M_leftmost()) // begin()
	    return _Res(_M_leftmost(), _M_leftmost());
	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
	    {
	      if (_S_right(__before._M_node) == 0)
		return _Res(0, __before._M_node);
  408984:	48 89 da             	mov    %rbx,%rdx
	    return _M_get_insert_unique_pos(__k);
	}
      else
	// Equivalent keys.
	return _Res(__pos._M_node, 0);
    }
  408987:	5b                   	pop    %rbx
  408988:	5d                   	pop    %rbp
  408989:	41 5c                	pop    %r12
  40898b:	41 5d                	pop    %r13
  40898d:	41 5e                	pop    %r14
  40898f:	41 5f                	pop    %r15
  408991:	c3                   	retq   
  408992:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
	    return _Res(0, _M_rightmost());
	  else
	    return _M_get_insert_unique_pos(__k);
	}
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
  408998:	85 c0                	test   %eax,%eax
  40899a:	0f 89 13 ff ff ff    	jns    4088b3 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x73>
  4089a0:	e9 67 ff ff ff       	jmpq   40890c <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0xcc>
  4089a5:	0f 1f 00             	nopl   (%rax)
      typedef pair<_Base_ptr, _Base_ptr> _Res;

      // end()
      if (__pos._M_node == _M_end())
	{
	  if (size() > 0
  4089a8:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
  4089ad:	74 51                	je     408a00 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1c0>
	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
  4089af:	48 8b 5f 20          	mov    0x20(%rdi),%rbx
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4089b3:	48 8b 32             	mov    (%rdx),%rsi
  4089b6:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  4089ba:	4c 8b 76 e8          	mov    -0x18(%rsi),%r14
  4089be:	48 8b 6f e8          	mov    -0x18(%rdi),%rbp
  4089c2:	49 39 ee             	cmp    %rbp,%r14
  4089c5:	48 89 ea             	mov    %rbp,%rdx
  4089c8:	49 0f 46 d6          	cmovbe %r14,%rdx
  4089cc:	e8 1f b6 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  4089d1:	85 c0                	test   %eax,%eax
  4089d3:	75 1b                	jne    4089f0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1b0>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  4089d5:	4c 29 f5             	sub    %r14,%rbp

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  4089d8:	48 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%rbp
  4089df:	7f 1f                	jg     408a00 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1c0>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  4089e1:	48 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%rbp
  4089e8:	0f 8c a2 00 00 00    	jl     408a90 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x250>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  4089ee:	89 e8                	mov    %ebp,%eax
      typedef pair<_Base_ptr, _Base_ptr> _Res;

      // end()
      if (__pos._M_node == _M_end())
	{
	  if (size() > 0
  4089f0:	85 c0                	test   %eax,%eax
  4089f2:	0f 88 98 00 00 00    	js     408a90 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x250>
  4089f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4089ff:	00 
	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
	    return _Res(0, _M_rightmost());
	  else
	    return _M_get_insert_unique_pos(__k);
  408a00:	4c 89 ee             	mov    %r13,%rsi
  408a03:	4c 89 e7             	mov    %r12,%rdi
  408a06:	e8 e5 fc ff ff       	callq  4086f0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE24_M_get_insert_unique_posERS1_>
	    return _M_get_insert_unique_pos(__k);
	}
      else
	// Equivalent keys.
	return _Res(__pos._M_node, 0);
    }
  408a0b:	48 83 c4 18          	add    $0x18,%rsp
  408a0f:	5b                   	pop    %rbx
  408a10:	5d                   	pop    %rbp
  408a11:	41 5c                	pop    %r12
  408a13:	41 5d                	pop    %r13
  408a15:	41 5e                	pop    %r14
  408a17:	41 5f                	pop    %r15
  408a19:	c3                   	retq   
  408a1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	}
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
	{
	  // ... then try after.
	  iterator __after = __pos;
	  if (__pos._M_node == _M_rightmost())
  408a20:	49 39 5c 24 20       	cmp    %rbx,0x20(%r12)
  408a25:	74 69                	je     408a90 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x250>
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() _GLIBCXX_NOEXCEPT
      {
	_M_node = _Rb_tree_increment(_M_node);
  408a27:	48 89 df             	mov    %rbx,%rdi
  408a2a:	e8 41 b6 ff ff       	callq  404070 <_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408a2f:	48 8b 70 20          	mov    0x20(%rax),%rsi
  408a33:	48 89 ea             	mov    %rbp,%rdx
  408a36:	4c 89 ff             	mov    %r15,%rdi
  408a39:	48 89 04 24          	mov    %rax,(%rsp)
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408a3d:	4c 8b 76 e8          	mov    -0x18(%rsi),%r14
  408a41:	49 39 ee             	cmp    %rbp,%r14
  408a44:	49 0f 46 d6          	cmovbe %r14,%rdx
  408a48:	e8 a3 b5 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  408a4d:	85 c0                	test   %eax,%eax
  408a4f:	4c 8b 04 24          	mov    (%rsp),%r8
  408a53:	75 17                	jne    408a6c <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x22c>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  408a55:	4c 29 f5             	sub    %r14,%rbp

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  408a58:	48 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%rbp
  408a5f:	7f 9f                	jg     408a00 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1c0>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  408a61:	48 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%rbp
  408a68:	7c 06                	jl     408a70 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x230>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  408a6a:	89 e8                	mov    %ebp,%eax
	{
	  // ... then try after.
	  iterator __after = __pos;
	  if (__pos._M_node == _M_rightmost())
	    return _Res(0, _M_rightmost());
	  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
  408a6c:	85 c0                	test   %eax,%eax
  408a6e:	79 90                	jns    408a00 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0x1c0>
	    {
	      if (_S_right(__pos._M_node) == 0)
		return _Res(0, __pos._M_node);
  408a70:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  408a75:	b9 00 00 00 00       	mov    $0x0,%ecx
  408a7a:	48 89 c8             	mov    %rcx,%rax
  408a7d:	49 0f 45 d8          	cmovne %r8,%rbx
  408a81:	49 0f 45 c0          	cmovne %r8,%rax
  408a85:	48 89 da             	mov    %rbx,%rdx
  408a88:	e9 61 fe ff ff       	jmpq   4088ee <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_+0xae>
  408a8d:	0f 1f 00             	nopl   (%rax)
	    return _M_get_insert_unique_pos(__k);
	}
      else
	// Equivalent keys.
	return _Res(__pos._M_node, 0);
    }
  408a90:	48 83 c4 18          	add    $0x18,%rsp
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
	{
	  // ... then try after.
	  iterator __after = __pos;
	  if (__pos._M_node == _M_rightmost())
	    return _Res(0, _M_rightmost());
  408a94:	48 89 da             	mov    %rbx,%rdx
  408a97:	31 c0                	xor    %eax,%eax
	    return _M_get_insert_unique_pos(__k);
	}
      else
	// Equivalent keys.
	return _Res(__pos._M_node, 0);
    }
  408a99:	5b                   	pop    %rbx
  408a9a:	5d                   	pop    %rbp
  408a9b:	41 5c                	pop    %r12
  408a9d:	41 5d                	pop    %r13
  408a9f:	41 5e                	pop    %r14
  408aa1:	41 5f                	pop    %r15
  408aa3:	c3                   	retq   
  408aa4:	90                   	nop
  408aa5:	90                   	nop
  408aa6:	90                   	nop
  408aa7:	90                   	nop
  408aa8:	90                   	nop
  408aa9:	90                   	nop
  408aaa:	90                   	nop
  408aab:	90                   	nop
  408aac:	90                   	nop
  408aad:	90                   	nop
  408aae:	90                   	nop
  408aaf:	90                   	nop

0000000000408ab0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_>:

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408ab0:	41 56                	push   %r14
  408ab2:	41 55                	push   %r13
  408ab4:	49 89 cd             	mov    %rcx,%r13
  408ab7:	41 54                	push   %r12
  408ab9:	55                   	push   %rbp
  408aba:	48 89 fd             	mov    %rdi,%rbp
  408abd:	53                   	push   %rbx
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  408abe:	bf 30 00 00 00       	mov    $0x30,%edi
  408ac3:	49 89 f6             	mov    %rsi,%r14
  408ac6:	48 83 ec 20          	sub    $0x20,%rsp
  408aca:	e8 b1 b6 ff ff       	callq  404180 <_Znwm@plt>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
	   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
  408acf:	49 8b 75 00          	mov    0x0(%r13),%rsi
	_M_storage;

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
  408ad3:	4c 8d 60 20          	lea    0x20(%rax),%r12
  408ad7:	48 89 c3             	mov    %rax,%rbx
  408ada:	4c 89 e7             	mov    %r12,%rdi
  408add:	e8 de b1 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  408ae2:	4c 8b 2d 77 b4 20 00 	mov    0x20b477(%rip),%r13        # 613f60 <_DYNAMIC+0x2d8>
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  408ae9:	4c 89 e2             	mov    %r12,%rdx
  408aec:	4c 89 f6             	mov    %r14,%rsi
  408aef:	48 89 ef             	mov    %rbp,%rdi
  408af2:	49 8d 45 18          	lea    0x18(%r13),%rax
  408af6:	48 89 43 28          	mov    %rax,0x28(%rbx)
  408afa:	e8 41 fd ff ff       	callq  408840 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_>

	    if (__res.second)
  408aff:	48 85 d2             	test   %rdx,%rdx
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  408b02:	49 89 d4             	mov    %rdx,%r12

	    if (__res.second)
  408b05:	74 31                	je     408b38 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x88>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
			    || _M_impl._M_key_compare(_S_key(__z),
						      _S_key(__p)));
  408b07:	48 85 c0             	test   %rax,%rax
  408b0a:	48 8d 4d 08          	lea    0x8(%rbp),%rcx
  408b0e:	74 70                	je     408b80 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0xd0>

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408b10:	bf 01 00 00 00       	mov    $0x1,%edi
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
			    || _M_impl._M_key_compare(_S_key(__z),
						      _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
  408b15:	4c 89 e2             	mov    %r12,%rdx
  408b18:	48 89 de             	mov    %rbx,%rsi
  408b1b:	e8 00 b4 ff ff       	callq  403f20 <_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_@plt>
				    this->_M_impl._M_header);
      ++_M_impl._M_node_count;
  408b20:	48 83 45 28 01       	addq   $0x1,0x28(%rbp)
	__catch(...)
	  {
	    _M_destroy_node(__z);
	    __throw_exception_again;
	  }
      }
  408b25:	48 83 c4 20          	add    $0x20,%rsp
  408b29:	48 89 d8             	mov    %rbx,%rax
  408b2c:	5b                   	pop    %rbx
  408b2d:	5d                   	pop    %rbp
  408b2e:	41 5c                	pop    %r12
  408b30:	41 5d                	pop    %r13
  408b32:	41 5e                	pop    %r14
  408b34:	c3                   	retq   
  408b35:	0f 1f 00             	nopl   (%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408b38:	48 8b 53 28          	mov    0x28(%rbx),%rdx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408b3c:	48 8d 7a e8          	lea    -0x18(%rdx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408b40:	4c 39 ef             	cmp    %r13,%rdi
  408b43:	0f 85 97 00 00 00    	jne    408be0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x130>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408b49:	48 8b 53 20          	mov    0x20(%rbx),%rdx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408b4d:	48 8d 7a e8          	lea    -0x18(%rdx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408b51:	4c 39 ef             	cmp    %r13,%rdi
  408b54:	0f 85 c6 00 00 00    	jne    408c20 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x170>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  408b5a:	48 89 df             	mov    %rbx,%rdi
  408b5d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  408b62:	e8 49 b0 ff ff       	callq  403bb0 <_ZdlPv@plt>

	    if (__res.second)
	      return _M_insert_node(__res.first, __res.second, __z);

	    _M_destroy_node(__z);
	    return iterator(static_cast<_Link_type>(__res.first));
  408b67:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	__catch(...)
	  {
	    _M_destroy_node(__z);
	    __throw_exception_again;
	  }
      }
  408b6c:	48 83 c4 20          	add    $0x20,%rsp
  408b70:	5b                   	pop    %rbx
  408b71:	5d                   	pop    %rbp
  408b72:	41 5c                	pop    %r12
  408b74:	41 5d                	pop    %r13
  408b76:	41 5e                	pop    %r14
  408b78:	c3                   	retq   
  408b79:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
			    || _M_impl._M_key_compare(_S_key(__z),
						      _S_key(__p)));
  408b80:	48 39 ca             	cmp    %rcx,%rdx
  408b83:	74 8b                	je     408b10 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x60>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408b85:	48 8b 72 20          	mov    0x20(%rdx),%rsi
  408b89:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  408b8d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408b92:	4c 8b 6f e8          	mov    -0x18(%rdi),%r13
  408b96:	4c 8b 76 e8          	mov    -0x18(%rsi),%r14
  408b9a:	4c 89 ea             	mov    %r13,%rdx
  408b9d:	4d 39 ee             	cmp    %r13,%r14
  408ba0:	49 0f 46 d6          	cmovbe %r14,%rdx
  408ba4:	e8 47 b4 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  408ba9:	85 c0                	test   %eax,%eax
  408bab:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  408bb0:	75 22                	jne    408bd4 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x124>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  408bb2:	4d 29 f5             	sub    %r14,%r13

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  408bb5:	31 ff                	xor    %edi,%edi
  408bb7:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  408bbe:	0f 8f 51 ff ff ff    	jg     408b15 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x65>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  408bc4:	49 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%r13
  408bcb:	0f 8c 3f ff ff ff    	jl     408b10 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x60>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  408bd1:	44 89 e8             	mov    %r13d,%eax
  408bd4:	c1 e8 1f             	shr    $0x1f,%eax
  408bd7:	89 c7                	mov    %eax,%edi
  408bd9:	e9 37 ff ff ff       	jmpq   408b15 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x65>
  408bde:	66 90                	xchg   %ax,%ax
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  408be0:	48 83 3d 90 b3 20 00 	cmpq   $0x0,0x20b390(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  408be7:	00 
  408be8:	74 6d                	je     408c57 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x1a7>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  408bea:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  408bef:	f0 0f c1 4a f8       	lock xadd %ecx,-0x8(%rdx)
  408bf4:	89 ca                	mov    %ecx,%edx
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  408bf6:	85 d2                	test   %edx,%edx
  408bf8:	0f 8f 4b ff ff ff    	jg     408b49 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x99>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  408bfe:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  408c03:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  408c08:	e8 63 b1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  408c0d:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  408c12:	e9 32 ff ff ff       	jmpq   408b49 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x99>
  408c17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  408c1e:	00 00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  408c20:	48 83 3d 50 b3 20 00 	cmpq   $0x0,0x20b350(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  408c27:	00 
  408c28:	74 3a                	je     408c64 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x1b4>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  408c2a:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  408c2f:	f0 0f c1 4a f8       	lock xadd %ecx,-0x8(%rdx)
  408c34:	89 ca                	mov    %ecx,%edx
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  408c36:	85 d2                	test   %edx,%edx
  408c38:	0f 8f 1c ff ff ff    	jg     408b5a <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0xaa>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  408c3e:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  408c43:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  408c48:	e8 23 b1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  408c4d:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  408c52:	e9 03 ff ff ff       	jmpq   408b5a <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0xaa>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  408c57:	8b 4a f8             	mov    -0x8(%rdx),%ecx
    *__mem += __val;
  408c5a:	8d 71 ff             	lea    -0x1(%rcx),%esi
  408c5d:	89 72 f8             	mov    %esi,-0x8(%rdx)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  408c60:	89 ca                	mov    %ecx,%edx
  408c62:	eb 92                	jmp    408bf6 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x146>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  408c64:	8b 4a f8             	mov    -0x8(%rdx),%ecx
    *__mem += __val;
  408c67:	8d 71 ff             	lea    -0x1(%rcx),%esi
  408c6a:	89 72 f8             	mov    %esi,-0x8(%rdx)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  408c6d:	89 ca                	mov    %ecx,%edx
  408c6f:	eb c5                	jmp    408c36 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE22_M_emplace_hint_uniqueIIRKSt21piecewise_construct_tSt5tupleIIRS1_EESD_IIEEEEESt17_Rb_tree_iteratorIS2_ESt23_Rb_tree_const_iteratorIS2_EDpOT_+0x186>
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  408c71:	48 89 c7             	mov    %rax,%rdi
  408c74:	e8 87 b4 ff ff       	callq  404100 <__cxa_begin_catch@plt>
  408c79:	48 89 df             	mov    %rbx,%rdi
  408c7c:	e8 2f af ff ff       	callq  403bb0 <_ZdlPv@plt>
	    {
	      _M_put_node(__tmp);
	      __throw_exception_again;
  408c81:	e8 9a af ff ff       	callq  403c20 <__cxa_rethrow@plt>
  408c86:	48 89 c3             	mov    %rax,%rbx
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  408c89:	e8 f2 b3 ff ff       	callq  404080 <__cxa_end_catch@plt>
  408c8e:	48 89 df             	mov    %rbx,%rdi
  408c91:	e8 0a b5 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  408c96:	90                   	nop
  408c97:	90                   	nop
  408c98:	90                   	nop
  408c99:	90                   	nop
  408c9a:	90                   	nop
  408c9b:	90                   	nop
  408c9c:	90                   	nop
  408c9d:	90                   	nop
  408c9e:	90                   	nop
  408c9f:	90                   	nop

0000000000408ca0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44>:
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  408ca0:	48 85 ff             	test   %rdi,%rdi

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408ca3:	41 56                	push   %r14
  408ca5:	41 55                	push   %r13
  408ca7:	49 89 f5             	mov    %rsi,%r13
  408caa:	41 54                	push   %r12
  408cac:	55                   	push   %rbp
  408cad:	48 89 fd             	mov    %rdi,%rbp
  408cb0:	53                   	push   %rbx
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  408cb1:	74 5b                	je     408d0e <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x6e>
  408cb3:	4c 8b 22             	mov    (%rdx),%r12
  408cb6:	4d 8b 74 24 e8       	mov    -0x18(%r12),%r14
  408cbb:	eb 15                	jmp    408cd2 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x32>
  408cbd:	0f 1f 00             	nopl   (%rax)
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  408cc0:	89 d8                	mov    %ebx,%eax
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  408cc2:	85 c0                	test   %eax,%eax
  408cc4:	78 3f                	js     408d05 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x65>

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  408cc6:	49 89 ed             	mov    %rbp,%r13
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
  408cc9:	48 8b 6d 10          	mov    0x10(%rbp),%rbp
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
  408ccd:	48 85 ed             	test   %rbp,%rbp
  408cd0:	74 3c                	je     408d0e <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x6e>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408cd2:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  408cd6:	4c 89 f2             	mov    %r14,%rdx
  408cd9:	4c 89 e6             	mov    %r12,%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408cdc:	48 8b 5f e8          	mov    -0x18(%rdi),%rbx
  408ce0:	4c 39 f3             	cmp    %r14,%rbx
  408ce3:	48 0f 46 d3          	cmovbe %rbx,%rdx
  408ce7:	e8 04 b3 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  408cec:	85 c0                	test   %eax,%eax
  408cee:	75 d2                	jne    408cc2 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x22>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  408cf0:	4c 29 f3             	sub    %r14,%rbx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  408cf3:	48 81 fb ff ff ff 7f 	cmp    $0x7fffffff,%rbx
  408cfa:	7f ca                	jg     408cc6 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x26>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  408cfc:	48 81 fb 00 00 00 80 	cmp    $0xffffffff80000000,%rbx
  408d03:	7d bb                	jge    408cc0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x20>
  408d05:	48 8b 6d 18          	mov    0x18(%rbp),%rbp
  408d09:	48 85 ed             	test   %rbp,%rbp
  408d0c:	75 c4                	jne    408cd2 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44+0x32>
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
	else
	  __x = _S_right(__x);
      return iterator(__y);
    }
  408d0e:	5b                   	pop    %rbx
  408d0f:	4c 89 e8             	mov    %r13,%rax
  408d12:	5d                   	pop    %rbp
  408d13:	41 5c                	pop    %r12
  408d15:	41 5d                	pop    %r13
  408d17:	41 5e                	pop    %r14
  408d19:	c3                   	retq   
  408d1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000408d20 <_ZN6rocket12ConfigReader4trimERSs>:

    return true;
}

string& ConfigReader::trim(string& s)
{
  408d20:	41 54                	push   %r12
  408d22:	55                   	push   %rbp
  408d23:	53                   	push   %rbx
  408d24:	48 89 f3             	mov    %rsi,%rbx
  408d27:	48 83 ec 30          	sub    $0x30,%rsp
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408d2b:	48 8b 06             	mov    (%rsi),%rax
    if (s.empty())
  408d2e:	48 83 78 e8 00       	cmpq   $0x0,-0x18(%rax)
  408d33:	75 13                	jne    408d48 <_ZN6rocket12ConfigReader4trimERSs+0x28>
    string blank = " \r\n\t";
    s.erase(0, s.find_first_not_of(blank));
    s.erase(s.find_last_not_of(blank) + 1);
    
    return s;
}
  408d35:	48 83 c4 30          	add    $0x30,%rsp
  408d39:	48 89 d8             	mov    %rbx,%rax
  408d3c:	5b                   	pop    %rbx
  408d3d:	5d                   	pop    %rbp
  408d3e:	41 5c                	pop    %r12
  408d40:	c3                   	retq   
  408d41:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    {
        return s;
    }

    // 删除注释
    string comment = "#;";
  408d48:	4c 8d 64 24 20       	lea    0x20(%rsp),%r12
  408d4d:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  408d52:	48 8d 35 c4 76 00 00 	lea    0x76c4(%rip),%rsi        # 41041d <_ZStL19piecewise_construct+0x1>
  408d59:	4c 89 e2             	mov    %r12,%rdx
  408d5c:	e8 bf b0 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408d61:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
       *  npos.
      */
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
  408d66:	31 d2                	xor    %edx,%edx
  408d68:	48 89 df             	mov    %rbx,%rdi
  408d6b:	48 8b 4e e8          	mov    -0x18(%rsi),%rcx
  408d6f:	e8 3c b0 ff ff       	callq  403db0 <_ZNKSs13find_first_ofEPKcmm@plt>
    string::size_type n = s.find_first_of(comment);
    if (n != string::npos)
  408d74:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  408d78:	74 23                	je     408d9d <_ZN6rocket12ConfigReader4trimERSs+0x7d>
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408d7a:	48 8b 13             	mov    (%rbx),%rdx
  408d7d:	48 8b 4a e8          	mov    -0x18(%rdx),%rcx

      // NB: _M_limit doesn't check for a bad __pos value.
      size_type
      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
      {
	const bool __testoff =  __off < this->size() - __pos;
  408d81:	48 89 ca             	mov    %rcx,%rdx
  408d84:	48 29 c2             	sub    %rax,%rdx
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
  408d87:	48 39 c8             	cmp    %rcx,%rax
  408d8a:	0f 87 7d 01 00 00    	ja     408f0d <_ZN6rocket12ConfigReader4trimERSs+0x1ed>
       *  change if an error is thrown.
      */
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      { 
	_M_mutate(_M_check(__pos, "basic_string::erase"),
  408d90:	31 c9                	xor    %ecx,%ecx
  408d92:	48 89 c6             	mov    %rax,%rsi
  408d95:	48 89 df             	mov    %rbx,%rdi
  408d98:	e8 73 ad ff ff       	callq  403b10 <_ZNSs9_M_mutateEmmm@plt>
    {
        s.erase(n);
    }

    // 删除空白
    string blank = " \r\n\t";
  408d9d:	48 8d 6c 24 0f       	lea    0xf(%rsp),%rbp
  408da2:	48 8d 35 77 76 00 00 	lea    0x7677(%rip),%rsi        # 410420 <_ZStL19piecewise_construct+0x4>
  408da9:	4c 89 e7             	mov    %r12,%rdi
  408dac:	48 89 ea             	mov    %rbp,%rdx
  408daf:	e8 6c b0 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408db4:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
  408db9:	31 d2                	xor    %edx,%edx
  408dbb:	48 89 df             	mov    %rbx,%rdi
  408dbe:	48 8b 4e e8          	mov    -0x18(%rsi),%rcx
  408dc2:	e8 89 af ff ff       	callq  403d50 <_ZNKSs17find_first_not_ofEPKcmm@plt>
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408dc7:	48 8b 13             	mov    (%rbx),%rdx
       *  change if an error is thrown.
      */
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      { 
	_M_mutate(_M_check(__pos, "basic_string::erase"),
  408dca:	48 89 df             	mov    %rbx,%rdi
  408dcd:	48 8b 52 e8          	mov    -0x18(%rdx),%rdx
  408dd1:	48 39 d0             	cmp    %rdx,%rax
  408dd4:	48 0f 46 d0          	cmovbe %rax,%rdx
  408dd8:	31 c9                	xor    %ecx,%ecx
  408dda:	31 f6                	xor    %esi,%esi
  408ddc:	e8 2f ad ff ff       	callq  403b10 <_ZNSs9_M_mutateEmmm@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408de1:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
       *  npos.
      */
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
  408de6:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  408ded:	48 89 df             	mov    %rbx,%rdi
  408df0:	48 8b 4e e8          	mov    -0x18(%rsi),%rcx
  408df4:	e8 67 ac ff ff       	callq  403a60 <_ZNKSs16find_last_not_ofEPKcmm@plt>
    s.erase(0, s.find_first_not_of(blank));
    s.erase(s.find_last_not_of(blank) + 1);
  408df9:	48 8d 70 01          	lea    0x1(%rax),%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408dfd:	48 8b 03             	mov    (%rbx),%rax
  408e00:	48 8b 48 e8          	mov    -0x18(%rax),%rcx

      // NB: _M_limit doesn't check for a bad __pos value.
      size_type
      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
      {
	const bool __testoff =  __off < this->size() - __pos;
  408e04:	48 89 ca             	mov    %rcx,%rdx
  408e07:	48 29 f2             	sub    %rsi,%rdx
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
  408e0a:	48 39 ce             	cmp    %rcx,%rsi
  408e0d:	0f 87 a2 00 00 00    	ja     408eb5 <_ZN6rocket12ConfigReader4trimERSs+0x195>
       *  change if an error is thrown.
      */
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      { 
	_M_mutate(_M_check(__pos, "basic_string::erase"),
  408e13:	31 c9                	xor    %ecx,%ecx
  408e15:	48 89 df             	mov    %rbx,%rdi
  408e18:	e8 f3 ac ff ff       	callq  403b10 <_ZNSs9_M_mutateEmmm@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408e1d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408e22:	4c 8b 25 37 b1 20 00 	mov    0x20b137(%rip),%r12        # 613f60 <_DYNAMIC+0x2d8>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408e29:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408e2d:	4c 39 e7             	cmp    %r12,%rdi
  408e30:	75 3e                	jne    408e70 <_ZN6rocket12ConfigReader4trimERSs+0x150>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408e32:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408e37:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408e3b:	4c 39 e7             	cmp    %r12,%rdi
  408e3e:	0f 84 f1 fe ff ff    	je     408d35 <_ZN6rocket12ConfigReader4trimERSs+0x15>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  408e44:	48 83 3d 2c b1 20 00 	cmpq   $0x0,0x20b12c(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  408e4b:	00 
  408e4c:	74 4a                	je     408e98 <_ZN6rocket12ConfigReader4trimERSs+0x178>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  408e4e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  408e53:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  408e58:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  408e5a:	85 c0                	test   %eax,%eax
  408e5c:	0f 8f d3 fe ff ff    	jg     408d35 <_ZN6rocket12ConfigReader4trimERSs+0x15>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  408e62:	48 89 ee             	mov    %rbp,%rsi
  408e65:	e8 06 af ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  408e6a:	e9 c6 fe ff ff       	jmpq   408d35 <_ZN6rocket12ConfigReader4trimERSs+0x15>
  408e6f:	90                   	nop
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  408e70:	48 83 3d 00 b1 20 00 	cmpq   $0x0,0x20b100(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  408e77:	00 
  408e78:	74 2e                	je     408ea8 <_ZN6rocket12ConfigReader4trimERSs+0x188>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  408e7a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  408e7f:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  408e84:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  408e86:	85 c0                	test   %eax,%eax
  408e88:	7f a8                	jg     408e32 <_ZN6rocket12ConfigReader4trimERSs+0x112>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  408e8a:	48 89 ee             	mov    %rbp,%rsi
  408e8d:	e8 de ae ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  408e92:	eb 9e                	jmp    408e32 <_ZN6rocket12ConfigReader4trimERSs+0x112>
  408e94:	0f 1f 40 00          	nopl   0x0(%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  408e98:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  408e9b:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  408e9e:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  408ea1:	89 d0                	mov    %edx,%eax
  408ea3:	eb b5                	jmp    408e5a <_ZN6rocket12ConfigReader4trimERSs+0x13a>
  408ea5:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  408ea8:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  408eab:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  408eae:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  408eb1:	89 d0                	mov    %edx,%eax
  408eb3:	eb d1                	jmp    408e86 <_ZN6rocket12ConfigReader4trimERSs+0x166>

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
  408eb5:	48 89 f2             	mov    %rsi,%rdx
  408eb8:	48 8d 3d b1 75 00 00 	lea    0x75b1(%rip),%rdi        # 410470 <_ZStL19piecewise_construct+0x54>
  408ebf:	48 8d 35 5f 75 00 00 	lea    0x755f(%rip),%rsi        # 410425 <_ZStL19piecewise_construct+0x9>
  408ec6:	31 c0                	xor    %eax,%eax
  408ec8:	e8 23 ac ff ff       	callq  403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>
  408ecd:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408ed0:	48 8b 44 24 20       	mov    0x20(%rsp),%rax

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408ed5:	4c 8b 25 84 b0 20 00 	mov    0x20b084(%rip),%r12        # 613f60 <_DYNAMIC+0x2d8>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408edc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408ee0:	4c 39 e7             	cmp    %r12,%rdi
  408ee3:	74 08                	je     408eed <_ZN6rocket12ConfigReader4trimERSs+0x1cd>
  408ee5:	48 89 ee             	mov    %rbp,%rsi
  408ee8:	e8 0b b4 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408eed:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  408ef2:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408ef6:	4c 39 e7             	cmp    %r12,%rdi
  408ef9:	74 0a                	je     408f05 <_ZN6rocket12ConfigReader4trimERSs+0x1e5>
  408efb:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  408f00:	e8 f3 b3 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  408f05:	48 89 df             	mov    %rbx,%rdi
  408f08:	e8 93 b2 ff ff       	callq  4041a0 <_Unwind_Resume@plt>

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
  408f0d:	48 8d 35 11 75 00 00 	lea    0x7511(%rip),%rsi        # 410425 <_ZStL19piecewise_construct+0x9>
  408f14:	48 8d 3d 55 75 00 00 	lea    0x7555(%rip),%rdi        # 410470 <_ZStL19piecewise_construct+0x54>
  408f1b:	48 89 c2             	mov    %rax,%rdx
  408f1e:	31 c0                	xor    %eax,%eax
  408f20:	e8 cb ab ff ff       	callq  403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>
  408f25:	48 89 c3             	mov    %rax,%rbx
  408f28:	4c 8b 25 31 b0 20 00 	mov    0x20b031(%rip),%r12        # 613f60 <_DYNAMIC+0x2d8>
  408f2f:	eb bc                	jmp    408eed <_ZN6rocket12ConfigReader4trimERSs+0x1cd>
  408f31:	90                   	nop
  408f32:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  408f39:	1f 84 00 00 00 00 00 

0000000000408f40 <_ZN6rocket12ConfigReader9isSectionESsRSs>:
 * @param line    a line from the config file
 * @param section section description
 *
 * @return return true and set section if the line is a section, else false
 */
bool ConfigReader::isSection(string line, string& section) {
  408f40:	41 56                	push   %r14
  408f42:	41 55                	push   %r13
  408f44:	49 89 d5             	mov    %rdx,%r13
  408f47:	41 54                	push   %r12
  408f49:	55                   	push   %rbp
  408f4a:	49 89 fc             	mov    %rdi,%r12
  408f4d:	53                   	push   %rbx
  408f4e:	48 83 ec 40          	sub    $0x40,%rsp
    string sec = trim(line);
  408f52:	48 8d 5c 24 20       	lea    0x20(%rsp),%rbx
  408f57:	e8 c4 fd ff ff       	callq  408d20 <_ZN6rocket12ConfigReader4trimERSs>
  408f5c:	48 89 df             	mov    %rbx,%rdi
  408f5f:	48 89 c6             	mov    %rax,%rsi
  408f62:	e8 59 ad ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  408f67:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx

    if (sec.empty() || sec.length() <= 2)
  408f6c:	48 83 79 e8 02       	cmpq   $0x2,-0x18(%rcx)
  408f71:	76 20                	jbe    408f93 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x53>
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()    // for use in begin() & non-const op[]
      {
	if (!_M_rep()->_M_is_leaked())
  408f73:	8b 51 f8             	mov    -0x8(%rcx),%edx
  408f76:	85 d2                	test   %edx,%edx
  408f78:	78 14                	js     408f8e <_ZN6rocket12ConfigReader9isSectionESsRSs+0x4e>
	  _M_leak_hard();
  408f7a:	48 89 df             	mov    %rbx,%rdi
  408f7d:	48 8b 2d dc af 20 00 	mov    0x20afdc(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  408f84:	e8 67 b2 ff ff       	callq  4041f0 <_ZNSs12_M_leak_hardEv@plt>
  408f89:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
        return false;

    if (sec.at(0) != '[' || sec.at(sec.length() - 1) != ']')
  408f8e:	80 39 5b             	cmpb   $0x5b,(%rcx)
  408f91:	74 5d                	je     408ff0 <_ZN6rocket12ConfigReader9isSectionESsRSs+0xb0>
  408f93:	48 8b 2d c6 af 20 00 	mov    0x20afc6(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
 */
bool ConfigReader::isSection(string line, string& section) {
    string sec = trim(line);

    if (sec.empty() || sec.length() <= 2)
        return false;
  408f9a:	31 c0                	xor    %eax,%eax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  408f9c:	48 8d 79 e8          	lea    -0x18(%rcx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  408fa0:	48 39 ef             	cmp    %rbp,%rdi
  408fa3:	75 13                	jne    408fb8 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x78>
    sec = sec.substr(1, sec.length() - 2);
    sec = trim(sec);
    section = sec;

    return true;
}
  408fa5:	48 83 c4 40          	add    $0x40,%rsp
  408fa9:	5b                   	pop    %rbx
  408faa:	5d                   	pop    %rbp
  408fab:	41 5c                	pop    %r12
  408fad:	41 5d                	pop    %r13
  408faf:	41 5e                	pop    %r14
  408fb1:	c3                   	retq   
  408fb2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  408fb8:	48 83 3d b8 af 20 00 	cmpq   $0x0,0x20afb8(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  408fbf:	00 
  408fc0:	0f 84 e2 00 00 00    	je     4090a8 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x168>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  408fc6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  408fcb:	f0 0f c1 51 f8       	lock xadd %edx,-0x8(%rcx)
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  408fd0:	85 d2                	test   %edx,%edx
  408fd2:	7f d1                	jg     408fa5 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x65>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  408fd4:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
  408fd9:	88 44 24 0f          	mov    %al,0xf(%rsp)
  408fdd:	e8 8e ad ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  408fe2:	0f b6 44 24 0f       	movzbl 0xf(%rsp),%eax
  408fe7:	eb bc                	jmp    408fa5 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x65>
  408fe9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      length() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  408ff0:	4c 8b 71 e8          	mov    -0x18(%rcx),%r14
    string sec = trim(line);

    if (sec.empty() || sec.length() <= 2)
        return false;

    if (sec.at(0) != '[' || sec.at(sec.length() - 1) != ']')
  408ff4:	49 8d 76 ff          	lea    -0x1(%r14),%rsi
       *  unsharing the string.
       */
      reference
      at(size_type __n)
      {
	if (__n >= size())
  408ff8:	4c 39 f6             	cmp    %r14,%rsi
  408ffb:	0f 83 e8 00 00 00    	jae    4090e9 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x1a9>
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()    // for use in begin() & non-const op[]
      {
	if (!_M_rep()->_M_is_leaked())
  409001:	8b 41 f8             	mov    -0x8(%rcx),%eax
  409004:	85 c0                	test   %eax,%eax
  409006:	78 14                	js     40901c <_ZN6rocket12ConfigReader9isSectionESsRSs+0xdc>
	  _M_leak_hard();
  409008:	48 89 df             	mov    %rbx,%rdi
  40900b:	48 8b 2d 4e af 20 00 	mov    0x20af4e(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  409012:	e8 d9 b1 ff ff       	callq  4041f0 <_ZNSs12_M_leak_hardEv@plt>
  409017:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
  40901c:	42 80 7c 31 ff 5d    	cmpb   $0x5d,-0x1(%rcx,%r14,1)
  409022:	0f 85 6b ff ff ff    	jne    408f93 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x53>

      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      length() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  409028:	48 8b 41 e8          	mov    -0x18(%rcx),%rax
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
  40902c:	48 85 c0             	test   %rax,%rax
        return false;

    sec = sec.substr(1, sec.length() - 2);
  40902f:	48 8d 48 fe          	lea    -0x2(%rax),%rcx
  409033:	0f 84 0f 01 00 00    	je     409148 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x208>
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }
  409039:	4c 8d 74 24 30       	lea    0x30(%rsp),%r14
  40903e:	ba 01 00 00 00       	mov    $0x1,%edx
  409043:	48 89 de             	mov    %rbx,%rsi
  409046:	48 8b 2d 13 af 20 00 	mov    0x20af13(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  40904d:	4c 89 f7             	mov    %r14,%rdi
  409050:	e8 3b b1 ff ff       	callq  404190 <_ZNSsC1ERKSsmm@plt>
      // PR 58265, this should be noexcept.
      basic_string&
      operator=(basic_string&& __str)
      {
	// NB: DR 1204.
	this->swap(__str);
  409055:	4c 89 f6             	mov    %r14,%rsi
  409058:	48 89 df             	mov    %rbx,%rdi
  40905b:	e8 b0 b1 ff ff       	callq  404210 <_ZNSs4swapERSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409060:	48 8b 44 24 30       	mov    0x30(%rsp),%rax

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409065:	48 8b 2d f4 ae 20 00 	mov    0x20aef4(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40906c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409070:	48 39 ef             	cmp    %rbp,%rdi
  409073:	75 41                	jne    4090b6 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x176>
    sec = trim(sec);
  409075:	48 89 de             	mov    %rbx,%rsi
  409078:	4c 89 e7             	mov    %r12,%rdi
  40907b:	e8 a0 fc ff ff       	callq  408d20 <_ZN6rocket12ConfigReader4trimERSs>
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  409080:	48 89 c6             	mov    %rax,%rsi
  409083:	48 89 df             	mov    %rbx,%rdi
  409086:	e8 35 af ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
  40908b:	48 89 de             	mov    %rbx,%rsi
  40908e:	4c 89 ef             	mov    %r13,%rdi
  409091:	e8 2a af ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
  409096:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
    section = sec;

    return true;
  40909b:	b8 01 00 00 00       	mov    $0x1,%eax
  4090a0:	e9 f7 fe ff ff       	jmpq   408f9c <_ZN6rocket12ConfigReader9isSectionESsRSs+0x5c>
  4090a5:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4090a8:	8b 51 f8             	mov    -0x8(%rcx),%edx
    *__mem += __val;
  4090ab:	8d 72 ff             	lea    -0x1(%rdx),%esi
  4090ae:	89 71 f8             	mov    %esi,-0x8(%rcx)
  4090b1:	e9 1a ff ff ff       	jmpq   408fd0 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x90>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4090b6:	48 83 3d ba ae 20 00 	cmpq   $0x0,0x20aeba(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4090bd:	00 
  4090be:	74 1c                	je     4090dc <_ZN6rocket12ConfigReader9isSectionESsRSs+0x19c>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4090c0:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4090c5:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4090ca:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4090cc:	85 c0                	test   %eax,%eax
  4090ce:	7f a5                	jg     409075 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x135>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4090d0:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  4090d5:	e8 96 ac ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4090da:	eb 99                	jmp    409075 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x135>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4090dc:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4090df:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4090e2:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4090e5:	89 d0                	mov    %edx,%eax
  4090e7:	eb e3                	jmp    4090cc <_ZN6rocket12ConfigReader9isSectionESsRSs+0x18c>
       */
      reference
      at(size_type __n)
      {
	if (__n >= size())
	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
  4090e9:	48 8d 3d b8 73 00 00 	lea    0x73b8(%rip),%rdi        # 4104a8 <_ZStL19piecewise_construct+0x8c>
  4090f0:	4c 89 f2             	mov    %r14,%rdx
  4090f3:	31 c0                	xor    %eax,%eax
  4090f5:	48 8b 2d 64 ae 20 00 	mov    0x20ae64(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  4090fc:	e8 ef a9 ff ff       	callq  403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>
  409101:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409104:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  409109:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40910d:	48 39 ef             	cmp    %rbp,%rdi
  409110:	74 0a                	je     40911c <_ZN6rocket12ConfigReader9isSectionESsRSs+0x1dc>
  409112:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  409117:	e8 dc b1 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40911c:	48 89 df             	mov    %rbx,%rdi
  40911f:	e8 7c b0 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  409124:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409127:	48 8b 44 24 30       	mov    0x30(%rsp),%rax

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40912c:	48 8b 2d 2d ae 20 00 	mov    0x20ae2d(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409133:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409137:	48 39 ef             	cmp    %rbp,%rdi
  40913a:	74 c8                	je     409104 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x1c4>
  40913c:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  409141:	e8 b2 b1 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  409146:	eb bc                	jmp    409104 <_ZN6rocket12ConfigReader9isSectionESsRSs+0x1c4>

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
  409148:	48 8d 35 ea 72 00 00 	lea    0x72ea(%rip),%rsi        # 410439 <_ZStL19piecewise_construct+0x1d>
  40914f:	48 8d 3d 1a 73 00 00 	lea    0x731a(%rip),%rdi        # 410470 <_ZStL19piecewise_construct+0x54>
  409156:	31 c9                	xor    %ecx,%ecx
  409158:	ba 01 00 00 00       	mov    $0x1,%edx
  40915d:	31 c0                	xor    %eax,%eax
  40915f:	48 8b 2d fa ad 20 00 	mov    0x20adfa(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  409166:	e8 85 a9 ff ff       	callq  403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>
  40916b:	90                   	nop
  40916c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000409170 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b>:
//}

bool ConfigReader::GetBool(const string& section,
                           const string& key,
                           bool default_value)
{
  409170:	41 57                	push   %r15
  409172:	41 56                	push   %r14
  409174:	41 55                	push   %r13
  409176:	41 54                	push   %r12
  409178:	41 89 cd             	mov    %ecx,%r13d
  40917b:	55                   	push   %rbp
  40917c:	53                   	push   %rbx
  40917d:	48 89 fd             	mov    %rdi,%rbp
  409180:	48 89 d3             	mov    %rdx,%rbx
  409183:	48 83 ec 48          	sub    $0x48,%rsp
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  409187:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
  40918c:	4c 89 e7             	mov    %r12,%rdi
  40918f:	e8 2c ab ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  409194:	48 8d 35 19 72 00 00 	lea    0x7219(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  40919b:	ba 01 00 00 00       	mov    $0x1,%edx
  4091a0:	4c 89 e7             	mov    %r12,%rdi
  4091a3:	e8 a8 a8 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  4091a8:	48 89 de             	mov    %rbx,%rsi
  4091ab:	4c 89 e7             	mov    %r12,%rdi
  4091ae:	e8 8d b0 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  4091b3:	48 8b 10             	mov    (%rax),%rdx
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  4091b6:	48 8b 1d a3 ad 20 00 	mov    0x20ada3(%rip),%rbx        # 613f60 <_DYNAMIC+0x2d8>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  4091bd:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  4091c2:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  4091c6:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4091c9:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4091ce:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4091d2:	48 39 df             	cmp    %rbx,%rdi
  4091d5:	0f 85 95 01 00 00    	jne    409370 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x200>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  4091db:	4c 8d 74 24 20       	lea    0x20(%rsp),%r14
			      (this->_M_impl._M_header._M_left));
      }

      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
  4091e0:	4c 8d 7d 08          	lea    0x8(%rbp),%r15
  4091e4:	48 89 ef             	mov    %rbp,%rdi
  4091e7:	4c 89 f6             	mov    %r14,%rsi
  4091ea:	e8 11 f4 ff ff       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
    string name = section + "." + key;

    if (_m.find(name) != _m.end())
  4091ef:	49 39 c7             	cmp    %rax,%r15
  4091f2:	0f 84 a0 00 00 00    	je     409298 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x128>
      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
  4091f8:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  4091fc:	4c 89 f2             	mov    %r14,%rdx
  4091ff:	4c 89 fe             	mov    %r15,%rsi
  409202:	e8 99 fa ff ff       	callq  408ca0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  409207:	49 39 c7             	cmp    %rax,%r15
  40920a:	49 89 c5             	mov    %rax,%r13
  40920d:	0f 84 cd 00 00 00    	je     4092e0 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x170>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409213:	4c 8b 7c 24 20       	mov    0x20(%rsp),%r15
  409218:	48 8b 70 20          	mov    0x20(%rax),%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40921c:	49 8b 4f e8          	mov    -0x18(%r15),%rcx
  409220:	4c 8b 46 e8          	mov    -0x18(%rsi),%r8
  409224:	4c 89 ff             	mov    %r15,%rdi
  409227:	49 39 c8             	cmp    %rcx,%r8
  40922a:	48 89 ca             	mov    %rcx,%rdx
  40922d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  409232:	49 0f 46 d0          	cmovbe %r8,%rdx
  409236:	4c 89 04 24          	mov    %r8,(%rsp)
  40923a:	e8 b1 ad ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40923f:	85 c0                	test   %eax,%eax
  409241:	75 20                	jne    409263 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0xf3>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  409243:	4c 8b 04 24          	mov    (%rsp),%r8
  409247:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  40924c:	4c 29 c1             	sub    %r8,%rcx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  40924f:	48 81 f9 ff ff ff 7f 	cmp    $0x7fffffff,%rcx
  409256:	7f 0f                	jg     409267 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0xf7>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  409258:	48 81 f9 00 00 00 80 	cmp    $0xffffffff80000000,%rcx
  40925f:	7c 7f                	jl     4092e0 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x170>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  409261:	89 c8                	mov    %ecx,%eax
  409263:	85 c0                	test   %eax,%eax
  409265:	78 79                	js     4092e0 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x170>
    {
        return 0 == strcasecmp(_m[name].c_str(), "true");
  409267:	49 8b 7d 28          	mov    0x28(%r13),%rdi
  40926b:	48 8d 35 dc 71 00 00 	lea    0x71dc(%rip),%rsi        # 41044e <_ZStL19piecewise_construct+0x32>
  409272:	e8 99 a9 ff ff       	callq  403c10 <strcasecmp@plt>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409277:	49 8d 7f e8          	lea    -0x18(%r15),%rdi
  40927b:	85 c0                	test   %eax,%eax
  40927d:	0f 94 c0             	sete   %al

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409280:	48 39 df             	cmp    %rbx,%rdi
  409283:	75 24                	jne    4092a9 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x139>
    }

    return default_value;
}
  409285:	48 83 c4 48          	add    $0x48,%rsp
  409289:	5b                   	pop    %rbx
  40928a:	5d                   	pop    %rbp
  40928b:	41 5c                	pop    %r12
  40928d:	41 5d                	pop    %r13
  40928f:	41 5e                	pop    %r14
  409291:	41 5f                	pop    %r15
  409293:	c3                   	retq   
  409294:	0f 1f 40 00          	nopl   0x0(%rax)
  409298:	4c 8b 7c 24 20       	mov    0x20(%rsp),%r15
    if (_m.find(name) != _m.end())
    {
        return 0 == strcasecmp(_m[name].c_str(), "true");
    }

    return default_value;
  40929d:	44 89 e8             	mov    %r13d,%eax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4092a0:	49 8d 7f e8          	lea    -0x18(%r15),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4092a4:	48 39 df             	cmp    %rbx,%rdi
  4092a7:	74 dc                	je     409285 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x115>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4092a9:	48 83 3d c7 ac 20 00 	cmpq   $0x0,0x20acc7(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4092b0:	00 
  4092b1:	0f 84 e9 00 00 00    	je     4093a0 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x230>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4092b7:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4092bc:	f0 41 0f c1 57 f8    	lock xadd %edx,-0x8(%r15)
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4092c2:	85 d2                	test   %edx,%edx
  4092c4:	7f bf                	jg     409285 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x115>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4092c6:	4c 89 e6             	mov    %r12,%rsi
  4092c9:	88 04 24             	mov    %al,(%rsp)
  4092cc:	e8 9f aa ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4092d1:	0f b6 04 24          	movzbl (%rsp),%eax
  4092d5:	eb ae                	jmp    409285 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x115>
  4092d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4092de:	00 00 
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  4092e0:	bf 30 00 00 00       	mov    $0x30,%edi
  4092e5:	e8 96 ae ff ff       	callq  404180 <_Znwm@plt>
  4092ea:	49 89 c7             	mov    %rax,%r15
  4092ed:	48 8d 40 20          	lea    0x20(%rax),%rax
  4092f1:	4c 89 f6             	mov    %r14,%rsi
  4092f4:	48 89 c7             	mov    %rax,%rdi
  4092f7:	49 89 c6             	mov    %rax,%r14
  4092fa:	e8 c1 a9 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  4092ff:	48 8d 43 18          	lea    0x18(%rbx),%rax
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  409303:	4c 89 ee             	mov    %r13,%rsi
  409306:	4c 89 f2             	mov    %r14,%rdx
  409309:	48 89 ef             	mov    %rbp,%rdi
  40930c:	49 89 47 28          	mov    %rax,0x28(%r15)
  409310:	e8 2b f5 ff ff       	callq  408840 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_>

	    if (__res.second)
  409315:	48 85 d2             	test   %rdx,%rdx
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  409318:	49 89 c5             	mov    %rax,%r13

	    if (__res.second)
  40931b:	74 23                	je     409340 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x1d0>
	      return _M_insert_node(__res.first, __res.second, __z);
  40931d:	4c 89 f9             	mov    %r15,%rcx
  409320:	48 89 c6             	mov    %rax,%rsi
  409323:	48 89 ef             	mov    %rbp,%rdi
  409326:	e8 a5 19 00 00       	callq  40acd0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E>
  40932b:	49 89 c5             	mov    %rax,%r13
  40932e:	4c 8b 7c 24 20       	mov    0x20(%rsp),%r15
  409333:	e9 2f ff ff ff       	jmpq   409267 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0xf7>
  409338:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40933f:	00 
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409340:	49 8b 47 28          	mov    0x28(%r15),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409344:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409348:	48 39 df             	cmp    %rbx,%rdi
  40934b:	0f 85 93 00 00 00    	jne    4093e4 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x274>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409351:	49 8b 47 20          	mov    0x20(%r15),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409355:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409359:	48 39 df             	cmp    %rbx,%rdi
  40935c:	75 5f                	jne    4093bd <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x24d>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40935e:	4c 89 ff             	mov    %r15,%rdi
  409361:	e8 4a a8 ff ff       	callq  403bb0 <_ZdlPv@plt>
  409366:	eb c6                	jmp    40932e <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x1be>
  409368:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40936f:	00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409370:	48 83 3d 00 ac 20 00 	cmpq   $0x0,0x20ac00(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409377:	00 
  409378:	74 36                	je     4093b0 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x240>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40937a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40937f:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409384:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409386:	85 c0                	test   %eax,%eax
  409388:	0f 8f 4d fe ff ff    	jg     4091db <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x6b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40938e:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  409393:	e8 d8 a9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409398:	e9 3e fe ff ff       	jmpq   4091db <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x6b>
  40939d:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4093a0:	41 8b 57 f8          	mov    -0x8(%r15),%edx
    *__mem += __val;
  4093a4:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4093a7:	41 89 4f f8          	mov    %ecx,-0x8(%r15)
  4093ab:	e9 12 ff ff ff       	jmpq   4092c2 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x152>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  4093b0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  4093b3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  4093b6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  4093b9:	89 d0                	mov    %edx,%eax
  4093bb:	eb c9                	jmp    409386 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x216>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4093bd:	48 83 3d b3 ab 20 00 	cmpq   $0x0,0x20abb3(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4093c4:	00 
  4093c5:	74 48                	je     40940f <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x29f>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4093c7:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4093cc:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4093d1:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4093d3:	85 c0                	test   %eax,%eax
  4093d5:	7f 87                	jg     40935e <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x1ee>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4093d7:	4c 89 e6             	mov    %r12,%rsi
  4093da:	e8 91 a9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4093df:	e9 7a ff ff ff       	jmpq   40935e <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x1ee>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4093e4:	48 83 3d 8c ab 20 00 	cmpq   $0x0,0x20ab8c(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4093eb:	00 
  4093ec:	74 2e                	je     40941c <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x2ac>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  4093ee:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4093f3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4093f8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4093fa:	85 c0                	test   %eax,%eax
  4093fc:	0f 8f 4f ff ff ff    	jg     409351 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x1e1>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409402:	4c 89 e6             	mov    %r12,%rsi
  409405:	e8 66 a9 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40940a:	e9 42 ff ff ff       	jmpq   409351 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x1e1>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40940f:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409412:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409415:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409418:	89 d0                	mov    %edx,%eax
  40941a:	eb b7                	jmp    4093d3 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x263>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40941c:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40941f:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409422:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409425:	89 d0                	mov    %edx,%eax
  409427:	eb d1                	jmp    4093fa <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x28a>
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  409429:	48 89 c7             	mov    %rax,%rdi
  40942c:	e8 cf ac ff ff       	callq  404100 <__cxa_begin_catch@plt>
  409431:	4c 89 ff             	mov    %r15,%rdi
  409434:	e8 77 a7 ff ff       	callq  403bb0 <_ZdlPv@plt>
	    {
	      _M_put_node(__tmp);
	      __throw_exception_again;
  409439:	e8 e2 a7 ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40943e:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409441:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  409446:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40944a:	48 3b 3d 0f ab 20 00 	cmp    0x20ab0f(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  409451:	74 0a                	je     40945d <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x2ed>
  409453:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  409458:	e8 9b ae ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40945d:	48 89 df             	mov    %rbx,%rdi
  409460:	e8 3b ad ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  409465:	48 89 c5             	mov    %rax,%rbp
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  409468:	e8 13 ac ff ff       	callq  404080 <__cxa_end_catch@plt>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40946d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  409472:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409476:	48 39 df             	cmp    %rbx,%rdi
  409479:	74 08                	je     409483 <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x313>
  40947b:	4c 89 e6             	mov    %r12,%rsi
  40947e:	e8 75 ae ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  409483:	48 89 ef             	mov    %rbp,%rdi
  409486:	e8 15 ad ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40948b:	48 89 c5             	mov    %rax,%rbp
  40948e:	eb dd                	jmp    40946d <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x2fd>
  409490:	eb ac                	jmp    40943e <_ZN6rocket12ConfigReader7GetBoolERKSsS2_b+0x2ce>
  409492:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  409499:	1f 84 00 00 00 00 00 

00000000004094a0 <_ZN6rocket12ConfigReader4LoadERKSs>:

namespace rocket
{

bool ConfigReader::Load(const string& file)
{
  4094a0:	41 57                	push   %r15
  4094a2:	41 56                	push   %r14
  4094a4:	49 89 ff             	mov    %rdi,%r15
  4094a7:	41 55                	push   %r13
  4094a9:	41 54                	push   %r12
  4094ab:	55                   	push   %rbp
  4094ac:	53                   	push   %rbx
  4094ad:	48 81 ec b8 02 00 00 	sub    $0x2b8,%rsp
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4094b4:	4c 8b 26             	mov    (%rsi),%r12
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
  4094b7:	4c 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%r14
  4094be:	00 
  4094bf:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4094c6:	00 00 
  4094c8:	48 89 84 24 a8 02 00 	mov    %rax,0x2a8(%rsp)
  4094cf:	00 
  4094d0:	31 c0                	xor    %eax,%eax
  4094d2:	49 8d be 00 01 00 00 	lea    0x100(%r14),%rdi
  4094d9:	e8 42 a6 ff ff       	callq  403b20 <_ZNSt8ios_baseC2Ev@plt>
  4094de:	48 8b 05 cb a9 20 00 	mov    0x20a9cb(%rip),%rax        # 613eb0 <_DYNAMIC+0x228>
  4094e5:	c6 84 24 80 02 00 00 	movb   $0x0,0x280(%rsp)
  4094ec:	00 
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
  4094ed:	4c 89 f7             	mov    %r14,%rdi
  4094f0:	48 c7 84 24 78 02 00 	movq   $0x0,0x278(%rsp)
  4094f7:	00 00 00 00 00 
  4094fc:	c6 84 24 81 02 00 00 	movb   $0x0,0x281(%rsp)
  409503:	00 
  409504:	31 f6                	xor    %esi,%esi
  409506:	48 c7 84 24 88 02 00 	movq   $0x0,0x288(%rsp)
  40950d:	00 00 00 00 00 
  409512:	48 c7 84 24 90 02 00 	movq   $0x0,0x290(%rsp)
  409519:	00 00 00 00 00 
  40951e:	48 83 c0 10          	add    $0x10,%rax
  409522:	48 c7 84 24 98 02 00 	movq   $0x0,0x298(%rsp)
  409529:	00 00 00 00 00 
  40952e:	48 c7 84 24 a0 02 00 	movq   $0x0,0x2a0(%rsp)
  409535:	00 00 00 00 00 
  40953a:	48 89 84 24 a0 01 00 	mov    %rax,0x1a0(%rsp)
  409541:	00 
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
  409542:	48 8b 05 07 aa 20 00 	mov    0x20aa07(%rip),%rax        # 613f50 <_DYNAMIC+0x2c8>
  409549:	48 8b 58 08          	mov    0x8(%rax),%rbx
  40954d:	48 8b 68 10          	mov    0x10(%rax),%rbp
  409551:	48 8b 43 e8          	mov    -0x18(%rbx),%rax
  409555:	48 89 9c 24 a0 00 00 	mov    %rbx,0xa0(%rsp)
  40955c:	00 
  40955d:	48 89 ac 04 a0 00 00 	mov    %rbp,0xa0(%rsp,%rax,1)
  409564:	00 
  409565:	48 c7 84 24 a8 00 00 	movq   $0x0,0xa8(%rsp)
  40956c:	00 00 00 00 00 
      { this->init(0); }
  409571:	48 03 7b e8          	add    -0x18(%rbx),%rdi
  409575:	e8 86 a9 ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  Tip:  When using std::string to hold the filename, you must use
       *  .c_str() before passing it to this constructor.
       */
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
  40957a:	48 8b 05 87 a9 20 00 	mov    0x20a987(%rip),%rax        # 613f08 <_DYNAMIC+0x280>
  409581:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  409585:	48 83 c0 18          	add    $0x18,%rax
  409589:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
  409590:	00 
  409591:	48 8b 05 70 a9 20 00 	mov    0x20a970(%rip),%rax        # 613f08 <_DYNAMIC+0x280>
  409598:	48 83 c0 40          	add    $0x40,%rax
  40959c:	48 89 84 24 a0 01 00 	mov    %rax,0x1a0(%rsp)
  4095a3:	00 
  4095a4:	e8 97 aa ff ff       	callq  404040 <_ZNSt13basic_filebufIcSt11char_traitsIcEEC1Ev@plt>
      {
	this->init(&_M_filebuf);
  4095a9:	49 8d 76 10          	lea    0x10(%r14),%rsi
  4095ad:	49 8d be 00 01 00 00 	lea    0x100(%r14),%rdi
  4095b4:	e8 47 a9 ff ff       	callq  403f00 <_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E@plt>
       *  .c_str() before passing it to this constructor.
       */
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
	if (!_M_filebuf.open(__s, __mode | ios_base::in))
  4095b9:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  4095bd:	ba 08 00 00 00       	mov    $0x8,%edx
  4095c2:	4c 89 e6             	mov    %r12,%rsi
  4095c5:	e8 16 a7 ff ff       	callq  403ce0 <_ZNSt13basic_filebufIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode@plt>
  4095ca:	48 85 c0             	test   %rax,%rax
	  this->setstate(ios_base::failbit);
  4095cd:	4c 89 f7             	mov    %r14,%rdi
  4095d0:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
  4095d7:	00 
       *  .c_str() before passing it to this constructor.
       */
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
	if (!_M_filebuf.open(__s, __mode | ios_base::in))
  4095d8:	0f 84 fa 05 00 00    	je     409bd8 <_ZN6rocket12ConfigReader4LoadERKSs+0x738>
	  this->setstate(ios_base::failbit);
	else
	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
	  // 409. Closing an fstream should clear error state
	  this->clear();
  4095de:	48 03 78 e8          	add    -0x18(%rax),%rdi
  4095e2:	31 f6                	xor    %esi,%esi
  4095e4:	e8 17 aa ff ff       	callq  404000 <_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate@plt>
    ifstream ifs(file.c_str());
    if (!ifs.good())
  4095e9:	8b 84 24 c0 01 00 00 	mov    0x1c0(%rsp),%eax
  4095f0:	85 c0                	test   %eax,%eax
  4095f2:	0f 85 f0 04 00 00    	jne    409ae8 <_ZN6rocket12ConfigReader4LoadERKSs+0x648>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  4095f8:	4c 8b 2d 61 a9 20 00 	mov    0x20a961(%rip),%r13        # 613f60 <_DYNAMIC+0x2d8>
    {
        return false;
    }

    string line;
    string section = "";
  4095ff:	4c 8d a4 24 90 00 00 	lea    0x90(%rsp),%r12
  409606:	00 
  409607:	48 8d 35 16 6e 00 00 	lea    0x6e16(%rip),%rsi        # 410424 <_ZStL19piecewise_construct+0x8>
  40960e:	4c 89 e2             	mov    %r12,%rdx
  409611:	49 8d 45 18          	lea    0x18(%r13),%rax
  409615:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  40961a:	48 8d 44 24 50       	lea    0x50(%rsp),%rax
  40961f:	48 89 c7             	mov    %rax,%rdi
  409622:	48 89 04 24          	mov    %rax,(%rsp)
  409626:	e8 f5 a7 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40962b:	48 8d 84 24 80 00 00 	lea    0x80(%rsp),%rax
  409632:	00 
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }
  409633:	48 8d 6c 24 40       	lea    0x40(%rsp),%rbp
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409638:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }
  40963d:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
  409642:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  409647:	48 8d 44 24 70       	lea    0x70(%rsp),%rax
  40964c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  409651:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

    while (!ifs.eof())
  409658:	f6 84 24 c0 01 00 00 	testb  $0x2,0x1c0(%rsp)
  40965f:	02 
  409660:	0f 85 6a 03 00 00    	jne    4099d0 <_ZN6rocket12ConfigReader4LoadERKSs+0x530>
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }
  409666:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
  40966d:	00 
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40966e:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  409672:	48 8b 9c 04 90 01 00 	mov    0x190(%rsp,%rax,1),%rbx
  409679:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40967a:	48 85 db             	test   %rbx,%rbx
  40967d:	0f 84 36 06 00 00    	je     409cb9 <_ZN6rocket12ConfigReader4LoadERKSs+0x819>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  409683:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  409687:	0f 84 33 01 00 00    	je     4097c0 <_ZN6rocket12ConfigReader4LoadERKSs+0x320>
  40968d:	0f be 53 43          	movsbl 0x43(%rbx),%edx
  409691:	48 89 ee             	mov    %rbp,%rsi
  409694:	4c 89 f7             	mov    %r14,%rdi
  409697:	e8 d4 a3 ff ff       	callq  403a70 <_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RSbIS4_S5_T1_ES4_@plt>
    {
        getline(ifs, line);

        if (isSection(line, section))
  40969c:	48 89 ee             	mov    %rbp,%rsi
  40969f:	4c 89 e7             	mov    %r12,%rdi
  4096a2:	e8 19 a6 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  4096a7:	48 8b 14 24          	mov    (%rsp),%rdx
  4096ab:	4c 89 e6             	mov    %r12,%rsi
  4096ae:	4c 89 ff             	mov    %r15,%rdi
  4096b1:	e8 8a f8 ff ff       	callq  408f40 <_ZN6rocket12ConfigReader9isSectionESsRSs>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4096b6:	48 8b 94 24 90 00 00 	mov    0x90(%rsp),%rdx
  4096bd:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4096be:	48 8d 7a e8          	lea    -0x18(%rdx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4096c2:	4c 39 ef             	cmp    %r13,%rdi
  4096c5:	0f 85 2d 01 00 00    	jne    4097f8 <_ZN6rocket12ConfigReader4LoadERKSs+0x358>
  4096cb:	84 c0                	test   %al,%al
  4096cd:	75 89                	jne    409658 <_ZN6rocket12ConfigReader4LoadERKSs+0x1b8>
        {
            continue;
        }

        size_t equ_pos = line.find('=');
  4096cf:	31 d2                	xor    %edx,%edx
  4096d1:	be 3d 00 00 00       	mov    $0x3d,%esi
  4096d6:	48 89 ef             	mov    %rbp,%rdi
  4096d9:	e8 22 a7 ff ff       	callq  403e00 <_ZNKSs4findEcm@plt>
        if (equ_pos == string::npos) continue;
  4096de:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
        if (isSection(line, section))
        {
            continue;
        }

        size_t equ_pos = line.find('=');
  4096e2:	48 89 c3             	mov    %rax,%rbx
        if (equ_pos == string::npos) continue;
  4096e5:	0f 84 6d ff ff ff    	je     409658 <_ZN6rocket12ConfigReader4LoadERKSs+0x1b8>
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }
  4096eb:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4096f0:	48 89 c1             	mov    %rax,%rcx
  4096f3:	31 d2                	xor    %edx,%edx
  4096f5:	48 89 ee             	mov    %rbp,%rsi
  4096f8:	e8 93 aa ff ff       	callq  404190 <_ZNSsC1ERKSsmm@plt>
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  4096fd:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
        string key = line.substr(0, equ_pos);
        string value = line.substr(equ_pos + 1);
  409702:	48 8d 53 01          	lea    0x1(%rbx),%rdx
  409706:	48 8b 48 e8          	mov    -0x18(%rax),%rcx
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
  40970a:	48 39 ca             	cmp    %rcx,%rdx
  40970d:	0f 87 7d 06 00 00    	ja     409d90 <_ZN6rocket12ConfigReader4LoadERKSs+0x8f0>
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }
  409713:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
  409718:	48 c7 c1 ff ff ff ff 	mov    $0xffffffffffffffff,%rcx
  40971f:	48 89 ee             	mov    %rbp,%rsi
  409722:	48 89 df             	mov    %rbx,%rdi
  409725:	e8 66 aa ff ff       	callq  404190 <_ZNSsC1ERKSsmm@plt>
        key = trim(key);
  40972a:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  40972f:	4c 89 ff             	mov    %r15,%rdi
  409732:	e8 e9 f5 ff ff       	callq  408d20 <_ZN6rocket12ConfigReader4trimERSs>
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  409737:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  40973c:	48 89 c6             	mov    %rax,%rsi
  40973f:	e8 7c a8 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
        value = trim(value);
  409744:	48 89 de             	mov    %rbx,%rsi
  409747:	4c 89 ff             	mov    %r15,%rdi
  40974a:	e8 d1 f5 ff ff       	callq  408d20 <_ZN6rocket12ConfigReader4trimERSs>
  40974f:	48 89 c6             	mov    %rax,%rsi
  409752:	48 89 df             	mov    %rbx,%rdi
  409755:	e8 66 a8 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40975a:	48 8b 44 24 60       	mov    0x60(%rsp),%rax

        if (key.empty()) continue;
  40975f:	48 83 78 e8 00       	cmpq   $0x0,-0x18(%rax)
  409764:	0f 85 ce 00 00 00    	jne    409838 <_ZN6rocket12ConfigReader4LoadERKSs+0x398>
  40976a:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40976f:	48 8d 7a e8          	lea    -0x18(%rdx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409773:	4c 39 ef             	cmp    %r13,%rdi
  409776:	0f 85 74 03 00 00    	jne    409af0 <_ZN6rocket12ConfigReader4LoadERKSs+0x650>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40977c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409780:	4c 39 ef             	cmp    %r13,%rdi
  409783:	0f 84 cf fe ff ff    	je     409658 <_ZN6rocket12ConfigReader4LoadERKSs+0x1b8>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409789:	48 83 3d e7 a7 20 00 	cmpq   $0x0,0x20a7e7(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409790:	00 
  409791:	0f 84 86 03 00 00    	je     409b1d <_ZN6rocket12ConfigReader4LoadERKSs+0x67d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409797:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40979c:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  4097a1:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  4097a3:	85 c0                	test   %eax,%eax
  4097a5:	0f 8f ad fe ff ff    	jg     409658 <_ZN6rocket12ConfigReader4LoadERKSs+0x1b8>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  4097ab:	4c 89 e6             	mov    %r12,%rsi
  4097ae:	e8 bd a5 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  4097b3:	e9 a0 fe ff ff       	jmpq   409658 <_ZN6rocket12ConfigReader4LoadERKSs+0x1b8>
  4097b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4097bf:	00 
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  4097c0:	48 89 df             	mov    %rbx,%rdi
  4097c3:	e8 28 a4 ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  4097c8:	48 8b 03             	mov    (%rbx),%rax
  4097cb:	ba 0a 00 00 00       	mov    $0xa,%edx
  4097d0:	48 8b 40 30          	mov    0x30(%rax),%rax
  4097d4:	48 3b 05 b5 a7 20 00 	cmp    0x20a7b5(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  4097db:	0f 84 b0 fe ff ff    	je     409691 <_ZN6rocket12ConfigReader4LoadERKSs+0x1f1>
  4097e1:	be 0a 00 00 00       	mov    $0xa,%esi
  4097e6:	48 89 df             	mov    %rbx,%rdi
  4097e9:	ff d0                	callq  *%rax
  4097eb:	0f be d0             	movsbl %al,%edx
  4097ee:	e9 9e fe ff ff       	jmpq   409691 <_ZN6rocket12ConfigReader4LoadERKSs+0x1f1>
  4097f3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  4097f8:	48 83 3d 78 a7 20 00 	cmpq   $0x0,0x20a778(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  4097ff:	00 
  409800:	0f 84 42 01 00 00    	je     409948 <_ZN6rocket12ConfigReader4LoadERKSs+0x4a8>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409806:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  40980b:	f0 0f c1 4a f8       	lock xadd %ecx,-0x8(%rdx)
  409810:	89 ca                	mov    %ecx,%edx
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409812:	85 d2                	test   %edx,%edx
  409814:	0f 8f b1 fe ff ff    	jg     4096cb <_ZN6rocket12ConfigReader4LoadERKSs+0x22b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40981a:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  40981f:	88 44 24 18          	mov    %al,0x18(%rsp)
  409823:	e8 48 a5 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409828:	0f b6 44 24 18       	movzbl 0x18(%rsp),%eax
  40982d:	e9 99 fe ff ff       	jmpq   4096cb <_ZN6rocket12ConfigReader4LoadERKSs+0x22b>
  409832:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  409838:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
  40983d:	48 8b 34 24          	mov    (%rsp),%rsi
  409841:	48 89 df             	mov    %rbx,%rdi
  409844:	e8 77 a4 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  409849:	48 8d 35 64 6b 00 00 	lea    0x6b64(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  409850:	ba 01 00 00 00       	mov    $0x1,%edx
  409855:	48 89 df             	mov    %rbx,%rdi
  409858:	e8 f3 a1 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  40985d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  409862:	48 89 df             	mov    %rbx,%rdi
  409865:	e8 d6 a9 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40986a:	48 8b 10             	mov    (%rax),%rdx
	  (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
  40986d:	49 8d 4f 08          	lea    0x8(%r15),%rcx
      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
  409871:	48 89 ce             	mov    %rcx,%rsi
  409874:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  409879:	48 89 94 24 90 00 00 	mov    %rdx,0x90(%rsp)
  409880:	00 
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  409881:	49 8d 55 18          	lea    0x18(%r13),%rdx
  409885:	48 89 10             	mov    %rdx,(%rax)
  409888:	49 8b 7f 10          	mov    0x10(%r15),%rdi
  40988c:	4c 89 e2             	mov    %r12,%rdx
  40988f:	e8 0c f4 ff ff       	callq  408ca0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  409894:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  409899:	48 89 c3             	mov    %rax,%rbx
  40989c:	48 39 c1             	cmp    %rax,%rcx
  40989f:	0f 84 ca 00 00 00    	je     40996f <_ZN6rocket12ConfigReader4LoadERKSs+0x4cf>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4098a5:	48 8b bc 24 90 00 00 	mov    0x90(%rsp),%rdi
  4098ac:	00 
  4098ad:	48 8b 70 20          	mov    0x20(%rax),%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  4098b1:	48 8b 4f e8          	mov    -0x18(%rdi),%rcx
  4098b5:	4c 8b 46 e8          	mov    -0x18(%rsi),%r8
  4098b9:	48 89 ca             	mov    %rcx,%rdx
  4098bc:	49 39 c8             	cmp    %rcx,%r8
  4098bf:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  4098c4:	49 0f 46 d0          	cmovbe %r8,%rdx
  4098c8:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  4098cd:	e8 1e a7 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  4098d2:	85 c0                	test   %eax,%eax
  4098d4:	0f 85 91 00 00 00    	jne    40996b <_ZN6rocket12ConfigReader4LoadERKSs+0x4cb>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  4098da:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
  4098df:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
  4098e4:	4c 29 c1             	sub    %r8,%rcx

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  4098e7:	48 81 f9 ff ff ff 7f 	cmp    $0x7fffffff,%rcx
  4098ee:	7e 70                	jle    409960 <_ZN6rocket12ConfigReader4LoadERKSs+0x4c0>
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  4098f0:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
					std::forward_as_tuple(std::move(__k)),
					std::tuple<>());
	return (*__i).second;
  4098f5:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
  4098f9:	e8 c2 a6 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4098fe:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  409905:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409906:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40990a:	4c 39 ef             	cmp    %r13,%rdi
  40990d:	0f 85 36 02 00 00    	jne    409b49 <_ZN6rocket12ConfigReader4LoadERKSs+0x6a9>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409913:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  40991a:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40991b:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40991f:	4c 39 ef             	cmp    %r13,%rdi
  409922:	0f 85 52 02 00 00    	jne    409b7a <_ZN6rocket12ConfigReader4LoadERKSs+0x6da>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409928:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40992d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409931:	4c 39 ef             	cmp    %r13,%rdi
  409934:	0f 85 f3 01 00 00    	jne    409b2d <_ZN6rocket12ConfigReader4LoadERKSs+0x68d>
  40993a:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  40993f:	e9 38 fe ff ff       	jmpq   40977c <_ZN6rocket12ConfigReader4LoadERKSs+0x2dc>
  409944:	0f 1f 40 00          	nopl   0x0(%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409948:	8b 4a f8             	mov    -0x8(%rdx),%ecx
    *__mem += __val;
  40994b:	8d 71 ff             	lea    -0x1(%rcx),%esi
  40994e:	89 72 f8             	mov    %esi,-0x8(%rdx)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409951:	89 ca                	mov    %ecx,%edx
  409953:	e9 ba fe ff ff       	jmpq   409812 <_ZN6rocket12ConfigReader4LoadERKSs+0x372>
  409958:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40995f:	00 
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  409960:	48 81 f9 00 00 00 80 	cmp    $0xffffffff80000000,%rcx
  409967:	7c 06                	jl     40996f <_ZN6rocket12ConfigReader4LoadERKSs+0x4cf>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  409969:	89 c8                	mov    %ecx,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40996b:	85 c0                	test   %eax,%eax
  40996d:	79 81                	jns    4098f0 <_ZN6rocket12ConfigReader4LoadERKSs+0x450>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40996f:	bf 30 00 00 00       	mov    $0x30,%edi
  409974:	e8 07 a8 ff ff       	callq  404180 <_Znwm@plt>
  409979:	48 89 c1             	mov    %rax,%rcx
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40997c:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  409983:	00 
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  409984:	48 89 de             	mov    %rbx,%rsi
  409987:	48 8d 51 20          	lea    0x20(%rcx),%rdx
  40998b:	4c 89 ff             	mov    %r15,%rdi
  40998e:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  409993:	48 89 41 20          	mov    %rax,0x20(%rcx)
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  409997:	49 8d 45 18          	lea    0x18(%r13),%rax
  40999b:	48 89 84 24 90 00 00 	mov    %rax,0x90(%rsp)
  4099a2:	00 

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  4099a3:	48 89 41 28          	mov    %rax,0x28(%rcx)
  4099a7:	e8 94 ee ff ff       	callq  408840 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_>

	    if (__res.second)
  4099ac:	48 85 d2             	test   %rdx,%rdx
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  4099af:	48 89 c3             	mov    %rax,%rbx

	    if (__res.second)
  4099b2:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  4099b7:	0f 84 ec 01 00 00    	je     409ba9 <_ZN6rocket12ConfigReader4LoadERKSs+0x709>
	      return _M_insert_node(__res.first, __res.second, __z);
  4099bd:	48 89 c6             	mov    %rax,%rsi
  4099c0:	4c 89 ff             	mov    %r15,%rdi
  4099c3:	e8 08 13 00 00       	callq  40acd0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E>
  4099c8:	48 89 c3             	mov    %rax,%rbx
  4099cb:	e9 20 ff ff ff       	jmpq   4098f0 <_ZN6rocket12ConfigReader4LoadERKSs+0x450>
       *  fails, @c failbit is set in the stream's error state.
       */
      void
      close()
      {
	if (!_M_filebuf.close())
  4099d0:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  4099d4:	e8 97 a8 ff ff       	callq  404270 <_ZNSt13basic_filebufIcSt11char_traitsIcEE5closeEv@plt>
  4099d9:	48 85 c0             	test   %rax,%rax
  4099dc:	0f 84 43 02 00 00    	je     409c25 <_ZN6rocket12ConfigReader4LoadERKSs+0x785>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4099e2:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4099e7:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4099eb:	4c 39 ef             	cmp    %r13,%rdi
  4099ee:	0f 85 50 02 00 00    	jne    409c44 <_ZN6rocket12ConfigReader4LoadERKSs+0x7a4>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  4099f4:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  4099f9:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  4099fd:	4c 39 ef             	cmp    %r13,%rdi
  409a00:	0f 85 f4 01 00 00    	jne    409bfa <_ZN6rocket12ConfigReader4LoadERKSs+0x75a>
  409a06:	48 8b 05 43 a5 20 00 	mov    0x20a543(%rip),%rax        # 613f50 <_DYNAMIC+0x2c8>
        _m[section + "." + key] = value;
    }

    ifs.close();

    return true;
  409a0d:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  409a13:	48 8b 58 08          	mov    0x8(%rax),%rbx
  409a17:	48 8b 68 10          	mov    0x10(%rax),%rbp
       *
       *  The file is closed by the filebuf object, not the formatting
       *  stream.
       */
      ~basic_ifstream()
      { }
  409a1b:	48 8b 05 e6 a4 20 00 	mov    0x20a4e6(%rip),%rax        # 613f08 <_DYNAMIC+0x280>
      /**
       *  @brief  The destructor closes the file first.
       */
      virtual
      ~basic_filebuf()
      { this->close(); }
  409a22:	49 8d 7e 10          	lea    0x10(%r14),%rdi
       *
       *  The file is closed by the filebuf object, not the formatting
       *  stream.
       */
      ~basic_ifstream()
      { }
  409a26:	48 83 c0 18          	add    $0x18,%rax
  409a2a:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
  409a31:	00 
  409a32:	48 8b 05 cf a4 20 00 	mov    0x20a4cf(%rip),%rax        # 613f08 <_DYNAMIC+0x280>
  409a39:	48 83 c0 40          	add    $0x40,%rax
  409a3d:	48 89 84 24 a0 01 00 	mov    %rax,0x1a0(%rsp)
  409a44:	00 
      /**
       *  @brief  The destructor closes the file first.
       */
      virtual
      ~basic_filebuf()
      { this->close(); }
  409a45:	48 8b 05 8c a4 20 00 	mov    0x20a48c(%rip),%rax        # 613ed8 <_DYNAMIC+0x250>
  409a4c:	48 83 c0 10          	add    $0x10,%rax
  409a50:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
  409a57:	00 
  409a58:	e8 13 a8 ff ff       	callq  404270 <_ZNSt13basic_filebufIcSt11char_traitsIcEE5closeEv@plt>
  409a5d:	49 8d 7e 78          	lea    0x78(%r14),%rdi
  409a61:	e8 0a a5 ff ff       	callq  403f70 <_ZNSt12__basic_fileIcED1Ev@plt>
  409a66:	48 8b 05 eb a4 20 00 	mov    0x20a4eb(%rip),%rax        # 613f58 <_DYNAMIC+0x2d0>
  409a6d:	49 8d 7e 48          	lea    0x48(%r14),%rdi
  409a71:	48 83 c0 10          	add    $0x10,%rax
  409a75:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
  409a7c:	00 
  409a7d:	e8 2e a7 ff ff       	callq  4041b0 <_ZNSt6localeD1Ev@plt>
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
  409a82:	48 8b 43 e8          	mov    -0x18(%rbx),%rax
  409a86:	48 89 9c 24 a0 00 00 	mov    %rbx,0xa0(%rsp)
  409a8d:	00 
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  409a8e:	49 8d be 00 01 00 00 	lea    0x100(%r14),%rdi
  409a95:	48 89 ac 04 a0 00 00 	mov    %rbp,0xa0(%rsp,%rax,1)
  409a9c:	00 
  409a9d:	48 8b 05 0c a4 20 00 	mov    0x20a40c(%rip),%rax        # 613eb0 <_DYNAMIC+0x228>
  409aa4:	48 83 c0 10          	add    $0x10,%rax
  409aa8:	48 89 84 24 a0 01 00 	mov    %rax,0x1a0(%rsp)
  409aaf:	00 
  409ab0:	e8 ab a4 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
}
  409ab5:	48 8b 8c 24 a8 02 00 	mov    0x2a8(%rsp),%rcx
  409abc:	00 
  409abd:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  409ac4:	00 00 
  409ac6:	44 89 e0             	mov    %r12d,%eax
  409ac9:	0f 85 8f 03 00 00    	jne    409e5e <_ZN6rocket12ConfigReader4LoadERKSs+0x9be>
  409acf:	48 81 c4 b8 02 00 00 	add    $0x2b8,%rsp
  409ad6:	5b                   	pop    %rbx
  409ad7:	5d                   	pop    %rbp
  409ad8:	41 5c                	pop    %r12
  409ada:	41 5d                	pop    %r13
  409adc:	41 5e                	pop    %r14
  409ade:	41 5f                	pop    %r15
  409ae0:	c3                   	retq   
  409ae1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
bool ConfigReader::Load(const string& file)
{
    ifstream ifs(file.c_str());
    if (!ifs.good())
    {
        return false;
  409ae8:	45 31 e4             	xor    %r12d,%r12d
  409aeb:	e9 2b ff ff ff       	jmpq   409a1b <_ZN6rocket12ConfigReader4LoadERKSs+0x57b>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409af0:	48 83 3d 80 a4 20 00 	cmpq   $0x0,0x20a480(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409af7:	00 
  409af8:	0f 84 ee 00 00 00    	je     409bec <_ZN6rocket12ConfigReader4LoadERKSs+0x74c>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409afe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  409b03:	f0 0f c1 42 f8       	lock xadd %eax,-0x8(%rdx)
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409b08:	85 c0                	test   %eax,%eax
  409b0a:	0f 8f 2a fe ff ff    	jg     40993a <_ZN6rocket12ConfigReader4LoadERKSs+0x49a>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409b10:	4c 89 e6             	mov    %r12,%rsi
  409b13:	e8 58 a2 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409b18:	e9 1d fe ff ff       	jmpq   40993a <_ZN6rocket12ConfigReader4LoadERKSs+0x49a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409b1d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409b20:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409b23:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409b26:	89 d0                	mov    %edx,%eax
  409b28:	e9 76 fc ff ff       	jmpq   4097a3 <_ZN6rocket12ConfigReader4LoadERKSs+0x303>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409b2d:	48 83 3d 43 a4 20 00 	cmpq   $0x0,0x20a443(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409b34:	00 
  409b35:	0f 84 6e 01 00 00    	je     409ca9 <_ZN6rocket12ConfigReader4LoadERKSs+0x809>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409b3b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  409b40:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409b45:	89 d0                	mov    %edx,%eax
  409b47:	eb bf                	jmp    409b08 <_ZN6rocket12ConfigReader4LoadERKSs+0x668>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409b49:	48 83 3d 27 a4 20 00 	cmpq   $0x0,0x20a427(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409b50:	00 
  409b51:	0f 84 32 01 00 00    	je     409c89 <_ZN6rocket12ConfigReader4LoadERKSs+0x7e9>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409b57:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  409b5c:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409b61:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409b63:	85 c0                	test   %eax,%eax
  409b65:	0f 8f a8 fd ff ff    	jg     409913 <_ZN6rocket12ConfigReader4LoadERKSs+0x473>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409b6b:	48 8d 74 24 3f       	lea    0x3f(%rsp),%rsi
  409b70:	e8 fb a1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409b75:	e9 99 fd ff ff       	jmpq   409913 <_ZN6rocket12ConfigReader4LoadERKSs+0x473>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409b7a:	48 83 3d f6 a3 20 00 	cmpq   $0x0,0x20a3f6(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409b81:	00 
  409b82:	0f 84 11 01 00 00    	je     409c99 <_ZN6rocket12ConfigReader4LoadERKSs+0x7f9>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409b88:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  409b8d:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409b92:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409b94:	85 c0                	test   %eax,%eax
  409b96:	0f 8f 8c fd ff ff    	jg     409928 <_ZN6rocket12ConfigReader4LoadERKSs+0x488>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409b9c:	4c 89 e6             	mov    %r12,%rsi
  409b9f:	e8 cc a1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409ba4:	e9 7f fd ff ff       	jmpq   409928 <_ZN6rocket12ConfigReader4LoadERKSs+0x488>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409ba9:	48 8b 41 28          	mov    0x28(%rcx),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409bad:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409bb1:	4c 39 ef             	cmp    %r13,%rdi
  409bb4:	0f 85 85 01 00 00    	jne    409d3f <_ZN6rocket12ConfigReader4LoadERKSs+0x89f>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409bba:	48 8b 41 20          	mov    0x20(%rcx),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409bbe:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409bc2:	4c 39 ef             	cmp    %r13,%rdi
  409bc5:	0f 85 3d 01 00 00    	jne    409d08 <_ZN6rocket12ConfigReader4LoadERKSs+0x868>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  409bcb:	48 89 cf             	mov    %rcx,%rdi
  409bce:	e8 dd 9f ff ff       	callq  403bb0 <_ZdlPv@plt>
  409bd3:	e9 18 fd ff ff       	jmpq   4098f0 <_ZN6rocket12ConfigReader4LoadERKSs+0x450>
       */
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
	if (!_M_filebuf.open(__s, __mode | ios_base::in))
	  this->setstate(ios_base::failbit);
  409bd8:	48 03 78 e8          	add    -0x18(%rax),%rdi
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }
  409bdc:	8b 77 20             	mov    0x20(%rdi),%esi
  409bdf:	83 ce 04             	or     $0x4,%esi
       *
       *  See std::ios_base::iostate for the possible bit values.
      */
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }
  409be2:	e8 19 a4 ff ff       	callq  404000 <_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate@plt>
  409be7:	e9 fd f9 ff ff       	jmpq   4095e9 <_ZN6rocket12ConfigReader4LoadERKSs+0x149>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409bec:	8b 42 f8             	mov    -0x8(%rdx),%eax
    *__mem += __val;
  409bef:	8d 48 ff             	lea    -0x1(%rax),%ecx
  409bf2:	89 4a f8             	mov    %ecx,-0x8(%rdx)
  409bf5:	e9 0e ff ff ff       	jmpq   409b08 <_ZN6rocket12ConfigReader4LoadERKSs+0x668>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409bfa:	48 83 3d 76 a3 20 00 	cmpq   $0x0,0x20a376(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409c01:	00 
  409c02:	74 6b                	je     409c6f <_ZN6rocket12ConfigReader4LoadERKSs+0x7cf>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409c04:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  409c09:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409c0e:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409c10:	85 c0                	test   %eax,%eax
  409c12:	0f 8f ee fd ff ff    	jg     409a06 <_ZN6rocket12ConfigReader4LoadERKSs+0x566>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409c18:	4c 89 e6             	mov    %r12,%rsi
  409c1b:	e8 50 a1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409c20:	e9 e1 fd ff ff       	jmpq   409a06 <_ZN6rocket12ConfigReader4LoadERKSs+0x566>
       */
      void
      close()
      {
	if (!_M_filebuf.close())
	  this->setstate(ios_base::failbit);
  409c25:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
  409c2c:	00 
  409c2d:	4c 89 f7             	mov    %r14,%rdi
  409c30:	48 03 78 e8          	add    -0x18(%rax),%rdi
  409c34:	8b 77 20             	mov    0x20(%rdi),%esi
  409c37:	83 ce 04             	or     $0x4,%esi
  409c3a:	e8 c1 a3 ff ff       	callq  404000 <_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate@plt>
  409c3f:	e9 9e fd ff ff       	jmpq   4099e2 <_ZN6rocket12ConfigReader4LoadERKSs+0x542>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409c44:	48 83 3d 2c a3 20 00 	cmpq   $0x0,0x20a32c(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409c4b:	00 
  409c4c:	74 2e                	je     409c7c <_ZN6rocket12ConfigReader4LoadERKSs+0x7dc>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409c4e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  409c53:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409c58:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409c5a:	85 c0                	test   %eax,%eax
  409c5c:	0f 8f 92 fd ff ff    	jg     4099f4 <_ZN6rocket12ConfigReader4LoadERKSs+0x554>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409c62:	4c 89 e6             	mov    %r12,%rsi
  409c65:	e8 06 a1 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409c6a:	e9 85 fd ff ff       	jmpq   4099f4 <_ZN6rocket12ConfigReader4LoadERKSs+0x554>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409c6f:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409c72:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409c75:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409c78:	89 d0                	mov    %edx,%eax
  409c7a:	eb 94                	jmp    409c10 <_ZN6rocket12ConfigReader4LoadERKSs+0x770>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409c7c:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409c7f:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409c82:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409c85:	89 d0                	mov    %edx,%eax
  409c87:	eb d1                	jmp    409c5a <_ZN6rocket12ConfigReader4LoadERKSs+0x7ba>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409c89:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409c8c:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409c8f:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409c92:	89 d0                	mov    %edx,%eax
  409c94:	e9 ca fe ff ff       	jmpq   409b63 <_ZN6rocket12ConfigReader4LoadERKSs+0x6c3>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409c99:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409c9c:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409c9f:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409ca2:	89 d0                	mov    %edx,%eax
  409ca4:	e9 eb fe ff ff       	jmpq   409b94 <_ZN6rocket12ConfigReader4LoadERKSs+0x6f4>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409ca9:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409cac:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  409caf:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409cb2:	89 d0                	mov    %edx,%eax
  409cb4:	e9 4f fe ff ff       	jmpq   409b08 <_ZN6rocket12ConfigReader4LoadERKSs+0x668>
  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
	__throw_bad_cast();
  409cb9:	e8 22 9e ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
  409cbe:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409cc1:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  409cc6:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409cca:	4c 39 ef             	cmp    %r13,%rdi
  409ccd:	74 0a                	je     409cd9 <_ZN6rocket12ConfigReader4LoadERKSs+0x839>
  409ccf:	48 8d 74 24 70       	lea    0x70(%rsp),%rsi
  409cd4:	e8 1f a6 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409cd9:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  409cde:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409ce2:	4c 39 ef             	cmp    %r13,%rdi
  409ce5:	74 0a                	je     409cf1 <_ZN6rocket12ConfigReader4LoadERKSs+0x851>
  409ce7:	48 8d 74 24 70       	lea    0x70(%rsp),%rsi
  409cec:	e8 07 a6 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
        _m[section + "." + key] = value;
    }

    ifs.close();

    return true;
  409cf1:	4c 89 f7             	mov    %r14,%rdi
  409cf4:	e8 67 a1 ff ff       	callq  403e60 <_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev@plt>
  409cf9:	48 89 df             	mov    %rbx,%rdi
  409cfc:	e8 9f a4 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  409d01:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409d08:	48 83 3d 68 a2 20 00 	cmpq   $0x0,0x20a268(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409d0f:	00 
  409d10:	74 64                	je     409d76 <_ZN6rocket12ConfigReader4LoadERKSs+0x8d6>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409d12:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  409d17:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409d1c:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409d1e:	85 c0                	test   %eax,%eax
  409d20:	0f 8f a5 fe ff ff    	jg     409bcb <_ZN6rocket12ConfigReader4LoadERKSs+0x72b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409d26:	48 8d 74 24 3f       	lea    0x3f(%rsp),%rsi
  409d2b:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  409d30:	e8 3b a0 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409d35:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  409d3a:	e9 8c fe ff ff       	jmpq   409bcb <_ZN6rocket12ConfigReader4LoadERKSs+0x72b>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409d3f:	48 83 3d 31 a2 20 00 	cmpq   $0x0,0x20a231(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  409d46:	00 
  409d47:	74 3a                	je     409d83 <_ZN6rocket12ConfigReader4LoadERKSs+0x8e3>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  409d49:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  409d4e:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  409d53:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  409d55:	85 c0                	test   %eax,%eax
  409d57:	0f 8f 5d fe ff ff    	jg     409bba <_ZN6rocket12ConfigReader4LoadERKSs+0x71a>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  409d5d:	48 8d 74 24 3f       	lea    0x3f(%rsp),%rsi
  409d62:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  409d67:	e8 04 a0 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  409d6c:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  409d71:	e9 44 fe ff ff       	jmpq   409bba <_ZN6rocket12ConfigReader4LoadERKSs+0x71a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409d76:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409d79:	8d 72 ff             	lea    -0x1(%rdx),%esi
  409d7c:	89 70 f8             	mov    %esi,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409d7f:	89 d0                	mov    %edx,%eax
  409d81:	eb 9b                	jmp    409d1e <_ZN6rocket12ConfigReader4LoadERKSs+0x87e>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  409d83:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  409d86:	8d 72 ff             	lea    -0x1(%rdx),%esi
  409d89:	89 70 f8             	mov    %esi,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  409d8c:	89 d0                	mov    %edx,%eax
  409d8e:	eb c5                	jmp    409d55 <_ZN6rocket12ConfigReader4LoadERKSs+0x8b5>

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
  409d90:	48 8d 35 a2 66 00 00 	lea    0x66a2(%rip),%rsi        # 410439 <_ZStL19piecewise_construct+0x1d>
  409d97:	48 8d 3d d2 66 00 00 	lea    0x66d2(%rip),%rdi        # 410470 <_ZStL19piecewise_construct+0x54>
  409d9e:	31 c0                	xor    %eax,%eax
  409da0:	e8 4b 9d ff ff       	callq  403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>
  409da5:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409da8:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  409dad:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409db1:	4c 39 ef             	cmp    %r13,%rdi
  409db4:	0f 84 07 ff ff ff    	je     409cc1 <_ZN6rocket12ConfigReader4LoadERKSs+0x821>
  409dba:	4c 89 e6             	mov    %r12,%rsi
  409dbd:	e8 36 a5 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  409dc2:	e9 fa fe ff ff       	jmpq   409cc1 <_ZN6rocket12ConfigReader4LoadERKSs+0x821>
  409dc7:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409dca:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  409dd1:	00 
  409dd2:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409dd6:	4c 39 ef             	cmp    %r13,%rdi
  409dd9:	0f 84 e2 fe ff ff    	je     409cc1 <_ZN6rocket12ConfigReader4LoadERKSs+0x821>
  409ddf:	48 8d b4 24 80 00 00 	lea    0x80(%rsp),%rsi
  409de6:	00 
  409de7:	e8 0c a5 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  409dec:	e9 d0 fe ff ff       	jmpq   409cc1 <_ZN6rocket12ConfigReader4LoadERKSs+0x821>
  409df1:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409df4:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  409df9:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409dfd:	4c 39 ef             	cmp    %r13,%rdi
  409e00:	74 a6                	je     409da8 <_ZN6rocket12ConfigReader4LoadERKSs+0x908>
  409e02:	4c 89 e6             	mov    %r12,%rsi
  409e05:	e8 ee a4 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  409e0a:	eb 9c                	jmp    409da8 <_ZN6rocket12ConfigReader4LoadERKSs+0x908>
  409e0c:	48 89 c3             	mov    %rax,%rbx
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
  409e0f:	48 8b 05 9a a0 20 00 	mov    0x20a09a(%rip),%rax        # 613eb0 <_DYNAMIC+0x228>
  409e16:	49 8d be 00 01 00 00 	lea    0x100(%r14),%rdi
  409e1d:	48 83 c0 10          	add    $0x10,%rax
  409e21:	48 89 84 24 a0 01 00 	mov    %rax,0x1a0(%rsp)
  409e28:	00 
  409e29:	e8 32 a1 ff ff       	callq  403f60 <_ZNSt8ios_baseD2Ev@plt>
  409e2e:	48 89 df             	mov    %rbx,%rdi
  409e31:	e8 6a a3 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
       *  Tip:  When using std::string to hold the filename, you must use
       *  .c_str() before passing it to this constructor.
       */
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
  409e36:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  409e3a:	49 89 c4             	mov    %rax,%r12
  409e3d:	e8 5e a2 ff ff       	callq  4040a0 <_ZNSt13basic_filebufIcSt11char_traitsIcEED1Ev@plt>
  409e42:	4c 89 e0             	mov    %r12,%rax
  409e45:	48 8b 53 e8          	mov    -0x18(%rbx),%rdx
  409e49:	48 89 9c 24 a0 00 00 	mov    %rbx,0xa0(%rsp)
  409e50:	00 
  409e51:	48 89 c3             	mov    %rax,%rbx
  409e54:	48 89 ac 14 a0 00 00 	mov    %rbp,0xa0(%rsp,%rdx,1)
  409e5b:	00 
  409e5c:	eb b1                	jmp    409e0f <_ZN6rocket12ConfigReader4LoadERKSs+0x96f>
}
  409e5e:	e8 ed a0 ff ff       	callq  403f50 <__stack_chk_fail@plt>
  409e63:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409e66:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  409e6d:	00 
  409e6e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409e72:	4c 39 ef             	cmp    %r13,%rdi
  409e75:	0f 84 79 ff ff ff    	je     409df4 <_ZN6rocket12ConfigReader4LoadERKSs+0x954>
  409e7b:	4c 89 e6             	mov    %r12,%rsi
  409e7e:	e8 75 a4 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  409e83:	e9 6c ff ff ff       	jmpq   409df4 <_ZN6rocket12ConfigReader4LoadERKSs+0x954>
  409e88:	eb d9                	jmp    409e63 <_ZN6rocket12ConfigReader4LoadERKSs+0x9c3>
  409e8a:	48 89 c3             	mov    %rax,%rbx
  409e8d:	e9 47 fe ff ff       	jmpq   409cd9 <_ZN6rocket12ConfigReader4LoadERKSs+0x839>
  409e92:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409e95:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  409e9c:	00 
  409e9d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409ea1:	4c 39 ef             	cmp    %r13,%rdi
  409ea4:	74 c0                	je     409e66 <_ZN6rocket12ConfigReader4LoadERKSs+0x9c6>
  409ea6:	48 8d 74 24 3f       	lea    0x3f(%rsp),%rsi
  409eab:	e8 48 a4 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  409eb0:	eb b4                	jmp    409e66 <_ZN6rocket12ConfigReader4LoadERKSs+0x9c6>
  409eb2:	eb 91                	jmp    409e45 <_ZN6rocket12ConfigReader4LoadERKSs+0x9a5>
  409eb4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  409ebb:	00 00 00 00 00 

0000000000409ec0 <_ZN6rocket12ConfigReaderixERKSs>:

    return default_value;
}

string& ConfigReader::operator[](const string& name)
{
  409ec0:	41 56                	push   %r14
  409ec2:	41 55                	push   %r13
  409ec4:	49 89 f5             	mov    %rsi,%r13
  409ec7:	41 54                	push   %r12
  409ec9:	55                   	push   %rbp
			      (this->_M_impl._M_header._M_left));
      }

      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
  409eca:	4c 8d 67 08          	lea    0x8(%rdi),%r12
  409ece:	53                   	push   %rbx
  409ecf:	48 89 fd             	mov    %rdi,%rbp
  409ed2:	48 83 ec 10          	sub    $0x10,%rsp
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  409ed6:	e8 25 e7 ff ff       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
    if (_m.find(name) == _m.end())
  409edb:	49 39 c4             	cmp    %rax,%r12
  409ede:	0f 84 c4 00 00 00    	je     409fa8 <_ZN6rocket12ConfigReaderixERKSs+0xe8>
      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
  409ee4:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  409ee8:	4c 89 ea             	mov    %r13,%rdx
  409eeb:	4c 89 e6             	mov    %r12,%rsi
  409eee:	e8 ad ed ff ff       	callq  408ca0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  409ef3:	49 39 c4             	cmp    %rax,%r12
  409ef6:	48 89 c3             	mov    %rax,%rbx
  409ef9:	74 55                	je     409f50 <_ZN6rocket12ConfigReaderixERKSs+0x90>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409efb:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  409eff:	48 8b 70 20          	mov    0x20(%rax),%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  409f03:	4c 8b 67 e8          	mov    -0x18(%rdi),%r12
  409f07:	4c 8b 76 e8          	mov    -0x18(%rsi),%r14
  409f0b:	4c 89 e2             	mov    %r12,%rdx
  409f0e:	4d 39 e6             	cmp    %r12,%r14
  409f11:	49 0f 46 d6          	cmovbe %r14,%rdx
  409f15:	e8 d6 a0 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  409f1a:	85 c0                	test   %eax,%eax
  409f1c:	75 2e                	jne    409f4c <_ZN6rocket12ConfigReaderixERKSs+0x8c>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  409f1e:	4d 29 f4             	sub    %r14,%r12

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  409f21:	49 81 fc ff ff ff 7f 	cmp    $0x7fffffff,%r12
  409f28:	7e 16                	jle    409f40 <_ZN6rocket12ConfigReaderixERKSs+0x80>
    {
        fprintf(stderr, "config[%s] error\n", name.c_str());
    }

    return _m[name];
}
  409f2a:	48 83 c4 10          	add    $0x10,%rsp
					    std::tuple<const key_type&>(__k),
					    std::tuple<>());
#else
          __i = insert(__i, value_type(__k, mapped_type()));
#endif
	return (*__i).second;
  409f2e:	48 8d 43 28          	lea    0x28(%rbx),%rax
  409f32:	5b                   	pop    %rbx
  409f33:	5d                   	pop    %rbp
  409f34:	41 5c                	pop    %r12
  409f36:	41 5d                	pop    %r13
  409f38:	41 5e                	pop    %r14
  409f3a:	c3                   	retq   
  409f3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  409f40:	49 81 fc 00 00 00 80 	cmp    $0xffffffff80000000,%r12
  409f47:	7c 07                	jl     409f50 <_ZN6rocket12ConfigReaderixERKSs+0x90>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  409f49:	44 89 e0             	mov    %r12d,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  409f4c:	85 c0                	test   %eax,%eax
  409f4e:	79 da                	jns    409f2a <_ZN6rocket12ConfigReaderixERKSs+0x6a>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  409f50:	bf 30 00 00 00       	mov    $0x30,%edi
  409f55:	e8 26 a2 ff ff       	callq  404180 <_Znwm@plt>
  409f5a:	4c 8d 70 20          	lea    0x20(%rax),%r14
  409f5e:	4c 89 ee             	mov    %r13,%rsi
  409f61:	49 89 c4             	mov    %rax,%r12
  409f64:	4c 89 f7             	mov    %r14,%rdi
  409f67:	e8 54 9d ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  409f6c:	4c 8b 2d ed 9f 20 00 	mov    0x209fed(%rip),%r13        # 613f60 <_DYNAMIC+0x2d8>
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  409f73:	48 89 de             	mov    %rbx,%rsi
  409f76:	4c 89 f2             	mov    %r14,%rdx
  409f79:	48 89 ef             	mov    %rbp,%rdi
  409f7c:	49 8d 45 18          	lea    0x18(%r13),%rax
  409f80:	49 89 44 24 28       	mov    %rax,0x28(%r12)
  409f85:	e8 b6 e8 ff ff       	callq  408840 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_>

	    if (__res.second)
  409f8a:	48 85 d2             	test   %rdx,%rdx
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  409f8d:	48 89 c3             	mov    %rax,%rbx

	    if (__res.second)
  409f90:	74 3e                	je     409fd0 <_ZN6rocket12ConfigReaderixERKSs+0x110>
	      return _M_insert_node(__res.first, __res.second, __z);
  409f92:	4c 89 e1             	mov    %r12,%rcx
  409f95:	48 89 c6             	mov    %rax,%rsi
  409f98:	48 89 ef             	mov    %rbp,%rdi
  409f9b:	e8 30 0d 00 00       	callq  40acd0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E>
  409fa0:	48 89 c3             	mov    %rax,%rbx
  409fa3:	eb 85                	jmp    409f2a <_ZN6rocket12ConfigReaderixERKSs+0x6a>
  409fa5:	0f 1f 00             	nopl   (%rax)
  409fa8:	48 8b 05 c1 9f 20 00 	mov    0x209fc1(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  409faf:	49 8b 4d 00          	mov    0x0(%r13),%rcx
  409fb3:	48 8d 15 99 64 00 00 	lea    0x6499(%rip),%rdx        # 410453 <_ZStL19piecewise_construct+0x37>
  409fba:	be 01 00 00 00       	mov    $0x1,%esi
  409fbf:	48 8b 38             	mov    (%rax),%rdi
  409fc2:	31 c0                	xor    %eax,%eax
  409fc4:	e8 97 9b ff ff       	callq  403b60 <__fprintf_chk@plt>
  409fc9:	e9 16 ff ff ff       	jmpq   409ee4 <_ZN6rocket12ConfigReaderixERKSs+0x24>
  409fce:	66 90                	xchg   %ax,%ax
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409fd0:	49 8b 44 24 28       	mov    0x28(%r12),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409fd5:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409fd9:	4c 39 ef             	cmp    %r13,%rdi
  409fdc:	75 1b                	jne    409ff9 <_ZN6rocket12ConfigReaderixERKSs+0x139>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  409fde:	49 8b 44 24 20       	mov    0x20(%r12),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  409fe3:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  409fe7:	4c 39 ef             	cmp    %r13,%rdi
  409fea:	75 33                	jne    40a01f <_ZN6rocket12ConfigReaderixERKSs+0x15f>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  409fec:	4c 89 e7             	mov    %r12,%rdi
  409fef:	e8 bc 9b ff ff       	callq  403bb0 <_ZdlPv@plt>
  409ff4:	e9 31 ff ff ff       	jmpq   409f2a <_ZN6rocket12ConfigReaderixERKSs+0x6a>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  409ff9:	48 83 3d 77 9f 20 00 	cmpq   $0x0,0x209f77(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a000:	00 
  40a001:	74 42                	je     40a045 <_ZN6rocket12ConfigReaderixERKSs+0x185>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a003:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a008:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a00d:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a00f:	85 c0                	test   %eax,%eax
  40a011:	7f cb                	jg     409fde <_ZN6rocket12ConfigReaderixERKSs+0x11e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a013:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40a018:	e8 53 9d ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a01d:	eb bf                	jmp    409fde <_ZN6rocket12ConfigReaderixERKSs+0x11e>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a01f:	48 83 3d 51 9f 20 00 	cmpq   $0x0,0x209f51(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a026:	00 
  40a027:	74 29                	je     40a052 <_ZN6rocket12ConfigReaderixERKSs+0x192>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a029:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a02e:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a033:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a035:	85 c0                	test   %eax,%eax
  40a037:	7f b3                	jg     409fec <_ZN6rocket12ConfigReaderixERKSs+0x12c>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a039:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40a03e:	e8 2d 9d ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a043:	eb a7                	jmp    409fec <_ZN6rocket12ConfigReaderixERKSs+0x12c>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a045:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a048:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a04b:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a04e:	89 d0                	mov    %edx,%eax
  40a050:	eb bd                	jmp    40a00f <_ZN6rocket12ConfigReaderixERKSs+0x14f>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a052:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a055:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a058:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a05b:	89 d0                	mov    %edx,%eax
  40a05d:	eb d6                	jmp    40a035 <_ZN6rocket12ConfigReaderixERKSs+0x175>
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  40a05f:	48 89 c7             	mov    %rax,%rdi
  40a062:	e8 99 a0 ff ff       	callq  404100 <__cxa_begin_catch@plt>
  40a067:	4c 89 e7             	mov    %r12,%rdi
  40a06a:	e8 41 9b ff ff       	callq  403bb0 <_ZdlPv@plt>
	    {
	      _M_put_node(__tmp);
	      __throw_exception_again;
  40a06f:	e8 ac 9b ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40a074:	48 89 c3             	mov    %rax,%rbx
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  40a077:	e8 04 a0 ff ff       	callq  404080 <__cxa_end_catch@plt>
  40a07c:	48 89 df             	mov    %rbx,%rdi
  40a07f:	e8 1c a1 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40a084:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40a08b:	00 00 00 00 00 

000000000040a090 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_>:
}

string ConfigReader::GetString(const string& section,
                               const string& key,
                               const string& default_value)
{
  40a090:	41 57                	push   %r15
  40a092:	41 56                	push   %r14
  40a094:	49 89 ff             	mov    %rdi,%r15
  40a097:	41 55                	push   %r13
  40a099:	41 54                	push   %r12
  40a09b:	49 89 cd             	mov    %rcx,%r13
  40a09e:	55                   	push   %rbp
  40a09f:	53                   	push   %rbx
  40a0a0:	48 89 f5             	mov    %rsi,%rbp
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  40a0a3:	48 89 d6             	mov    %rdx,%rsi
  40a0a6:	4c 89 c3             	mov    %r8,%rbx
  40a0a9:	48 83 ec 48          	sub    $0x48,%rsp
  40a0ad:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
  40a0b2:	4c 89 e7             	mov    %r12,%rdi
  40a0b5:	e8 06 9c ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  40a0ba:	48 8d 35 f3 62 00 00 	lea    0x62f3(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  40a0c1:	ba 01 00 00 00       	mov    $0x1,%edx
  40a0c6:	4c 89 e7             	mov    %r12,%rdi
  40a0c9:	e8 82 99 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  40a0ce:	4c 89 ee             	mov    %r13,%rsi
  40a0d1:	4c 89 e7             	mov    %r12,%rdi
  40a0d4:	e8 67 a1 ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40a0d9:	48 8b 10             	mov    (%rax),%rdx
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  40a0dc:	48 8b 0d 7d 9e 20 00 	mov    0x209e7d(%rip),%rcx        # 613f60 <_DYNAMIC+0x2d8>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40a0e3:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  40a0e8:	48 8d 51 18          	lea    0x18(%rcx),%rdx
  40a0ec:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a0ef:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a0f4:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a0f8:	48 39 cf             	cmp    %rcx,%rdi
  40a0fb:	0f 85 2f 01 00 00    	jne    40a230 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x1a0>
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
  40a101:	4c 8d 74 24 20       	lea    0x20(%rsp),%r14
			      (this->_M_impl._M_header._M_left));
      }

      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
  40a106:	4c 8d 6d 08          	lea    0x8(%rbp),%r13
  40a10a:	48 89 ef             	mov    %rbp,%rdi
  40a10d:	4c 89 f6             	mov    %r14,%rsi
  40a110:	e8 eb e4 ff ff       	callq  408600 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE4findERS1_>
    string name = section + "." + key;

    if (_m.find(name) != _m.end())
  40a115:	49 39 c5             	cmp    %rax,%r13
  40a118:	0f 84 02 01 00 00    	je     40a220 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x190>
      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
  40a11e:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  40a122:	4c 89 f2             	mov    %r14,%rdx
  40a125:	4c 89 ee             	mov    %r13,%rsi
  40a128:	e8 73 eb ff ff       	callq  408ca0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS2_ESB_RS1_.isra.44>
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40a12d:	49 39 c5             	cmp    %rax,%r13
  40a130:	48 89 c3             	mov    %rax,%rbx
  40a133:	74 4b                	je     40a180 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0xf0>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a135:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40a13a:	48 8b 70 20          	mov    0x20(%rax),%rsi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40a13e:	4c 8b 6f e8          	mov    -0x18(%rdi),%r13
  40a142:	48 8b 4e e8          	mov    -0x18(%rsi),%rcx
  40a146:	4c 89 ea             	mov    %r13,%rdx
  40a149:	4c 39 e9             	cmp    %r13,%rcx
  40a14c:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  40a151:	48 0f 46 d1          	cmovbe %rcx,%rdx
  40a155:	e8 96 9e ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40a15a:	85 c0                	test   %eax,%eax
  40a15c:	0f 85 b1 00 00 00    	jne    40a213 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x183>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  40a162:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  40a167:	49 29 cd             	sub    %rcx,%r13

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  40a16a:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  40a171:	7f 66                	jg     40a1d9 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x149>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  40a173:	49 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%r13
  40a17a:	0f 8d 90 00 00 00    	jge    40a210 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x180>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40a180:	bf 30 00 00 00       	mov    $0x30,%edi
  40a185:	e8 f6 9f ff ff       	callq  404180 <_Znwm@plt>
  40a18a:	49 89 c5             	mov    %rax,%r13
  40a18d:	48 8d 40 20          	lea    0x20(%rax),%rax
  40a191:	4c 89 f6             	mov    %r14,%rsi
  40a194:	48 89 c7             	mov    %rax,%rdi
  40a197:	49 89 c6             	mov    %rax,%r14
  40a19a:	e8 21 9b ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  40a19f:	48 8b 05 ba 9d 20 00 	mov    0x209dba(%rip),%rax        # 613f60 <_DYNAMIC+0x2d8>
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  40a1a6:	48 89 de             	mov    %rbx,%rsi
  40a1a9:	4c 89 f2             	mov    %r14,%rdx
  40a1ac:	48 89 ef             	mov    %rbp,%rdi
  40a1af:	48 83 c0 18          	add    $0x18,%rax
  40a1b3:	49 89 45 28          	mov    %rax,0x28(%r13)
  40a1b7:	e8 84 e6 ff ff       	callq  408840 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE29_M_get_insert_hint_unique_posESt23_Rb_tree_const_iteratorIS2_ERS1_>

	    if (__res.second)
  40a1bc:	48 85 d2             	test   %rdx,%rdx
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
  40a1bf:	48 89 c3             	mov    %rax,%rbx

	    if (__res.second)
  40a1c2:	0f 84 d0 00 00 00    	je     40a298 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x208>
	      return _M_insert_node(__res.first, __res.second, __z);
  40a1c8:	4c 89 e9             	mov    %r13,%rcx
  40a1cb:	48 89 c6             	mov    %rax,%rsi
  40a1ce:	48 89 ef             	mov    %rbp,%rdi
  40a1d1:	e8 fa 0a 00 00       	callq  40acd0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E>
  40a1d6:	48 89 c3             	mov    %rax,%rbx
					    std::tuple<const key_type&>(__k),
					    std::tuple<>());
#else
          __i = insert(__i, value_type(__k, mapped_type()));
#endif
	return (*__i).second;
  40a1d9:	48 8d 73 28          	lea    0x28(%rbx),%rsi
    {
        return _m[name];
  40a1dd:	4c 89 ff             	mov    %r15,%rdi
  40a1e0:	e8 db 9a ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a1e5:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a1ea:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a1ee:	48 3b 3d 6b 9d 20 00 	cmp    0x209d6b(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40a1f5:	75 71                	jne    40a268 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x1d8>
    }

    return default_value;
}
  40a1f7:	48 83 c4 48          	add    $0x48,%rsp
  40a1fb:	4c 89 f8             	mov    %r15,%rax
  40a1fe:	5b                   	pop    %rbx
  40a1ff:	5d                   	pop    %rbp
  40a200:	41 5c                	pop    %r12
  40a202:	41 5d                	pop    %r13
  40a204:	41 5e                	pop    %r14
  40a206:	41 5f                	pop    %r15
  40a208:	c3                   	retq   
  40a209:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  40a210:	44 89 e8             	mov    %r13d,%eax
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
  40a213:	85 c0                	test   %eax,%eax
  40a215:	79 c2                	jns    40a1d9 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x149>
  40a217:	e9 64 ff ff ff       	jmpq   40a180 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0xf0>
  40a21c:	0f 1f 40 00          	nopl   0x0(%rax)
    if (_m.find(name) != _m.end())
    {
        return _m[name];
    }

    return default_value;
  40a220:	48 89 de             	mov    %rbx,%rsi
  40a223:	4c 89 ff             	mov    %r15,%rdi
  40a226:	e8 95 9a ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  40a22b:	eb b8                	jmp    40a1e5 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x155>
  40a22d:	0f 1f 00             	nopl   (%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a230:	48 83 3d 40 9d 20 00 	cmpq   $0x0,0x209d40(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a237:	00 
  40a238:	0f 84 a2 00 00 00    	je     40a2e0 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x250>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a23e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a243:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a248:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a24a:	85 c0                	test   %eax,%eax
  40a24c:	0f 8f af fe ff ff    	jg     40a101 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x71>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a252:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  40a257:	e8 14 9b ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a25c:	e9 a0 fe ff ff       	jmpq   40a101 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x71>
  40a261:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a268:	48 83 3d 08 9d 20 00 	cmpq   $0x0,0x209d08(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a26f:	00 
  40a270:	74 5e                	je     40a2d0 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x240>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a272:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a277:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a27c:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a27e:	85 c0                	test   %eax,%eax
  40a280:	0f 8f 71 ff ff ff    	jg     40a1f7 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x167>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a286:	4c 89 e6             	mov    %r12,%rsi
  40a289:	e8 e2 9a ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a28e:	e9 64 ff ff ff       	jmpq   40a1f7 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x167>
  40a293:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a298:	49 8b 45 28          	mov    0x28(%r13),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a29c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a2a0:	48 3b 3d b9 9c 20 00 	cmp    0x209cb9(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40a2a7:	75 6b                	jne    40a314 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x284>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a2a9:	49 8b 45 20          	mov    0x20(%r13),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a2ad:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a2b1:	48 3b 3d a8 9c 20 00 	cmp    0x209ca8(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40a2b8:	75 36                	jne    40a2f0 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x260>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40a2ba:	4c 89 ef             	mov    %r13,%rdi
  40a2bd:	e8 ee 98 ff ff       	callq  403bb0 <_ZdlPv@plt>
  40a2c2:	e9 12 ff ff ff       	jmpq   40a1d9 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x149>
  40a2c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40a2ce:	00 00 
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a2d0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a2d3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a2d6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a2d9:	89 d0                	mov    %edx,%eax
  40a2db:	eb a1                	jmp    40a27e <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x1ee>
  40a2dd:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a2e0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a2e3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a2e6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a2e9:	89 d0                	mov    %edx,%eax
  40a2eb:	e9 5a ff ff ff       	jmpq   40a24a <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x1ba>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a2f0:	48 83 3d 80 9c 20 00 	cmpq   $0x0,0x209c80(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a2f7:	00 
  40a2f8:	74 45                	je     40a33f <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x2af>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a2fa:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a2ff:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a304:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a306:	85 c0                	test   %eax,%eax
  40a308:	7f b0                	jg     40a2ba <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x22a>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a30a:	4c 89 e6             	mov    %r12,%rsi
  40a30d:	e8 5e 9a ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a312:	eb a6                	jmp    40a2ba <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x22a>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a314:	48 83 3d 5c 9c 20 00 	cmpq   $0x0,0x209c5c(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a31b:	00 
  40a31c:	74 2e                	je     40a34c <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x2bc>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a31e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a323:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a328:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a32a:	85 c0                	test   %eax,%eax
  40a32c:	0f 8f 77 ff ff ff    	jg     40a2a9 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x219>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a332:	4c 89 e6             	mov    %r12,%rsi
  40a335:	e8 36 9a ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a33a:	e9 6a ff ff ff       	jmpq   40a2a9 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x219>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a33f:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a342:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a345:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a348:	89 d0                	mov    %edx,%eax
  40a34a:	eb ba                	jmp    40a306 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x276>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a34c:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a34f:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a352:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a355:	89 d0                	mov    %edx,%eax
  40a357:	eb d1                	jmp    40a32a <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x29a>
  40a359:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a35c:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40a361:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a365:	48 3b 3d f4 9b 20 00 	cmp    0x209bf4(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40a36c:	74 0a                	je     40a378 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x2e8>
  40a36e:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  40a373:	e8 80 9f ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40a378:	48 89 df             	mov    %rbx,%rdi
  40a37b:	e8 20 9e ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40a380:	eb d7                	jmp    40a359 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x2c9>
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  40a382:	48 89 c7             	mov    %rax,%rdi
  40a385:	e8 76 9d ff ff       	callq  404100 <__cxa_begin_catch@plt>
  40a38a:	4c 89 ef             	mov    %r13,%rdi
  40a38d:	e8 1e 98 ff ff       	callq  403bb0 <_ZdlPv@plt>
	    {
	      _M_put_node(__tmp);
	      __throw_exception_again;
  40a392:	e8 89 98 ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40a397:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a39a:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40a39f:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a3a3:	48 3b 3d b6 9b 20 00 	cmp    0x209bb6(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40a3aa:	74 cc                	je     40a378 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x2e8>
  40a3ac:	4c 89 e6             	mov    %r12,%rsi
  40a3af:	e8 44 9f ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40a3b4:	eb c2                	jmp    40a378 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x2e8>
  40a3b6:	48 89 c3             	mov    %rax,%rbx
	      ::new(__tmp) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __tmp->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
  40a3b9:	e8 c2 9c ff ff       	callq  404080 <__cxa_end_catch@plt>
  40a3be:	eb da                	jmp    40a39a <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_+0x30a>

000000000040a3c0 <_ZN6rocket12ConfigReader7GetListERKSsS2_>:
}

vector<string> ConfigReader::GetList(const string& section,
                                     const string& key)
{
  40a3c0:	41 57                	push   %r15
  40a3c2:	41 56                	push   %r14
  40a3c4:	49 89 f7             	mov    %rsi,%r15
  40a3c7:	41 55                	push   %r13
  40a3c9:	41 54                	push   %r12
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  40a3cb:	48 89 d6             	mov    %rdx,%rsi
  40a3ce:	55                   	push   %rbp
  40a3cf:	53                   	push   %rbx
  40a3d0:	48 89 fd             	mov    %rdi,%rbp
  40a3d3:	49 89 d6             	mov    %rdx,%r14
  40a3d6:	48 89 cb             	mov    %rcx,%rbx
  40a3d9:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
  40a3e0:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
  40a3e7:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  40a3ee:	00 
  40a3ef:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  40a3f4:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  40a3fb:	00 
  40a3fc:	48 89 c7             	mov    %rax,%rdi
  40a3ff:	49 89 c5             	mov    %rax,%r13
  40a402:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40a407:	e8 b4 98 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  40a40c:	48 8d 35 a1 5f 00 00 	lea    0x5fa1(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  40a413:	ba 01 00 00 00       	mov    $0x1,%edx
  40a418:	4c 89 ef             	mov    %r13,%rdi
  40a41b:	e8 30 96 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }
  40a420:	48 89 de             	mov    %rbx,%rsi
  40a423:	4c 89 ef             	mov    %r13,%rdi
  40a426:	e8 15 9e ff ff       	callq  404240 <_ZNSs6appendERKSs@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40a42b:	48 8b 10             	mov    (%rax),%rdx
  40a42e:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  40a433:	48 8b 15 26 9b 20 00 	mov    0x209b26(%rip),%rdx        # 613f60 <_DYNAMIC+0x2d8>
  40a43a:	48 89 d6             	mov    %rdx,%rsi
  40a43d:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  40a442:	48 83 c2 18          	add    $0x18,%rdx
  40a446:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a449:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a44e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a452:	48 39 f7             	cmp    %rsi,%rdi
  40a455:	0f 85 1b 03 00 00    	jne    40a776 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x3b6>
    vector<string> v;
    string name = section + "." + key;
    string str = GetString(section, key, "");
  40a45b:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
  40a460:	4c 8d ac 24 90 00 00 	lea    0x90(%rsp),%r13
  40a467:	00 
  40a468:	48 8d 35 b5 5f 00 00 	lea    0x5fb5(%rip),%rsi        # 410424 <_ZStL19piecewise_construct+0x8>
  40a46f:	4c 89 ea             	mov    %r13,%rdx
  40a472:	48 89 c7             	mov    %rax,%rdi
  40a475:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  40a47a:	e8 a1 99 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40a47f:	4c 8d 64 24 50       	lea    0x50(%rsp),%r12
  40a484:	4c 8b 44 24 20       	mov    0x20(%rsp),%r8
  40a489:	48 89 d9             	mov    %rbx,%rcx
  40a48c:	4c 89 f2             	mov    %r14,%rdx
  40a48f:	4c 89 fe             	mov    %r15,%rsi
  40a492:	4c 89 e7             	mov    %r12,%rdi
  40a495:	e8 f6 fb ff ff       	callq  40a090 <_ZN6rocket12ConfigReader9GetStringERKSsS2_S2_>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a49a:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a49f:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a4a3:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a4a8:	0f 85 5a 02 00 00    	jne    40a708 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x348>
  40a4ae:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
  40a4b5:	00 
  40a4b6:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    string sep = ", \t";
  40a4bb:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40a4c0:	48 8d 7c 24 70       	lea    0x70(%rsp),%rdi
  40a4c5:	48 8d 35 99 5f 00 00 	lea    0x5f99(%rip),%rsi        # 410465 <_ZStL19piecewise_construct+0x49>
  40a4cc:	e8 4f 99 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  40a4d1:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    string substr;
    string::size_type start = 0;
  40a4d6:	45 31 ff             	xor    %r15d,%r15d
      // PR 58265, this should be noexcept.
      basic_string&
      operator=(basic_string&& __str)
      {
	// NB: DR 1204.
	this->swap(__str);
  40a4d9:	4c 8d b4 24 80 00 00 	lea    0x80(%rsp),%r14
  40a4e0:	00 

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  40a4e1:	48 83 c0 18          	add    $0x18,%rax
  40a4e5:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
  40a4ec:	00 
    string::size_type index;

    while ((index = str.find_first_of(sep, start)) != string::npos)
  40a4ed:	eb 49                	jmp    40a538 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x178>
  40a4ef:	90                   	nop
       *  available.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  40a4f0:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
  40a4f4:	48 3b 7d 10          	cmp    0x10(%rbp),%rdi
  40a4f8:	0f 84 e2 00 00 00    	je     40a5e0 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x220>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40a4fe:	48 85 ff             	test   %rdi,%rdi
  40a501:	74 0c                	je     40a50f <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x14f>
  40a503:	4c 89 f6             	mov    %r14,%rsi
  40a506:	e8 b5 97 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  40a50b:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
	                             __x);
	    ++this->_M_impl._M_finish;
  40a50f:	48 83 c7 08          	add    $0x8,%rdi
  40a513:	48 89 7d 08          	mov    %rdi,0x8(%rbp)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a517:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
  40a51c:	48 89 da             	mov    %rbx,%rdx
  40a51f:	4c 89 e7             	mov    %r12,%rdi
  40a522:	48 8b 4e e8          	mov    -0x18(%rsi),%rcx
  40a526:	e8 25 98 ff ff       	callq  403d50 <_ZNKSs17find_first_not_ofEPKcmm@plt>
    {
        substr = str.substr(start, index - start);
        v.push_back(substr);

        start = str.find_first_not_of(sep, index);
        if (start == string::npos)
  40a52b:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  40a52f:	49 89 c7             	mov    %rax,%r15
  40a532:	0f 84 57 01 00 00    	je     40a68f <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2cf>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a538:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
       *  npos.
      */
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
  40a53d:	4c 89 fa             	mov    %r15,%rdx
  40a540:	4c 89 e7             	mov    %r12,%rdi
  40a543:	48 8b 4e e8          	mov    -0x18(%rsi),%rcx
  40a547:	e8 64 98 ff ff       	callq  403db0 <_ZNKSs13find_first_ofEPKcmm@plt>
    string sep = ", \t";
    string substr;
    string::size_type start = 0;
    string::size_type index;

    while ((index = str.find_first_of(sep, start)) != string::npos)
  40a54c:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  40a550:	48 89 c3             	mov    %rax,%rbx
  40a553:	0f 84 97 00 00 00    	je     40a5f0 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x230>
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40a559:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
    {
        substr = str.substr(start, index - start);
  40a55e:	48 89 d9             	mov    %rbx,%rcx
  40a561:	4c 29 f9             	sub    %r15,%rcx
  40a564:	48 8b 40 e8          	mov    -0x18(%rax),%rax
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
  40a568:	49 39 c7             	cmp    %rax,%r15
  40a56b:	0f 87 4b 03 00 00    	ja     40a8bc <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x4fc>
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }
  40a571:	4c 89 fa             	mov    %r15,%rdx
  40a574:	4c 89 e6             	mov    %r12,%rsi
  40a577:	4c 89 ef             	mov    %r13,%rdi
  40a57a:	e8 11 9c ff ff       	callq  404190 <_ZNSsC1ERKSsmm@plt>
      // PR 58265, this should be noexcept.
      basic_string&
      operator=(basic_string&& __str)
      {
	// NB: DR 1204.
	this->swap(__str);
  40a57f:	4c 89 ee             	mov    %r13,%rsi
  40a582:	4c 89 f7             	mov    %r14,%rdi
  40a585:	e8 86 9c ff ff       	callq  404210 <_ZNSs4swapERSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a58a:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  40a591:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a592:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a596:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a59b:	0f 84 4f ff ff ff    	je     40a4f0 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x130>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a5a1:	48 83 3d cf 99 20 00 	cmpq   $0x0,0x2099cf(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a5a8:	00 
  40a5a9:	0f 84 49 01 00 00    	je     40a6f8 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x338>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a5af:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a5b4:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a5b9:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a5bb:	85 c0                	test   %eax,%eax
  40a5bd:	0f 8f 2d ff ff ff    	jg     40a4f0 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x130>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a5c3:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40a5c8:	e8 a3 97 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
       *  available.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  40a5cd:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
  40a5d1:	48 3b 7d 10          	cmp    0x10(%rbp),%rdi
  40a5d5:	0f 85 23 ff ff ff    	jne    40a4fe <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x13e>
  40a5db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	                             __x);
	    ++this->_M_impl._M_finish;
	  }
	else
#if __cplusplus >= 201103L
	  _M_emplace_back_aux(__x);
  40a5e0:	4c 89 f6             	mov    %r14,%rsi
  40a5e3:	48 89 ef             	mov    %rbp,%rdi
  40a5e6:	e8 c5 04 00 00       	callq  40aab0 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_>
  40a5eb:	e9 27 ff ff ff       	jmpq   40a517 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x157>
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40a5f0:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  40a5f5:	48 8b 48 e8          	mov    -0x18(%rax),%rcx
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
  40a5f9:	49 39 cf             	cmp    %rcx,%r15
  40a5fc:	0f 87 3d 04 00 00    	ja     40aa3f <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x67f>
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }
  40a602:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14
  40a607:	48 89 d9             	mov    %rbx,%rcx
  40a60a:	4c 89 fa             	mov    %r15,%rdx
  40a60d:	4c 89 e6             	mov    %r12,%rsi
  40a610:	4c 89 f7             	mov    %r14,%rdi
  40a613:	e8 78 9b ff ff       	callq  404190 <_ZNSsC1ERKSsmm@plt>
      // PR 58265, this should be noexcept.
      basic_string&
      operator=(basic_string&& __str)
      {
	// NB: DR 1204.
	this->swap(__str);
  40a618:	48 8d 9c 24 80 00 00 	lea    0x80(%rsp),%rbx
  40a61f:	00 
  40a620:	4c 89 f6             	mov    %r14,%rsi
  40a623:	48 89 df             	mov    %rbx,%rdi
  40a626:	e8 e5 9b ff ff       	callq  404210 <_ZNSs4swapERSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a62b:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
  40a632:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a633:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a637:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a63c:	74 2a                	je     40a668 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2a8>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a63e:	48 83 3d 32 99 20 00 	cmpq   $0x0,0x209932(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a645:	00 
  40a646:	0f 84 00 02 00 00    	je     40a84c <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x48c>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a64c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a651:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a656:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a658:	85 c0                	test   %eax,%eax
  40a65a:	7f 0c                	jg     40a668 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2a8>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a65c:	4c 89 ee             	mov    %r13,%rsi
  40a65f:	e8 0c 97 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a664:	0f 1f 40 00          	nopl   0x0(%rax)
       *  available.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  40a668:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
  40a66c:	48 3b 7d 10          	cmp    0x10(%rbp),%rdi
  40a670:	0f 84 c6 01 00 00    	je     40a83c <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x47c>
  40a676:	48 85 ff             	test   %rdi,%rdi
  40a679:	74 0c                	je     40a687 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2c7>
  40a67b:	48 89 de             	mov    %rbx,%rsi
  40a67e:	e8 3d 96 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  40a683:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
	                             __x);
	    ++this->_M_impl._M_finish;
  40a687:	48 83 c7 08          	add    $0x8,%rdi
  40a68b:	48 89 7d 08          	mov    %rdi,0x8(%rbp)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a68f:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  40a696:	00 
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a697:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a69b:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a6a0:	0f 85 07 01 00 00    	jne    40a7ad <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x3ed>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a6a6:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a6ab:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a6af:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a6b4:	0f 85 24 01 00 00    	jne    40a7de <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x41e>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a6ba:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a6bf:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a6c3:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a6c8:	0f 85 3d 01 00 00    	jne    40a80b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x44b>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a6ce:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  40a6d3:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a6d7:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a6dc:	75 66                	jne    40a744 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x384>

    substr = str.substr(start);
    v.push_back(substr);

    return v;
}
  40a6de:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
  40a6e5:	48 89 e8             	mov    %rbp,%rax
  40a6e8:	5b                   	pop    %rbx
  40a6e9:	5d                   	pop    %rbp
  40a6ea:	41 5c                	pop    %r12
  40a6ec:	41 5d                	pop    %r13
  40a6ee:	41 5e                	pop    %r14
  40a6f0:	41 5f                	pop    %r15
  40a6f2:	c3                   	retq   
  40a6f3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a6f8:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a6fb:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a6fe:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a701:	89 d0                	mov    %edx,%eax
  40a703:	e9 b3 fe ff ff       	jmpq   40a5bb <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x1fb>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a708:	48 83 3d 68 98 20 00 	cmpq   $0x0,0x209868(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a70f:	00 
  40a710:	0f 84 63 01 00 00    	je     40a879 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x4b9>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a716:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a71b:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a720:	89 d0                	mov    %edx,%eax
  40a722:	48 8d 9c 24 a0 00 00 	lea    0xa0(%rsp),%rbx
  40a729:	00 
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a72a:	85 c0                	test   %eax,%eax
  40a72c:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
  40a731:	0f 8f 84 fd ff ff    	jg     40a4bb <_ZN6rocket12ConfigReader7GetListERKSsS2_+0xfb>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a737:	48 89 de             	mov    %rbx,%rsi
  40a73a:	e8 31 96 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a73f:	e9 77 fd ff ff       	jmpq   40a4bb <_ZN6rocket12ConfigReader7GetListERKSsS2_+0xfb>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a744:	48 83 3d 2c 98 20 00 	cmpq   $0x0,0x20982c(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a74b:	00 
  40a74c:	0f 84 47 01 00 00    	je     40a899 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x4d9>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a752:	48 89 c3             	mov    %rax,%rbx
  40a755:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40a75a:	f0 0f c1 43 f8       	lock xadd %eax,-0x8(%rbx)
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a75f:	85 c0                	test   %eax,%eax
  40a761:	0f 8f 77 ff ff ff    	jg     40a6de <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x31e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a767:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40a76c:	e8 ff 95 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a771:	e9 68 ff ff ff       	jmpq   40a6de <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x31e>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a776:	48 83 3d fa 97 20 00 	cmpq   $0x0,0x2097fa(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a77d:	00 
  40a77e:	0f 84 05 01 00 00    	je     40a889 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x4c9>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a784:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a789:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a78e:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a790:	85 c0                	test   %eax,%eax
  40a792:	0f 8f c3 fc ff ff    	jg     40a45b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x9b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a798:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
  40a79f:	00 
  40a7a0:	48 89 c6             	mov    %rax,%rsi
  40a7a3:	e8 c8 95 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a7a8:	e9 ae fc ff ff       	jmpq   40a45b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x9b>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a7ad:	48 83 3d c3 97 20 00 	cmpq   $0x0,0x2097c3(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a7b4:	00 
  40a7b5:	0f 84 ae 00 00 00    	je     40a869 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x4a9>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a7bb:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a7c0:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a7c5:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a7c7:	85 c0                	test   %eax,%eax
  40a7c9:	0f 8f d7 fe ff ff    	jg     40a6a6 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2e6>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a7cf:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40a7d4:	e8 97 95 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a7d9:	e9 c8 fe ff ff       	jmpq   40a6a6 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2e6>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a7de:	48 83 3d 92 97 20 00 	cmpq   $0x0,0x209792(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a7e5:	00 
  40a7e6:	74 74                	je     40a85c <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x49c>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a7e8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a7ed:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a7f2:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a7f4:	85 c0                	test   %eax,%eax
  40a7f6:	0f 8f be fe ff ff    	jg     40a6ba <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2fa>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a7fc:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40a801:	e8 6a 95 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a806:	e9 af fe ff ff       	jmpq   40a6ba <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2fa>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a80b:	48 83 3d 65 97 20 00 	cmpq   $0x0,0x209765(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a812:	00 
  40a813:	0f 84 93 00 00 00    	je     40a8ac <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x4ec>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a819:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40a81e:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40a823:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a825:	85 c0                	test   %eax,%eax
  40a827:	0f 8f a1 fe ff ff    	jg     40a6ce <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x30e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a82d:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40a832:	e8 39 95 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a837:	e9 92 fe ff ff       	jmpq   40a6ce <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x30e>
	  }
	else
#if __cplusplus >= 201103L
	  _M_emplace_back_aux(__x);
  40a83c:	48 89 de             	mov    %rbx,%rsi
  40a83f:	48 89 ef             	mov    %rbp,%rdi
  40a842:	e8 69 02 00 00       	callq  40aab0 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_>
  40a847:	e9 43 fe ff ff       	jmpq   40a68f <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x2cf>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a84c:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a84f:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a852:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a855:	89 d0                	mov    %edx,%eax
  40a857:	e9 fc fd ff ff       	jmpq   40a658 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x298>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a85c:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a85f:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a862:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a865:	89 d0                	mov    %edx,%eax
  40a867:	eb 8b                	jmp    40a7f4 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x434>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a869:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a86c:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a86f:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a872:	89 d0                	mov    %edx,%eax
  40a874:	e9 4e ff ff ff       	jmpq   40a7c7 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x407>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a879:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a87c:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a87f:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a882:	89 d0                	mov    %edx,%eax
  40a884:	e9 99 fe ff ff       	jmpq   40a722 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x362>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a889:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a88c:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a88f:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a892:	89 d0                	mov    %edx,%eax
  40a894:	e9 f7 fe ff ff       	jmpq   40a790 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x3d0>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a899:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
  40a89e:	8b 43 f8             	mov    -0x8(%rbx),%eax
    *__mem += __val;
  40a8a1:	8d 50 ff             	lea    -0x1(%rax),%edx
  40a8a4:	89 53 f8             	mov    %edx,-0x8(%rbx)
  40a8a7:	e9 b3 fe ff ff       	jmpq   40a75f <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x39f>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40a8ac:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40a8af:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40a8b2:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40a8b5:	89 d0                	mov    %edx,%eax
  40a8b7:	e9 69 ff ff ff       	jmpq   40a825 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x465>

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
  40a8bc:	48 8d 35 76 5b 00 00 	lea    0x5b76(%rip),%rsi        # 410439 <_ZStL19piecewise_construct+0x1d>
  40a8c3:	48 8d 3d a6 5b 00 00 	lea    0x5ba6(%rip),%rdi        # 410470 <_ZStL19piecewise_construct+0x54>
  40a8ca:	48 89 c1             	mov    %rax,%rcx
  40a8cd:	4c 89 fa             	mov    %r15,%rdx
  40a8d0:	31 c0                	xor    %eax,%eax
  40a8d2:	e8 19 92 ff ff       	callq  403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>
  40a8d7:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a8da:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  40a8e1:	00 
  40a8e2:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a8e6:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a8eb:	74 0a                	je     40a8f7 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x537>
  40a8ed:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  40a8f2:	e8 01 9a ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a8f7:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  40a8fc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a900:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a905:	74 0a                	je     40a911 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x551>
  40a907:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  40a90c:	e8 e7 99 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a911:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  40a916:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a91a:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a91f:	74 0a                	je     40a92b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x56b>
  40a921:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  40a926:	e8 cd 99 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a92b:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40a930:	48 83 ef 18          	sub    $0x18,%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a934:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a939:	74 0a                	je     40a945 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x585>
  40a93b:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
  40a940:	e8 b3 99 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  40a945:	4c 8b 6d 08          	mov    0x8(%rbp),%r13
  40a949:	4c 8b 75 00          	mov    0x0(%rbp),%r14
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
  40a94d:	4d 39 f5             	cmp    %r14,%r13
  40a950:	74 2c                	je     40a97e <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x5be>
  40a952:	48 8b 05 07 96 20 00 	mov    0x209607(%rip),%rax        # 613f60 <_DYNAMIC+0x2d8>
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a959:	4c 8d 64 24 3f       	lea    0x3f(%rsp),%r12
  40a95e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40a963:	49 8b 16             	mov    (%r14),%rdx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a966:	48 8d 7a e8          	lea    -0x18(%rdx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a96a:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a96f:	75 49                	jne    40a9ba <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x5fa>
  40a971:	49 83 c6 08          	add    $0x8,%r14
  40a975:	4d 39 f5             	cmp    %r14,%r13
  40a978:	75 e9                	jne    40a963 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x5a3>
  40a97a:	4c 8b 6d 00          	mov    0x0(%rbp),%r13

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
  40a97e:	4d 85 ed             	test   %r13,%r13
  40a981:	74 08                	je     40a98b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x5cb>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40a983:	4c 89 ef             	mov    %r13,%rdi
  40a986:	e8 25 92 ff ff       	callq  403bb0 <_ZdlPv@plt>
  40a98b:	48 89 df             	mov    %rbx,%rdi
  40a98e:	e8 0d 98 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40a993:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a996:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
  40a99d:	00 
  40a99e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a9a2:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a9a7:	0f 84 2d ff ff ff    	je     40a8da <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x51a>
  40a9ad:	4c 89 ee             	mov    %r13,%rsi
  40a9b0:	e8 43 99 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40a9b5:	e9 20 ff ff ff       	jmpq   40a8da <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x51a>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40a9ba:	48 83 3d b6 95 20 00 	cmpq   $0x0,0x2095b6(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40a9c1:	00 
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
  40a9c2:	48 8d 4f 10          	lea    0x10(%rdi),%rcx
  40a9c6:	0f 84 c6 00 00 00    	je     40aa92 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x6d2>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40a9cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40a9d1:	f0 0f c1 01          	lock xadd %eax,(%rcx)
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40a9d5:	85 c0                	test   %eax,%eax
  40a9d7:	7f 98                	jg     40a971 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x5b1>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40a9d9:	4c 89 e6             	mov    %r12,%rsi
  40a9dc:	e8 8f 93 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40a9e1:	eb 8e                	jmp    40a971 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x5b1>
  40a9e3:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40a9e6:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  40a9eb:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40a9ef:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40a9f4:	0f 84 31 ff ff ff    	je     40a92b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x56b>
  40a9fa:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40aa01:	00 
  40aa02:	e8 f1 98 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40aa07:	e9 1f ff ff ff       	jmpq   40a92b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x56b>
  40aa0c:	48 89 c3             	mov    %rax,%rbx
  40aa0f:	e9 31 ff ff ff       	jmpq   40a945 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x585>
  40aa14:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40aa17:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  40aa1c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40aa20:	48 3b 3d 39 95 20 00 	cmp    0x209539(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40aa27:	0f 84 18 ff ff ff    	je     40a945 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x585>
  40aa2d:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40aa34:	00 
  40aa35:	e8 be 98 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40aa3a:	e9 06 ff ff ff       	jmpq   40a945 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x585>

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
  40aa3f:	48 8d 35 f3 59 00 00 	lea    0x59f3(%rip),%rsi        # 410439 <_ZStL19piecewise_construct+0x1d>
  40aa46:	48 8d 3d 23 5a 00 00 	lea    0x5a23(%rip),%rdi        # 410470 <_ZStL19piecewise_construct+0x54>
  40aa4d:	4c 89 fa             	mov    %r15,%rdx
  40aa50:	31 c0                	xor    %eax,%eax
  40aa52:	e8 99 90 ff ff       	callq  403af0 <_ZSt24__throw_out_of_range_fmtPKcz@plt>
  40aa57:	eb bb                	jmp    40aa14 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x654>
  40aa59:	48 89 c3             	mov    %rax,%rbx
  40aa5c:	e9 b0 fe ff ff       	jmpq   40a911 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x551>
  40aa61:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40aa64:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
  40aa6b:	00 
  40aa6c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40aa70:	48 3b 7c 24 08       	cmp    0x8(%rsp),%rdi
  40aa75:	0f 84 5f fe ff ff    	je     40a8da <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x51a>
  40aa7b:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40aa80:	e8 73 98 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40aa85:	e9 50 fe ff ff       	jmpq   40a8da <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x51a>
  40aa8a:	48 89 c3             	mov    %rax,%rbx
  40aa8d:	e9 99 fe ff ff       	jmpq   40a92b <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x56b>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40aa92:	8b 42 f8             	mov    -0x8(%rdx),%eax
    *__mem += __val;
  40aa95:	8d 48 ff             	lea    -0x1(%rax),%ecx
  40aa98:	89 4a f8             	mov    %ecx,-0x8(%rdx)
  40aa9b:	e9 35 ff ff ff       	jmpq   40a9d5 <_ZN6rocket12ConfigReader7GetListERKSsS2_+0x615>

000000000040aaa0 <_ZNKSt5ctypeIcE8do_widenEc>:
       *  @param __c  The char to convert.
       *  @return  The converted character.
      */
      virtual char_type
      do_widen(char __c) const
      { return __c; }
  40aaa0:	89 f0                	mov    %esi,%eax
  40aaa2:	c3                   	retq   
  40aaa3:	90                   	nop
  40aaa4:	90                   	nop
  40aaa5:	90                   	nop
  40aaa6:	90                   	nop
  40aaa7:	90                   	nop
  40aaa8:	90                   	nop
  40aaa9:	90                   	nop
  40aaaa:	90                   	nop
  40aaab:	90                   	nop
  40aaac:	90                   	nop
  40aaad:	90                   	nop
  40aaae:	90                   	nop
  40aaaf:	90                   	nop

000000000040aab0 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
  40aab0:	41 57                	push   %r15
  40aab2:	41 56                	push   %r14
  40aab4:	41 55                	push   %r13
  40aab6:	41 54                	push   %r12
  40aab8:	55                   	push   %rbp
  40aab9:	53                   	push   %rbx
  40aaba:	48 89 fd             	mov    %rdi,%rbp
  40aabd:	48 83 ec 28          	sub    $0x28,%rsp
  40aac1:	4c 8b 77 08          	mov    0x8(%rdi),%r14
  40aac5:	48 8b 07             	mov    (%rdi),%rax

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
  40aac8:	4c 89 f7             	mov    %r14,%rdi
  40aacb:	48 29 c7             	sub    %rax,%rdi
  40aace:	48 89 fa             	mov    %rdi,%rdx
  40aad1:	48 c1 fa 03          	sar    $0x3,%rdx
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
  40aad5:	48 85 d2             	test   %rdx,%rdx
  40aad8:	0f 84 3a 01 00 00    	je     40ac18 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x168>
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
  40aade:	48 8d 0c 12          	lea    (%rdx,%rdx,1),%rcx
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  40aae2:	48 39 ca             	cmp    %rcx,%rdx
  40aae5:	0f 86 5c 01 00 00    	jbe    40ac47 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x197>
  40aaeb:	48 b8 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rax
  40aaf2:	ff ff 1f 
  40aaf5:	48 c7 c7 f8 ff ff ff 	mov    $0xfffffffffffffff8,%rdi
  40aafc:	48 89 04 24          	mov    %rax,(%rsp)
  40ab00:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40ab05:	e8 76 96 ff ff       	callq  404180 <_Znwm@plt>
  40ab0a:	4c 8b 75 08          	mov    0x8(%rbp),%r14
  40ab0e:	49 89 c4             	mov    %rax,%r12
  40ab11:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40ab15:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  40ab1a:	4c 89 f7             	mov    %r14,%rdi
  40ab1d:	48 29 c7             	sub    %rax,%rdi

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40ab20:	4c 01 e7             	add    %r12,%rdi
  40ab23:	74 0d                	je     40ab32 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x82>
  40ab25:	e8 96 91 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  40ab2a:	4c 8b 75 08          	mov    0x8(%rbp),%r14
  40ab2e:	48 8b 45 00          	mov    0x0(%rbp),%rax
		      _ForwardIterator __result)
        {
	  _ForwardIterator __cur = __result;
	  __try
	    {
	      for (; __first != __last; ++__first, ++__cur)
  40ab32:	49 39 c6             	cmp    %rax,%r14
  40ab35:	0f 84 05 01 00 00    	je     40ac40 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x190>
  40ab3b:	4c 8b 3d 1e 94 20 00 	mov    0x20941e(%rip),%r15        # 613f60 <_DYNAMIC+0x2d8>
  40ab42:	48 89 c2             	mov    %rax,%rdx
  40ab45:	4c 89 e1             	mov    %r12,%rcx
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  40ab48:	49 8d 7f 18          	lea    0x18(%r15),%rdi
  40ab4c:	0f 1f 40 00          	nopl   0x0(%rax)
   */
#if __cplusplus >= 201103L
  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
  40ab50:	48 85 c9             	test   %rcx,%rcx
  40ab53:	74 09                	je     40ab5e <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0xae>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40ab55:	48 8b 32             	mov    (%rdx),%rsi
  40ab58:	48 89 31             	mov    %rsi,(%rcx)
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  40ab5b:	48 89 3a             	mov    %rdi,(%rdx)
      { return _M_current; }

      move_iterator&
      operator++()
      {
	++_M_current;
  40ab5e:	48 83 c2 08          	add    $0x8,%rdx
  40ab62:	48 83 c1 08          	add    $0x8,%rcx
  40ab66:	4c 39 f2             	cmp    %r14,%rdx
  40ab69:	75 e5                	jne    40ab50 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0xa0>
  40ab6b:	48 8d 58 08          	lea    0x8(%rax),%rbx
  40ab6f:	4c 89 f2             	mov    %r14,%rdx
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40ab72:	4c 8d 44 24 1f       	lea    0x1f(%rsp),%r8
  40ab77:	48 29 da             	sub    %rbx,%rdx
  40ab7a:	48 83 e2 f8          	and    $0xfffffffffffffff8,%rdx
	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
  40ab7e:	4e 8d 6c 22 10       	lea    0x10(%rdx,%r12,1),%r13
  40ab83:	eb 0f                	jmp    40ab94 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0xe4>
  40ab85:	0f 1f 00             	nopl   (%rax)
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
  40ab88:	49 39 de             	cmp    %rbx,%r14
  40ab8b:	48 89 d8             	mov    %rbx,%rax
  40ab8e:	74 50                	je     40abe0 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x130>
  40ab90:	48 83 c3 08          	add    $0x8,%rbx
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40ab94:	48 8b 00             	mov    (%rax),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40ab97:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40ab9b:	4c 39 ff             	cmp    %r15,%rdi
  40ab9e:	74 e8                	je     40ab88 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0xd8>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40aba0:	48 83 3d d0 93 20 00 	cmpq   $0x0,0x2093d0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40aba7:	00 
  40aba8:	0f 84 82 00 00 00    	je     40ac30 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x180>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40abae:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40abb3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40abb8:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40abba:	85 c0                	test   %eax,%eax
  40abbc:	7f ca                	jg     40ab88 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0xd8>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40abbe:	4c 89 c6             	mov    %r8,%rsi
  40abc1:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  40abc6:	e8 a5 91 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40abcb:	49 39 de             	cmp    %rbx,%r14
  40abce:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  40abd3:	48 89 d8             	mov    %rbx,%rax
  40abd6:	75 b8                	jne    40ab90 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0xe0>
  40abd8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40abdf:	00 
  40abe0:	4c 8b 75 00          	mov    0x0(%rbp),%r14

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
  40abe4:	4d 85 f6             	test   %r14,%r14
  40abe7:	74 08                	je     40abf1 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x141>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40abe9:	4c 89 f7             	mov    %r14,%rdi
  40abec:	e8 bf 8f ff ff       	callq  403bb0 <_ZdlPv@plt>
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
	this->_M_impl._M_finish = __new_finish;
	this->_M_impl._M_end_of_storage = __new_start + __len;
  40abf1:	48 8b 04 24          	mov    (%rsp),%rax
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
  40abf5:	4c 89 65 00          	mov    %r12,0x0(%rbp)
	this->_M_impl._M_finish = __new_finish;
  40abf9:	4c 89 6d 08          	mov    %r13,0x8(%rbp)
	this->_M_impl._M_end_of_storage = __new_start + __len;
  40abfd:	49 8d 04 c4          	lea    (%r12,%rax,8),%rax
  40ac01:	48 89 45 10          	mov    %rax,0x10(%rbp)
      }
  40ac05:	48 83 c4 28          	add    $0x28,%rsp
  40ac09:	5b                   	pop    %rbx
  40ac0a:	5d                   	pop    %rbp
  40ac0b:	41 5c                	pop    %r12
  40ac0d:	41 5d                	pop    %r13
  40ac0f:	41 5e                	pop    %r14
  40ac11:	41 5f                	pop    %r15
  40ac13:	c3                   	retq   
  40ac14:	0f 1f 40 00          	nopl   0x0(%rax)
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
  40ac18:	b9 01 00 00 00       	mov    $0x1,%ecx
  40ac1d:	48 8d 3c cd 00 00 00 	lea    0x0(,%rcx,8),%rdi
  40ac24:	00 
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  40ac25:	48 89 0c 24          	mov    %rcx,(%rsp)
  40ac29:	e9 d2 fe ff ff       	jmpq   40ab00 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x50>
  40ac2e:	66 90                	xchg   %ax,%ax
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40ac30:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40ac33:	8d 72 ff             	lea    -0x1(%rdx),%esi
  40ac36:	89 70 f8             	mov    %esi,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40ac39:	89 d0                	mov    %edx,%eax
  40ac3b:	e9 7a ff ff ff       	jmpq   40abba <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x10a>
	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
  40ac40:	4d 8d 6c 24 08       	lea    0x8(%r12),%r13
  40ac45:	eb 9d                	jmp    40abe4 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x134>
  40ac47:	49 bd ff ff ff ff ff 	movabs $0x1fffffffffffffff,%r13
  40ac4e:	ff ff 1f 
  40ac51:	4c 39 e9             	cmp    %r13,%rcx
  40ac54:	76 12                	jbe    40ac68 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x1b8>
  40ac56:	48 c7 c7 f8 ff ff ff 	mov    $0xfffffffffffffff8,%rdi
  40ac5d:	4c 89 2c 24          	mov    %r13,(%rsp)
  40ac61:	e9 9a fe ff ff       	jmpq   40ab00 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x50>
  40ac66:	eb 15                	jmp    40ac7d <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x1cd>

      pointer
      _M_allocate(size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : 0;
  40ac68:	48 85 c9             	test   %rcx,%rcx
  40ac6b:	75 b0                	jne    40ac1d <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x16d>
  40ac6d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40ac74:	00 
  40ac75:	45 31 e4             	xor    %r12d,%r12d
  40ac78:	e9 a3 fe ff ff       	jmpq   40ab20 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x70>
	  }
	__catch(...)
  40ac7d:	48 89 c7             	mov    %rax,%rdi
  40ac80:	e8 7b 94 ff ff       	callq  404100 <__cxa_begin_catch@plt>
	  {
	    if (!__new_finish)
  40ac85:	4d 85 e4             	test   %r12,%r12
  40ac88:	74 0d                	je     40ac97 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x1e7>
  40ac8a:	4c 89 e7             	mov    %r12,%rdi
  40ac8d:	e8 1e 8f ff ff       	callq  403bb0 <_ZdlPv@plt>
	      _Alloc_traits::destroy(this->_M_impl, __new_start + size());
	    else
	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
	    _M_deallocate(__new_start, __len);
	    __throw_exception_again;
  40ac92:	e8 89 8f ff ff       	callq  403c20 <__cxa_rethrow@plt>

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
  40ac97:	48 8b 45 08          	mov    0x8(%rbp),%rax
  40ac9b:	48 2b 45 00          	sub    0x0(%rbp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40ac9f:	48 8b 38             	mov    (%rax),%rdi
  40aca2:	48 83 ef 18          	sub    $0x18,%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40aca6:	48 3b 3d b3 92 20 00 	cmp    0x2092b3(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40acad:	74 e3                	je     40ac92 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x1e2>
  40acaf:	48 8d 74 24 1f       	lea    0x1f(%rsp),%rsi
  40acb4:	e8 3f 96 ff ff       	callq  4042f8 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.2>
  40acb9:	eb d7                	jmp    40ac92 <_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_+0x1e2>
  40acbb:	48 89 c3             	mov    %rax,%rbx
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
	  }
	__catch(...)
  40acbe:	e8 bd 93 ff ff       	callq  404080 <__cxa_end_catch@plt>
  40acc3:	48 89 df             	mov    %rbx,%rdi
  40acc6:	e8 d5 94 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40accb:	90                   	nop
  40accc:	90                   	nop
  40accd:	90                   	nop
  40acce:	90                   	nop
  40accf:	90                   	nop

000000000040acd0 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E>:

#if __cplusplus >= 201103L
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
  40acd0:	41 56                	push   %r14
  40acd2:	41 55                	push   %r13
  40acd4:	41 54                	push   %r12
  40acd6:	55                   	push   %rbp
  40acd7:	49 89 d4             	mov    %rdx,%r12
  40acda:	53                   	push   %rbx
  40acdb:	48 89 cd             	mov    %rcx,%rbp
  40acde:	48 89 fb             	mov    %rdi,%rbx
  40ace1:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
  40ace5:	48 83 ec 10          	sub    $0x10,%rsp
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
			    || _M_impl._M_key_compare(_S_key(__z),
						      _S_key(__p)));
  40ace9:	48 85 f6             	test   %rsi,%rsi
  40acec:	74 2a                	je     40ad18 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E+0x48>
  40acee:	bf 01 00 00 00       	mov    $0x1,%edi

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
  40acf3:	4c 89 e2             	mov    %r12,%rdx
  40acf6:	48 89 ee             	mov    %rbp,%rsi
  40acf9:	e8 22 92 ff ff       	callq  403f20 <_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_@plt>
				    this->_M_impl._M_header);
      ++_M_impl._M_node_count;
  40acfe:	48 83 43 28 01       	addq   $0x1,0x28(%rbx)
      return iterator(__z);
    }
  40ad03:	48 83 c4 10          	add    $0x10,%rsp
  40ad07:	48 89 e8             	mov    %rbp,%rax
  40ad0a:	5b                   	pop    %rbx
  40ad0b:	5d                   	pop    %rbp
  40ad0c:	41 5c                	pop    %r12
  40ad0e:	41 5d                	pop    %r13
  40ad10:	41 5e                	pop    %r14
  40ad12:	c3                   	retq   
  40ad13:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
			    || _M_impl._M_key_compare(_S_key(__z),
						      _S_key(__p)));
  40ad18:	48 39 ca             	cmp    %rcx,%rdx
  40ad1b:	74 d1                	je     40acee <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E+0x1e>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40ad1d:	48 8b 72 20          	mov    0x20(%rdx),%rsi
  40ad21:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  40ad25:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40ad2a:	4c 8b 6f e8          	mov    -0x18(%rdi),%r13
  40ad2e:	4c 8b 76 e8          	mov    -0x18(%rsi),%r14
  40ad32:	4c 89 ea             	mov    %r13,%rdx
  40ad35:	4d 39 ee             	cmp    %r13,%r14
  40ad38:	49 0f 46 d6          	cmovbe %r14,%rdx
  40ad3c:	e8 af 92 ff ff       	callq  403ff0 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
  40ad41:	85 c0                	test   %eax,%eax
  40ad43:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  40ad48:	75 1a                	jne    40ad64 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E+0x94>
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);
  40ad4a:	4d 29 f5             	sub    %r14,%r13

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
  40ad4d:	31 ff                	xor    %edi,%edi
  40ad4f:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  40ad56:	7f 9b                	jg     40acf3 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E+0x23>
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
  40ad58:	49 81 fd 00 00 00 80 	cmp    $0xffffffff80000000,%r13
  40ad5f:	7c 8d                	jl     40acee <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E+0x1e>
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
  40ad61:	44 89 e8             	mov    %r13d,%eax
  40ad64:	c1 e8 1f             	shr    $0x1f,%eax
  40ad67:	89 c7                	mov    %eax,%edi
  40ad69:	eb 88                	jmp    40acf3 <_ZNSt8_Rb_treeISsSt4pairIKSsSsESt10_Select1stIS2_ESt4lessISsESaIS2_EE14_M_insert_nodeEPSt18_Rb_tree_node_baseSA_PSt13_Rb_tree_nodeIS2_E+0x23>
  40ad6b:	90                   	nop
  40ad6c:	90                   	nop
  40ad6d:	90                   	nop
  40ad6e:	90                   	nop
  40ad6f:	90                   	nop

000000000040ad70 <_ZN6rocket10ConnectionD1Ev>:
	, ip_(ip)
	, port_(port)
	, flow_(flow)
{ }

Connection::~Connection() {
  40ad70:	48 8b 05 b1 91 20 00 	mov    0x2091b1(%rip),%rax        # 613f28 <_DYNAMIC+0x2a0>
  40ad77:	48 83 c0 10          	add    $0x10,%rax
  40ad7b:	48 89 07             	mov    %rax,(%rdi)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40ad7e:	48 8b 47 10          	mov    0x10(%rdi),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40ad82:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40ad86:	48 3b 3d d3 91 20 00 	cmp    0x2091d3(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40ad8d:	75 01                	jne    40ad90 <_ZN6rocket10ConnectionD1Ev+0x20>
}
  40ad8f:	c3                   	retq   
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40ad90:	48 83 3d e0 91 20 00 	cmpq   $0x0,0x2091e0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40ad97:	00 
  40ad98:	74 26                	je     40adc0 <_ZN6rocket10ConnectionD1Ev+0x50>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40ad9a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40ad9f:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40ada4:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40ada6:	85 c0                	test   %eax,%eax
  40ada8:	7f e5                	jg     40ad8f <_ZN6rocket10ConnectionD1Ev+0x1f>
	, ip_(ip)
	, port_(port)
	, flow_(flow)
{ }

Connection::~Connection() {
  40adaa:	48 83 ec 18          	sub    $0x18,%rsp
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40adae:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40adb3:	e8 b8 8f ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
}
  40adb8:	48 83 c4 18          	add    $0x18,%rsp
  40adbc:	c3                   	retq   
  40adbd:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40adc0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40adc3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40adc6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40adc9:	89 d0                	mov    %edx,%eax
  40adcb:	eb d9                	jmp    40ada6 <_ZN6rocket10ConnectionD1Ev+0x36>
  40adcd:	90                   	nop
  40adce:	66 90                	xchg   %ax,%ax

000000000040add0 <_ZN6rocket10ConnectionD0Ev>:
	, ip_(ip)
	, port_(port)
	, flow_(flow)
{ }

Connection::~Connection() {
  40add0:	53                   	push   %rbx
  40add1:	48 89 fb             	mov    %rdi,%rbx
}
  40add4:	e8 97 ff ff ff       	callq  40ad70 <_ZN6rocket10ConnectionD1Ev>
  40add9:	48 89 df             	mov    %rbx,%rdi
  40addc:	5b                   	pop    %rbx
  40addd:	e9 ce 8d ff ff       	jmpq   403bb0 <_ZdlPv@plt>
  40ade2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40ade9:	1f 84 00 00 00 00 00 

000000000040adf0 <_ZN6rocket10Connection5WriteEjPKcm>:

int Connection::Write(unsigned flow, const char* buf, size_t len) {
  40adf0:	41 55                	push   %r13
  40adf2:	41 54                	push   %r12
  40adf4:	41 89 f5             	mov    %esi,%r13d
  40adf7:	55                   	push   %rbp
  40adf8:	53                   	push   %rbx
  40adf9:	49 89 fc             	mov    %rdi,%r12
  40adfc:	48 89 cb             	mov    %rcx,%rbx
  40adff:	48 89 d5             	mov    %rdx,%rbp
  40ae02:	48 83 ec 18          	sub    $0x18,%rsp
    LOG_DEBUG("Connection::Write flow=%u, len=%d", flow, len);
  40ae06:	e8 25 0d 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40ae0b:	48 83 ec 08          	sub    $0x8,%rsp
  40ae0f:	4c 8b 10             	mov    (%rax),%r10
  40ae12:	31 f6                	xor    %esi,%esi
  40ae14:	53                   	push   %rbx
  40ae15:	48 89 c7             	mov    %rax,%rdi
  40ae18:	45 89 e9             	mov    %r13d,%r9d
  40ae1b:	31 c0                	xor    %eax,%eax
  40ae1d:	4c 8d 05 cc 56 00 00 	lea    0x56cc(%rip),%r8        # 4104f0 <_ZStL19piecewise_construct+0xd4>
  40ae24:	b9 16 00 00 00       	mov    $0x16,%ecx
  40ae29:	48 8d 15 e2 56 00 00 	lea    0x56e2(%rip),%rdx        # 410512 <_ZStL19piecewise_construct+0xf6>
  40ae30:	41 ff 52 20          	callq  *0x20(%r10)
    int ret = -1;
    int write_size = 0;
  40ae34:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%rsp)
  40ae3b:	00 
    ret = BaseSocket::nbWrite(fd_, buf, len, &write_size);
  40ae3c:	41 8b 7c 24 08       	mov    0x8(%r12),%edi
  40ae41:	48 89 ee             	mov    %rbp,%rsi
  40ae44:	58                   	pop    %rax
  40ae45:	5a                   	pop    %rdx
  40ae46:	89 da                	mov    %ebx,%edx
  40ae48:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  40ae4d:	e8 de 47 00 00       	callq  40f630 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi>
  40ae52:	0f b6 d8             	movzbl %al,%ebx
    if (ret) {
  40ae55:	85 db                	test   %ebx,%ebx
  40ae57:	75 37                	jne    40ae90 <_ZN6rocket10Connection5WriteEjPKcm+0xa0>
    	LOG_DEBUG("Write nbWrite success");
    } else {
    	LOG_ERROR("Write nbWrite error");
  40ae59:	e8 d2 0c 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40ae5e:	4c 8b 08             	mov    (%rax),%r9
  40ae61:	48 89 c7             	mov    %rax,%rdi
  40ae64:	4c 8d 05 cb 56 00 00 	lea    0x56cb(%rip),%r8        # 410536 <_ZStL19piecewise_construct+0x11a>
  40ae6b:	31 c0                	xor    %eax,%eax
  40ae6d:	b9 1d 00 00 00       	mov    $0x1d,%ecx
  40ae72:	48 8d 15 99 56 00 00 	lea    0x5699(%rip),%rdx        # 410512 <_ZStL19piecewise_construct+0xf6>
  40ae79:	be 03 00 00 00       	mov    $0x3,%esi
  40ae7e:	41 ff 51 20          	callq  *0x20(%r9)
    }
    return ret;
}	
  40ae82:	48 83 c4 18          	add    $0x18,%rsp
  40ae86:	89 d8                	mov    %ebx,%eax
  40ae88:	5b                   	pop    %rbx
  40ae89:	5d                   	pop    %rbp
  40ae8a:	41 5c                	pop    %r12
  40ae8c:	41 5d                	pop    %r13
  40ae8e:	c3                   	retq   
  40ae8f:	90                   	nop
    LOG_DEBUG("Connection::Write flow=%u, len=%d", flow, len);
    int ret = -1;
    int write_size = 0;
    ret = BaseSocket::nbWrite(fd_, buf, len, &write_size);
    if (ret) {
    	LOG_DEBUG("Write nbWrite success");
  40ae90:	e8 9b 0c 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40ae95:	4c 8b 08             	mov    (%rax),%r9
  40ae98:	48 89 c7             	mov    %rax,%rdi
  40ae9b:	4c 8d 05 7e 56 00 00 	lea    0x567e(%rip),%r8        # 410520 <_ZStL19piecewise_construct+0x104>
  40aea2:	31 c0                	xor    %eax,%eax
  40aea4:	b9 1b 00 00 00       	mov    $0x1b,%ecx
  40aea9:	48 8d 15 62 56 00 00 	lea    0x5662(%rip),%rdx        # 410512 <_ZStL19piecewise_construct+0xf6>
  40aeb0:	31 f6                	xor    %esi,%esi
  40aeb2:	41 ff 51 20          	callq  *0x20(%r9)
    } else {
    	LOG_ERROR("Write nbWrite error");
    }
    return ret;
}	
  40aeb6:	48 83 c4 18          	add    $0x18,%rsp
  40aeba:	89 d8                	mov    %ebx,%eax
  40aebc:	5b                   	pop    %rbx
  40aebd:	5d                   	pop    %rbp
  40aebe:	41 5c                	pop    %r12
  40aec0:	41 5d                	pop    %r13
  40aec2:	c3                   	retq   
  40aec3:	90                   	nop
  40aec4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40aecb:	00 00 00 00 00 

000000000040aed0 <_ZN6rocket10ConnectionC1EiRKSsij>:
                       int port, 
                       unsigned flow)
	: fd_(fd)
	, ip_(ip)
	, port_(port)
	, flow_(flow)
  40aed0:	48 8b 05 51 90 20 00 	mov    0x209051(%rip),%rax        # 613f28 <_DYNAMIC+0x2a0>
#include "logger.h"


namespace rocket {

Connection::Connection(int fd, 
  40aed7:	41 54                	push   %r12
  40aed9:	41 89 cc             	mov    %ecx,%r12d
  40aedc:	55                   	push   %rbp
  40aedd:	53                   	push   %rbx
  40aede:	48 89 fb             	mov    %rdi,%rbx
                       int port, 
                       unsigned flow)
	: fd_(fd)
	, ip_(ip)
	, port_(port)
	, flow_(flow)
  40aee1:	89 77 08             	mov    %esi,0x8(%rdi)
  40aee4:	48 8d 7f 10          	lea    0x10(%rdi),%rdi
#include "logger.h"


namespace rocket {

Connection::Connection(int fd, 
  40aee8:	44 89 c5             	mov    %r8d,%ebp
                       int port, 
                       unsigned flow)
	: fd_(fd)
	, ip_(ip)
	, port_(port)
	, flow_(flow)
  40aeeb:	48 83 c0 10          	add    $0x10,%rax
  40aeef:	48 89 d6             	mov    %rdx,%rsi
  40aef2:	48 89 47 f0          	mov    %rax,-0x10(%rdi)
  40aef6:	e8 c5 8d ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  40aefb:	44 89 63 18          	mov    %r12d,0x18(%rbx)
  40aeff:	89 6b 1c             	mov    %ebp,0x1c(%rbx)
{ }
  40af02:	5b                   	pop    %rbx
  40af03:	5d                   	pop    %rbp
  40af04:	41 5c                	pop    %r12
  40af06:	c3                   	retq   
  40af07:	90                   	nop
  40af08:	90                   	nop
  40af09:	90                   	nop
  40af0a:	90                   	nop
  40af0b:	90                   	nop
  40af0c:	90                   	nop
  40af0d:	90                   	nop
  40af0e:	90                   	nop
  40af0f:	90                   	nop

000000000040af10 <_ZN6rocket10Connection6get_fdEv>:
{
public:
    Connection(int fd = -1, const std::string& ip = "", int port = 0, unsigned flow = 0);
    virtual ~Connection();

    int get_fd() { return fd_; }
  40af10:	8b 47 08             	mov    0x8(%rdi),%eax
  40af13:	c3                   	retq   
  40af14:	90                   	nop
  40af15:	90                   	nop
  40af16:	90                   	nop
  40af17:	90                   	nop
  40af18:	90                   	nop
  40af19:	90                   	nop
  40af1a:	90                   	nop
  40af1b:	90                   	nop
  40af1c:	90                   	nop
  40af1d:	90                   	nop
  40af1e:	90                   	nop
  40af1f:	90                   	nop

000000000040af20 <_ZN6rocket10Connection8get_portEv>:

    virtual std::string get_ip() { return ip_; }

    virtual int get_port() { return port_; }
  40af20:	8b 47 18             	mov    0x18(%rdi),%eax
  40af23:	c3                   	retq   
  40af24:	90                   	nop
  40af25:	90                   	nop
  40af26:	90                   	nop
  40af27:	90                   	nop
  40af28:	90                   	nop
  40af29:	90                   	nop
  40af2a:	90                   	nop
  40af2b:	90                   	nop
  40af2c:	90                   	nop
  40af2d:	90                   	nop
  40af2e:	90                   	nop
  40af2f:	90                   	nop

000000000040af30 <_ZN6rocket10Connection6get_ipEv>:
    Connection(int fd = -1, const std::string& ip = "", int port = 0, unsigned flow = 0);
    virtual ~Connection();

    int get_fd() { return fd_; }

    virtual std::string get_ip() { return ip_; }
  40af30:	53                   	push   %rbx
  40af31:	48 83 c6 10          	add    $0x10,%rsi
  40af35:	48 89 fb             	mov    %rdi,%rbx
  40af38:	e8 83 8d ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  40af3d:	48 89 d8             	mov    %rbx,%rax
  40af40:	5b                   	pop    %rbx
  40af41:	c3                   	retq   
  40af42:	90                   	nop
  40af43:	90                   	nop
  40af44:	90                   	nop
  40af45:	90                   	nop
  40af46:	90                   	nop
  40af47:	90                   	nop
  40af48:	90                   	nop
  40af49:	90                   	nop
  40af4a:	90                   	nop
  40af4b:	90                   	nop
  40af4c:	90                   	nop
  40af4d:	90                   	nop
  40af4e:	90                   	nop
  40af4f:	90                   	nop

000000000040af50 <_ZN6rocket12EpollWrapperC1Ev>:
  40af50:	48 8b 05 51 90 20 00 	mov    0x209051(%rip),%rax        # 613fa8 <_DYNAMIC+0x320>
  40af57:	53                   	push   %rbx
  40af58:	48 89 fb             	mov    %rdi,%rbx
  40af5b:	c7 47 08 ff ff ff ff 	movl   $0xffffffff,0x8(%rdi)
  40af62:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
  40af69:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
  40af70:	48 83 c0 10          	add    $0x10,%rax
  40af74:	48 89 07             	mov    %rax,(%rdi)
  40af77:	bf c0 d4 01 00       	mov    $0x1d4c0,%edi
  40af7c:	e8 cf 8c ff ff       	callq  403c50 <malloc@plt>
  40af81:	48 85 c0             	test   %rax,%rax
  40af84:	48 89 43 10          	mov    %rax,0x10(%rbx)
  40af88:	74 10                	je     40af9a <_ZN6rocket12EpollWrapperC1Ev+0x4a>
  40af8a:	5b                   	pop    %rbx
  40af8b:	ba c0 d4 01 00       	mov    $0x1d4c0,%edx
  40af90:	31 f6                	xor    %esi,%esi
  40af92:	48 89 c7             	mov    %rax,%rdi
  40af95:	e9 26 8b ff ff       	jmpq   403ac0 <memset@plt>
  40af9a:	e8 91 0b 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40af9f:	4c 8b 08             	mov    (%rax),%r9
  40afa2:	48 89 c7             	mov    %rax,%rdi
  40afa5:	4c 8d 05 ca 55 00 00 	lea    0x55ca(%rip),%r8        # 410576 <_ZTSN6rocket10ConnectionE+0x16>
  40afac:	b9 13 00 00 00       	mov    $0x13,%ecx
  40afb1:	48 8d 15 d8 55 00 00 	lea    0x55d8(%rip),%rdx        # 410590 <_ZTSN6rocket10ConnectionE+0x30>
  40afb8:	be 03 00 00 00       	mov    $0x3,%esi
  40afbd:	31 c0                	xor    %eax,%eax
  40afbf:	41 ff 51 20          	callq  *0x20(%r9)
  40afc3:	bf 01 00 00 00       	mov    $0x1,%edi
  40afc8:	e8 03 8c ff ff       	callq  403bd0 <exit@plt>
  40afcd:	90                   	nop
  40afce:	66 90                	xchg   %ax,%ax

000000000040afd0 <_ZN6rocket12EpollWrapper12CreateHandleEv>:
  40afd0:	53                   	push   %rbx
  40afd1:	48 89 fb             	mov    %rdi,%rbx
  40afd4:	bf 10 27 00 00       	mov    $0x2710,%edi
  40afd9:	e8 92 8b ff ff       	callq  403b70 <epoll_create@plt>
  40afde:	89 c2                	mov    %eax,%edx
  40afe0:	89 43 08             	mov    %eax,0x8(%rbx)
  40afe3:	b8 01 00 00 00       	mov    $0x1,%eax
  40afe8:	83 fa ff             	cmp    $0xffffffff,%edx
  40afeb:	74 03                	je     40aff0 <_ZN6rocket12EpollWrapper12CreateHandleEv+0x20>
  40afed:	5b                   	pop    %rbx
  40afee:	c3                   	retq   
  40afef:	90                   	nop
  40aff0:	e8 3b 0b 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40aff5:	4c 8b 08             	mov    (%rax),%r9
  40aff8:	48 89 c7             	mov    %rax,%rdi
  40affb:	4c 8d 05 9f 55 00 00 	lea    0x559f(%rip),%r8        # 4105a1 <_ZTSN6rocket10ConnectionE+0x41>
  40b002:	31 c0                	xor    %eax,%eax
  40b004:	b9 23 00 00 00       	mov    $0x23,%ecx
  40b009:	48 8d 15 80 55 00 00 	lea    0x5580(%rip),%rdx        # 410590 <_ZTSN6rocket10ConnectionE+0x30>
  40b010:	be 03 00 00 00       	mov    $0x3,%esi
  40b015:	41 ff 51 20          	callq  *0x20(%r9)
  40b019:	31 c0                	xor    %eax,%eax
  40b01b:	5b                   	pop    %rbx
  40b01c:	c3                   	retq   
  40b01d:	90                   	nop
  40b01e:	66 90                	xchg   %ax,%ax

000000000040b020 <_ZN6rocket12EpollWrapper13DestroyHandleEv>:
  40b020:	48 89 fa             	mov    %rdi,%rdx
  40b023:	8b 7f 08             	mov    0x8(%rdi),%edi
  40b026:	31 c0                	xor    %eax,%eax
  40b028:	85 ff                	test   %edi,%edi
  40b02a:	78 16                	js     40b042 <_ZN6rocket12EpollWrapper13DestroyHandleEv+0x22>
  40b02c:	53                   	push   %rbx
  40b02d:	48 89 d3             	mov    %rdx,%rbx
  40b030:	e8 cb 8a ff ff       	callq  403b00 <close@plt>
  40b035:	c7 43 08 ff ff ff ff 	movl   $0xffffffff,0x8(%rbx)
  40b03c:	b8 01 00 00 00       	mov    $0x1,%eax
  40b041:	5b                   	pop    %rbx
  40b042:	f3 c3                	repz retq 
  40b044:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40b04b:	00 00 00 00 00 

000000000040b050 <_ZN6rocket12EpollWrapperD1Ev>:
  40b050:	48 8b 05 51 8f 20 00 	mov    0x208f51(%rip),%rax        # 613fa8 <_DYNAMIC+0x320>
  40b057:	53                   	push   %rbx
  40b058:	48 89 fb             	mov    %rdi,%rbx
  40b05b:	48 83 c0 10          	add    $0x10,%rax
  40b05f:	48 89 07             	mov    %rax,(%rdi)
  40b062:	e8 b9 ff ff ff       	callq  40b020 <_ZN6rocket12EpollWrapper13DestroyHandleEv>
  40b067:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  40b06b:	5b                   	pop    %rbx
  40b06c:	e9 cf 8c ff ff       	jmpq   403d40 <free@plt>
  40b071:	90                   	nop
  40b072:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40b079:	1f 84 00 00 00 00 00 

000000000040b080 <_ZN6rocket12EpollWrapperD0Ev>:
  40b080:	53                   	push   %rbx
  40b081:	48 89 fb             	mov    %rdi,%rbx
  40b084:	e8 c7 ff ff ff       	callq  40b050 <_ZN6rocket12EpollWrapperD1Ev>
  40b089:	48 89 df             	mov    %rbx,%rdi
  40b08c:	5b                   	pop    %rbx
  40b08d:	e9 1e 8b ff ff       	jmpq   403bb0 <_ZdlPv@plt>
  40b092:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40b099:	1f 84 00 00 00 00 00 

000000000040b0a0 <_ZN6rocket12EpollWrapper3ctlEiij>:
  40b0a0:	48 83 ec 18          	sub    $0x18,%rsp
  40b0a4:	83 fe 02             	cmp    $0x2,%esi
  40b0a7:	89 54 24 04          	mov    %edx,0x4(%rsp)
  40b0ab:	74 07                	je     40b0b4 <_ZN6rocket12EpollWrapper3ctlEiij+0x14>
  40b0ad:	c7 04 24 00 00 00 80 	movl   $0x80000000,(%rsp)
  40b0b4:	f6 c1 01             	test   $0x1,%cl
  40b0b7:	74 04                	je     40b0bd <_ZN6rocket12EpollWrapper3ctlEiij+0x1d>
  40b0b9:	83 0c 24 01          	orl    $0x1,(%rsp)
  40b0bd:	83 e1 02             	and    $0x2,%ecx
  40b0c0:	74 04                	je     40b0c6 <_ZN6rocket12EpollWrapper3ctlEiij+0x26>
  40b0c2:	83 0c 24 04          	orl    $0x4,(%rsp)
  40b0c6:	8b 7f 08             	mov    0x8(%rdi),%edi
  40b0c9:	48 89 e1             	mov    %rsp,%rcx
  40b0cc:	e8 7f 8d ff ff       	callq  403e50 <epoll_ctl@plt>
  40b0d1:	48 83 c4 18          	add    $0x18,%rsp
  40b0d5:	c3                   	retq   
  40b0d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b0dd:	00 00 00 

000000000040b0e0 <_ZN6rocket12EpollWrapper10AddFdEventEij>:
  40b0e0:	53                   	push   %rbx
  40b0e1:	89 d1                	mov    %edx,%ecx
  40b0e3:	89 f3                	mov    %esi,%ebx
  40b0e5:	89 f2                	mov    %esi,%edx
  40b0e7:	be 01 00 00 00       	mov    $0x1,%esi
  40b0ec:	e8 af ff ff ff       	callq  40b0a0 <_ZN6rocket12EpollWrapper3ctlEiij>
  40b0f1:	83 f8 ff             	cmp    $0xffffffff,%eax
  40b0f4:	b9 01 00 00 00       	mov    $0x1,%ecx
  40b0f9:	74 05                	je     40b100 <_ZN6rocket12EpollWrapper10AddFdEventEij+0x20>
  40b0fb:	89 c8                	mov    %ecx,%eax
  40b0fd:	5b                   	pop    %rbx
  40b0fe:	c3                   	retq   
  40b0ff:	90                   	nop
  40b100:	48 8d 3d ad 54 00 00 	lea    0x54ad(%rip),%rdi        # 4105b4 <_ZTSN6rocket10ConnectionE+0x54>
  40b107:	e8 24 90 ff ff       	callq  404130 <perror@plt>
  40b10c:	e8 1f 0a 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b111:	4c 8b 10             	mov    (%rax),%r10
  40b114:	41 89 d9             	mov    %ebx,%r9d
  40b117:	b9 37 00 00 00       	mov    $0x37,%ecx
  40b11c:	48 89 c7             	mov    %rax,%rdi
  40b11f:	4c 8d 05 99 54 00 00 	lea    0x5499(%rip),%r8        # 4105bf <_ZTSN6rocket10ConnectionE+0x5f>
  40b126:	31 c0                	xor    %eax,%eax
  40b128:	48 8d 15 61 54 00 00 	lea    0x5461(%rip),%rdx        # 410590 <_ZTSN6rocket10ConnectionE+0x30>
  40b12f:	be 03 00 00 00       	mov    $0x3,%esi
  40b134:	41 ff 52 20          	callq  *0x20(%r10)
  40b138:	31 c9                	xor    %ecx,%ecx
  40b13a:	89 c8                	mov    %ecx,%eax
  40b13c:	5b                   	pop    %rbx
  40b13d:	c3                   	retq   
  40b13e:	66 90                	xchg   %ax,%ax

000000000040b140 <_ZN6rocket12EpollWrapper10DelFdEventEij>:
  40b140:	48 83 ec 08          	sub    $0x8,%rsp
  40b144:	89 d1                	mov    %edx,%ecx
  40b146:	89 f2                	mov    %esi,%edx
  40b148:	be 02 00 00 00       	mov    $0x2,%esi
  40b14d:	e8 4e ff ff ff       	callq  40b0a0 <_ZN6rocket12EpollWrapper3ctlEiij>
  40b152:	85 c0                	test   %eax,%eax
  40b154:	0f 95 c0             	setne  %al
  40b157:	48 83 c4 08          	add    $0x8,%rsp
  40b15b:	0f b6 c0             	movzbl %al,%eax
  40b15e:	f7 d8                	neg    %eax
  40b160:	c3                   	retq   
  40b161:	90                   	nop
  40b162:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40b169:	1f 84 00 00 00 00 00 

000000000040b170 <_ZN6rocket12EpollWrapper13ModifyFdEventEij>:
  40b170:	48 83 ec 08          	sub    $0x8,%rsp
  40b174:	89 d1                	mov    %edx,%ecx
  40b176:	89 f2                	mov    %esi,%edx
  40b178:	be 03 00 00 00       	mov    $0x3,%esi
  40b17d:	e8 1e ff ff ff       	callq  40b0a0 <_ZN6rocket12EpollWrapper3ctlEiij>
  40b182:	85 c0                	test   %eax,%eax
  40b184:	0f 94 c0             	sete   %al
  40b187:	48 83 c4 08          	add    $0x8,%rsp
  40b18b:	0f b6 c0             	movzbl %al,%eax
  40b18e:	c3                   	retq   
  40b18f:	90                   	nop

000000000040b190 <_ZN6rocket12EpollWrapper4PollEi>:
  40b190:	53                   	push   %rbx
  40b191:	89 f1                	mov    %esi,%ecx
  40b193:	48 89 fb             	mov    %rdi,%rbx
  40b196:	48 8b 77 10          	mov    0x10(%rdi),%rsi
  40b19a:	8b 7f 08             	mov    0x8(%rdi),%edi
  40b19d:	ba 10 27 00 00       	mov    $0x2710,%edx
  40b1a2:	e8 e9 8d ff ff       	callq  403f90 <epoll_wait@plt>
  40b1a7:	89 43 0c             	mov    %eax,0xc(%rbx)
  40b1aa:	5b                   	pop    %rbx
  40b1ab:	c3                   	retq   
  40b1ac:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040b1b0 <_ZN6rocket12EpollWrapper11GetFdEventsEiRiRj>:
  40b1b0:	39 77 0c             	cmp    %esi,0xc(%rdi)
  40b1b3:	7c 2b                	jl     40b1e0 <_ZN6rocket12EpollWrapper11GetFdEventsEiRiRj+0x30>
  40b1b5:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
  40b1bb:	7f 23                	jg     40b1e0 <_ZN6rocket12EpollWrapper11GetFdEventsEiRiRj+0x30>
  40b1bd:	48 8b 47 10          	mov    0x10(%rdi),%rax
  40b1c1:	48 63 f6             	movslq %esi,%rsi
  40b1c4:	48 8d 34 76          	lea    (%rsi,%rsi,2),%rsi
  40b1c8:	48 8d 04 b0          	lea    (%rax,%rsi,4),%rax
  40b1cc:	8b 70 04             	mov    0x4(%rax),%esi
  40b1cf:	89 32                	mov    %esi,(%rdx)
  40b1d1:	8b 00                	mov    (%rax),%eax
  40b1d3:	89 01                	mov    %eax,(%rcx)
  40b1d5:	31 c0                	xor    %eax,%eax
  40b1d7:	c3                   	retq   
  40b1d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b1df:	00 
  40b1e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40b1e5:	c3                   	retq   
  40b1e6:	90                   	nop
  40b1e7:	90                   	nop
  40b1e8:	90                   	nop
  40b1e9:	90                   	nop
  40b1ea:	90                   	nop
  40b1eb:	90                   	nop
  40b1ec:	90                   	nop
  40b1ed:	90                   	nop
  40b1ee:	90                   	nop
  40b1ef:	90                   	nop

000000000040b1f0 <_ZN6rocket15EventDispatcher4initEv>:

EventDispatcher::~EventDispatcher() {

}

int EventDispatcher::init() {
  40b1f0:	55                   	push   %rbp
  40b1f1:	53                   	push   %rbx
  40b1f2:	48 89 fd             	mov    %rdi,%rbp
    LOG_INFO("EventDispatcher init 1");
	int ret = 0;
	if (!epoll_.CreateHandle()) {
  40b1f5:	48 8d 5d 10          	lea    0x10(%rbp),%rbx

EventDispatcher::~EventDispatcher() {

}

int EventDispatcher::init() {
  40b1f9:	48 83 ec 08          	sub    $0x8,%rsp
    LOG_INFO("EventDispatcher init 1");
  40b1fd:	e8 2e 09 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b202:	4c 8b 08             	mov    (%rax),%r9
  40b205:	48 89 c7             	mov    %rax,%rdi
  40b208:	4c 8d 05 e9 53 00 00 	lea    0x53e9(%rip),%r8        # 4105f8 <_ZTSN6rocket12EpollWrapperE+0x18>
  40b20f:	31 c0                	xor    %eax,%eax
  40b211:	b9 21 00 00 00       	mov    $0x21,%ecx
  40b216:	48 8d 15 f2 53 00 00 	lea    0x53f2(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b21d:	be 01 00 00 00       	mov    $0x1,%esi
  40b222:	41 ff 51 20          	callq  *0x20(%r9)
	int ret = 0;
	if (!epoll_.CreateHandle()) {
  40b226:	48 89 df             	mov    %rbx,%rdi
  40b229:	e8 a2 fd ff ff       	callq  40afd0 <_ZN6rocket12EpollWrapper12CreateHandleEv>
  40b22e:	84 c0                	test   %al,%al
  40b230:	74 4e                	je     40b280 <_ZN6rocket15EventDispatcher4initEv+0x90>
        perror("epoll_.CreateHandle()");
        return -1;
    }
        
	if(!epoll_.AddFdEvent(listenfd_, EpollWrapper::READ_READY)) {
  40b232:	8b 75 08             	mov    0x8(%rbp),%esi
  40b235:	ba 01 00 00 00       	mov    $0x1,%edx
  40b23a:	48 89 df             	mov    %rbx,%rdi
  40b23d:	e8 9e fe ff ff       	callq  40b0e0 <_ZN6rocket12EpollWrapper10AddFdEventEij>
  40b242:	84 c0                	test   %al,%al
  40b244:	74 52                	je     40b298 <_ZN6rocket15EventDispatcher4initEv+0xa8>
        perror("epoll_.AddFdEvent()");
        return -1;
    }

    LOG_INFO("EventDispatcher init 2");  
  40b246:	e8 e5 08 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b24b:	4c 8b 08             	mov    (%rax),%r9
  40b24e:	48 89 c7             	mov    %rax,%rdi
  40b251:	4c 8d 05 f5 53 00 00 	lea    0x53f5(%rip),%r8        # 41064d <_ZTSN6rocket12EpollWrapperE+0x6d>
  40b258:	31 c0                	xor    %eax,%eax
  40b25a:	b9 2d 00 00 00       	mov    $0x2d,%ecx
  40b25f:	48 8d 15 a9 53 00 00 	lea    0x53a9(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b266:	be 01 00 00 00       	mov    $0x1,%esi
  40b26b:	41 ff 51 20          	callq  *0x20(%r9)
	return ret;
  40b26f:	31 c0                	xor    %eax,%eax
}
  40b271:	48 83 c4 08          	add    $0x8,%rsp
  40b275:	5b                   	pop    %rbx
  40b276:	5d                   	pop    %rbp
  40b277:	c3                   	retq   
  40b278:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b27f:	00 

int EventDispatcher::init() {
    LOG_INFO("EventDispatcher init 1");
	int ret = 0;
	if (!epoll_.CreateHandle()) {
        perror("epoll_.CreateHandle()");
  40b280:	48 8d 3d 9c 53 00 00 	lea    0x539c(%rip),%rdi        # 410623 <_ZTSN6rocket12EpollWrapperE+0x43>
  40b287:	e8 a4 8e ff ff       	callq  404130 <perror@plt>
        return -1;
  40b28c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40b291:	eb de                	jmp    40b271 <_ZN6rocket15EventDispatcher4initEv+0x81>
  40b293:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    }
        
	if(!epoll_.AddFdEvent(listenfd_, EpollWrapper::READ_READY)) {
        perror("epoll_.AddFdEvent()");
  40b298:	48 8d 3d 9a 53 00 00 	lea    0x539a(%rip),%rdi        # 410639 <_ZTSN6rocket12EpollWrapperE+0x59>
  40b29f:	e8 8c 8e ff ff       	callq  404130 <perror@plt>
        return -1;
  40b2a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40b2a9:	eb c6                	jmp    40b271 <_ZN6rocket15EventDispatcher4initEv+0x81>
  40b2ab:	90                   	nop
  40b2ac:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040b2b0 <_ZN6rocket15EventDispatcher13ProcessEventsEij>:
            ProcessEvents(fd, events);
		}
	}
}

void EventDispatcher::ProcessEvents(int fd, u_int events) {
  40b2b0:	55                   	push   %rbp
  40b2b1:	48 89 e5             	mov    %rsp,%rbp
  40b2b4:	41 57                	push   %r15
  40b2b6:	41 56                	push   %r14
  40b2b8:	41 55                	push   %r13
  40b2ba:	41 54                	push   %r12
  40b2bc:	41 89 f7             	mov    %esi,%r15d
  40b2bf:	53                   	push   %rbx
  40b2c0:	89 d3                	mov    %edx,%ebx
  40b2c2:	48 83 ec 28          	sub    $0x28,%rsp
    // handle read event
    if(epoll_.is_read(events)) {
  40b2c6:	f6 c2 01             	test   $0x1,%dl
  40b2c9:	74 10                	je     40b2db <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x2b>
        if (fd == listenfd_) {
  40b2cb:	3b 77 08             	cmp    0x8(%rdi),%esi
  40b2ce:	49 89 fc             	mov    %rdi,%r12
  40b2d1:	74 4d                	je     40b320 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x70>
                        return;
                    }
                } 
            } 
        } else {
            server_->ReadCallback(fd);
  40b2d3:	48 8b 3f             	mov    (%rdi),%rdi
  40b2d6:	e8 85 33 00 00       	callq  40e660 <_ZN6rocket6Server12ReadCallbackEi>
            */
        }
    }

    // handle write event
    if (epoll_.is_write(events)) {
  40b2db:	83 e3 04             	and    $0x4,%ebx
  40b2de:	74 2c                	je     40b30c <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x5c>
        LOG_ERROR("ProcessEvents WRITE EVENT, fd=%d", fd);
  40b2e0:	e8 4b 08 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b2e5:	4c 8b 10             	mov    (%rax),%r10
  40b2e8:	48 89 c7             	mov    %rax,%rdi
  40b2eb:	45 89 f9             	mov    %r15d,%r9d
  40b2ee:	4c 8d 05 43 54 00 00 	lea    0x5443(%rip),%r8        # 410738 <_ZTSN6rocket12EpollWrapperE+0x158>
  40b2f5:	b9 89 00 00 00       	mov    $0x89,%ecx
  40b2fa:	48 8d 15 0e 53 00 00 	lea    0x530e(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b301:	be 03 00 00 00       	mov    $0x3,%esi
  40b306:	31 c0                	xor    %eax,%eax
  40b308:	41 ff 52 20          	callq  *0x20(%r10)
    }
}
  40b30c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  40b310:	5b                   	pop    %rbx
  40b311:	41 5c                	pop    %r12
  40b313:	41 5d                	pop    %r13
  40b315:	41 5e                	pop    %r14
  40b317:	41 5f                	pop    %r15
  40b319:	5d                   	pop    %rbp
  40b31a:	c3                   	retq   
  40b31b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  40b320:	4c 8b 35 39 8c 20 00 	mov    0x208c39(%rip),%r14        # 613f60 <_DYNAMIC+0x2d8>
            // 每次poll 最多建立50个连接
            /*while (accept_cnt_tcp --)*/ {
                int port;
                std::string ip;
                int infd;
                infd = BaseSocket::accept(fd, ip, port);
  40b327:	48 8d 55 bc          	lea    -0x44(%rbp),%rdx
  40b32b:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  40b32f:	44 89 ff             	mov    %r15d,%edi
  40b332:	49 8d 46 18          	lea    0x18(%r14),%rax
  40b336:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  40b33a:	e8 51 42 00 00       	callq  40f590 <_ZN6rocket10BaseSocket6acceptEiRSsRi>
                if (infd == -1 && (errno == EAGAIN)) {
  40b33f:	83 f8 ff             	cmp    $0xffffffff,%eax
            // 每次poll 最多建立50个连接
            /*while (accept_cnt_tcp --)*/ {
                int port;
                std::string ip;
                int infd;
                infd = BaseSocket::accept(fd, ip, port);
  40b342:	41 89 c5             	mov    %eax,%r13d
                if (infd == -1 && (errno == EAGAIN)) {
  40b345:	0f 84 a5 00 00 00    	je     40b3f0 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x140>
                } else if (infd == -1) {
                    perror("accept error");
                    LOG_DEBUG("ProcessEvents READ EVENT, listenfd is readable, infd=%d, fd=%d",
                              infd, fd);
                } else {
                    LOG_DEBUG("ProcessEvents READ EVENT, infd=%d, fd=%d, port=%d, ip=%s",
  40b34b:	e8 e0 07 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b350:	4c 8b 10             	mov    (%rax),%r10
                              infd, fd, port, ip.c_str());
  40b353:	8b 55 bc             	mov    -0x44(%rbp),%edx
  40b356:	48 83 ec 08          	sub    $0x8,%rsp
  40b35a:	48 89 c7             	mov    %rax,%rdi
  40b35d:	ff 75 c0             	pushq  -0x40(%rbp)
  40b360:	45 89 e9             	mov    %r13d,%r9d
  40b363:	4c 8d 05 8e 53 00 00 	lea    0x538e(%rip),%r8        # 4106f8 <_ZTSN6rocket12EpollWrapperE+0x118>
  40b36a:	b9 59 00 00 00       	mov    $0x59,%ecx
  40b36f:	31 f6                	xor    %esi,%esi
  40b371:	52                   	push   %rdx
  40b372:	31 c0                	xor    %eax,%eax
  40b374:	41 57                	push   %r15
  40b376:	48 8d 15 92 52 00 00 	lea    0x5292(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b37d:	41 ff 52 20          	callq  *0x20(%r10)
  40b381:	48 83 c4 20          	add    $0x20,%rsp
                    BaseSocket::setNonBlocking(infd);
  40b385:	44 89 ef             	mov    %r13d,%edi
  40b388:	e8 13 41 00 00       	callq  40f4a0 <_ZN6rocket10BaseSocket14setNonBlockingEi>
                    if(!epoll_.AddFdEvent(infd, EpollWrapper::READ_READY)) {
  40b38d:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
  40b392:	ba 01 00 00 00       	mov    $0x1,%edx
  40b397:	44 89 ee             	mov    %r13d,%esi
  40b39a:	e8 41 fd ff ff       	callq  40b0e0 <_ZN6rocket12EpollWrapper10AddFdEventEij>
  40b39f:	84 c0                	test   %al,%al
  40b3a1:	0f 84 a9 00 00 00    	je     40b450 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x1a0>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40b3a7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40b3ab:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40b3af:	4c 39 f7             	cmp    %r14,%rdi
  40b3b2:	0f 84 23 ff ff ff    	je     40b2db <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x2b>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40b3b8:	48 83 3d b8 8b 20 00 	cmpq   $0x0,0x208bb8(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40b3bf:	00 
  40b3c0:	0f 84 04 01 00 00    	je     40b4ca <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x21a>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40b3c6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40b3cb:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40b3d0:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40b3d2:	85 c0                	test   %eax,%eax
  40b3d4:	0f 8f 01 ff ff ff    	jg     40b2db <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x2b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40b3da:	48 8d 75 bb          	lea    -0x45(%rbp),%rsi
  40b3de:	e8 8d 89 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40b3e3:	e9 f3 fe ff ff       	jmpq   40b2db <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x2b>
  40b3e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b3ef:	00 
            /*while (accept_cnt_tcp --)*/ {
                int port;
                std::string ip;
                int infd;
                infd = BaseSocket::accept(fd, ip, port);
                if (infd == -1 && (errno == EAGAIN)) {
  40b3f0:	e8 1b 8b ff ff       	callq  403f10 <__errno_location@plt>
  40b3f5:	8b 00                	mov    (%rax),%eax
  40b3f7:	83 f8 0b             	cmp    $0xb,%eax
  40b3fa:	74 ab                	je     40b3a7 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0xf7>
                    //break;
                } else if (infd == -1 && (errno == EINTR)) {
  40b3fc:	83 f8 04             	cmp    $0x4,%eax
  40b3ff:	74 a6                	je     40b3a7 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0xf7>
                    //continue;
                } else if (infd == -1) {
                    perror("accept error");
  40b401:	48 8d 3d 5c 52 00 00 	lea    0x525c(%rip),%rdi        # 410664 <_ZTSN6rocket12EpollWrapperE+0x84>
  40b408:	e8 23 8d ff ff       	callq  404130 <perror@plt>
                    LOG_DEBUG("ProcessEvents READ EVENT, listenfd is readable, infd=%d, fd=%d",
  40b40d:	e8 1e 07 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b412:	4c 8b 10             	mov    (%rax),%r10
                              infd, fd);
  40b415:	48 83 ec 08          	sub    $0x8,%rsp
  40b419:	48 89 c7             	mov    %rax,%rdi
  40b41c:	41 57                	push   %r15
  40b41e:	41 b9 ff ff ff ff    	mov    $0xffffffff,%r9d
  40b424:	4c 8d 05 8d 52 00 00 	lea    0x528d(%rip),%r8        # 4106b8 <_ZTSN6rocket12EpollWrapperE+0xd8>
  40b42b:	b9 56 00 00 00       	mov    $0x56,%ecx
  40b430:	48 8d 15 d8 51 00 00 	lea    0x51d8(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b437:	31 f6                	xor    %esi,%esi
  40b439:	31 c0                	xor    %eax,%eax
  40b43b:	41 ff 52 20          	callq  *0x20(%r10)
  40b43f:	58                   	pop    %rax
  40b440:	5a                   	pop    %rdx
  40b441:	e9 61 ff ff ff       	jmpq   40b3a7 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0xf7>
  40b446:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b44d:	00 00 00 
                } else {
                    LOG_DEBUG("ProcessEvents READ EVENT, infd=%d, fd=%d, port=%d, ip=%s",
                              infd, fd, port, ip.c_str());
                    BaseSocket::setNonBlocking(infd);
                    if(!epoll_.AddFdEvent(infd, EpollWrapper::READ_READY)) {
                        LOG_ERROR("ProcessEvents READ EVENT, infd=%d, fd=%d, port=%d, ip=%s",
  40b450:	e8 db 06 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b455:	4c 8b 10             	mov    (%rax),%r10
                                  infd, fd, port, ip.c_str());
  40b458:	8b 55 bc             	mov    -0x44(%rbp),%edx
  40b45b:	48 83 ec 08          	sub    $0x8,%rsp
  40b45f:	48 89 c7             	mov    %rax,%rdi
  40b462:	ff 75 c0             	pushq  -0x40(%rbp)
  40b465:	45 89 e9             	mov    %r13d,%r9d
  40b468:	4c 8d 05 89 52 00 00 	lea    0x5289(%rip),%r8        # 4106f8 <_ZTSN6rocket12EpollWrapperE+0x118>
  40b46f:	b9 5d 00 00 00       	mov    $0x5d,%ecx
  40b474:	be 03 00 00 00       	mov    $0x3,%esi
  40b479:	52                   	push   %rdx
  40b47a:	31 c0                	xor    %eax,%eax
  40b47c:	41 57                	push   %r15
  40b47e:	48 8d 15 8a 51 00 00 	lea    0x518a(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b485:	41 ff 52 20          	callq  *0x20(%r10)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40b489:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  40b48d:	48 83 c4 20          	add    $0x20,%rsp
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40b491:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40b495:	4c 39 f7             	cmp    %r14,%rdi
  40b498:	0f 84 6e fe ff ff    	je     40b30c <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x5c>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40b49e:	48 83 3d d2 8a 20 00 	cmpq   $0x0,0x208ad2(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40b4a5:	00 
  40b4a6:	74 32                	je     40b4da <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x22a>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40b4a8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40b4ad:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40b4b2:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40b4b4:	85 c0                	test   %eax,%eax
  40b4b6:	0f 8f 50 fe ff ff    	jg     40b30c <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x5c>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40b4bc:	48 8d 75 bb          	lea    -0x45(%rbp),%rsi
  40b4c0:	e8 ab 88 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40b4c5:	e9 42 fe ff ff       	jmpq   40b30c <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x5c>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40b4ca:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40b4cd:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40b4d0:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40b4d3:	89 d0                	mov    %edx,%eax
  40b4d5:	e9 f8 fe ff ff       	jmpq   40b3d2 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x122>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40b4da:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40b4dd:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40b4e0:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40b4e3:	89 d0                	mov    %edx,%eax
  40b4e5:	eb cd                	jmp    40b4b4 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x204>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40b4e7:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  40b4eb:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40b4ee:	48 8d 79 e8          	lea    -0x18(%rcx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40b4f2:	4c 39 f7             	cmp    %r14,%rdi
  40b4f5:	75 08                	jne    40b4ff <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x24f>
  40b4f7:	48 89 df             	mov    %rbx,%rdi
  40b4fa:	e8 a1 8c ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40b4ff:	48 83 3d 71 8a 20 00 	cmpq   $0x0,0x208a71(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40b506:	00 
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
  40b507:	48 8d 47 10          	lea    0x10(%rdi),%rax
  40b50b:	74 16                	je     40b523 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x273>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40b50d:	83 ca ff             	or     $0xffffffff,%edx
  40b510:	f0 0f c1 10          	lock xadd %edx,(%rax)
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40b514:	85 d2                	test   %edx,%edx
  40b516:	7f df                	jg     40b4f7 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x247>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40b518:	48 8d 75 bb          	lea    -0x45(%rbp),%rsi
  40b51c:	e8 4f 88 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40b521:	eb d4                	jmp    40b4f7 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x247>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40b523:	8b 51 f8             	mov    -0x8(%rcx),%edx
    *__mem += __val;
  40b526:	8d 42 ff             	lea    -0x1(%rdx),%eax
  40b529:	89 41 f8             	mov    %eax,-0x8(%rcx)
  40b52c:	eb e6                	jmp    40b514 <_ZN6rocket15EventDispatcher13ProcessEventsEij+0x264>
  40b52e:	66 90                	xchg   %ax,%ax

000000000040b530 <_ZN6rocket15EventDispatcher4loopEv>:

    LOG_INFO("EventDispatcher init 2");  
	return ret;
}

int EventDispatcher::loop() {
  40b530:	41 57                	push   %r15
  40b532:	41 56                	push   %r14
  40b534:	49 89 ff             	mov    %rdi,%r15
  40b537:	41 55                	push   %r13
  40b539:	41 54                	push   %r12
}

__extern_always_inline int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40b53b:	48 8d 35 2f 51 00 00 	lea    0x512f(%rip),%rsi        # 410671 <_ZTSN6rocket12EpollWrapperE+0x91>
  40b542:	55                   	push   %rbp
  40b543:	53                   	push   %rbx
    printf("EventDispatcher LOOP\n");
	while (!stop_) {
        //printf("EventDispatcher LOOP1\n");
		int events_num = epoll_.Poll();
  40b544:	4d 8d 67 10          	lea    0x10(%r15),%r12
  40b548:	bf 01 00 00 00       	mov    $0x1,%edi
  40b54d:	31 c0                	xor    %eax,%eax

    LOG_INFO("EventDispatcher init 2");  
	return ret;
}

int EventDispatcher::loop() {
  40b54f:	48 83 ec 18          	sub    $0x18,%rsp
  40b553:	4c 8d 74 24 0c       	lea    0xc(%rsp),%r14
  40b558:	4c 8d 6c 24 08       	lea    0x8(%rsp),%r13
  40b55d:	e8 9e 86 ff ff       	callq  403c00 <__printf_chk@plt>
  40b562:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    printf("EventDispatcher LOOP\n");
	while (!stop_) {
  40b568:	41 80 7f 34 00       	cmpb   $0x0,0x34(%r15)
  40b56d:	0f 85 86 00 00 00    	jne    40b5f9 <_ZN6rocket15EventDispatcher4loopEv+0xc9>
        //printf("EventDispatcher LOOP1\n");
		int events_num = epoll_.Poll();
  40b573:	be 88 13 00 00       	mov    $0x1388,%esi
  40b578:	4c 89 e7             	mov    %r12,%rdi
		for (int i = 0; i < events_num; ++i) {
  40b57b:	31 db                	xor    %ebx,%ebx

int EventDispatcher::loop() {
    printf("EventDispatcher LOOP\n");
	while (!stop_) {
        //printf("EventDispatcher LOOP1\n");
		int events_num = epoll_.Poll();
  40b57d:	e8 0e fc ff ff       	callq  40b190 <_ZN6rocket12EpollWrapper4PollEi>
		for (int i = 0; i < events_num; ++i) {
  40b582:	85 c0                	test   %eax,%eax

int EventDispatcher::loop() {
    printf("EventDispatcher LOOP\n");
	while (!stop_) {
        //printf("EventDispatcher LOOP1\n");
		int events_num = epoll_.Poll();
  40b584:	89 c5                	mov    %eax,%ebp
		for (int i = 0; i < events_num; ++i) {
  40b586:	7f 3b                	jg     40b5c3 <_ZN6rocket15EventDispatcher4loopEv+0x93>
  40b588:	eb de                	jmp    40b568 <_ZN6rocket15EventDispatcher4loopEv+0x38>
  40b58a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            int fd = -1;
            u_int events = 0;
            if (epoll_.GetFdEvents(i, fd, events) != 0) {
                LOG_ERROR("loop getFdEvents error, i=%d", i);
  40b590:	e8 9b 05 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b595:	4c 8b 10             	mov    (%rax),%r10
  40b598:	48 89 c7             	mov    %rax,%rdi
  40b59b:	41 89 d9             	mov    %ebx,%r9d
  40b59e:	4c 8d 05 e2 50 00 00 	lea    0x50e2(%rip),%r8        # 410687 <_ZTSN6rocket12EpollWrapperE+0xa7>
  40b5a5:	b9 3a 00 00 00       	mov    $0x3a,%ecx
  40b5aa:	48 8d 15 5e 50 00 00 	lea    0x505e(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b5b1:	be 03 00 00 00       	mov    $0x3,%esi
  40b5b6:	31 c0                	xor    %eax,%eax
  40b5b8:	41 ff 52 20          	callq  *0x20(%r10)
int EventDispatcher::loop() {
    printf("EventDispatcher LOOP\n");
	while (!stop_) {
        //printf("EventDispatcher LOOP1\n");
		int events_num = epoll_.Poll();
		for (int i = 0; i < events_num; ++i) {
  40b5bc:	83 c3 01             	add    $0x1,%ebx
  40b5bf:	39 eb                	cmp    %ebp,%ebx
  40b5c1:	74 a5                	je     40b568 <_ZN6rocket15EventDispatcher4loopEv+0x38>
            int fd = -1;
            u_int events = 0;
            if (epoll_.GetFdEvents(i, fd, events) != 0) {
  40b5c3:	4c 89 f1             	mov    %r14,%rcx
  40b5c6:	4c 89 ea             	mov    %r13,%rdx
  40b5c9:	89 de                	mov    %ebx,%esi
  40b5cb:	4c 89 e7             	mov    %r12,%rdi
    printf("EventDispatcher LOOP\n");
	while (!stop_) {
        //printf("EventDispatcher LOOP1\n");
		int events_num = epoll_.Poll();
		for (int i = 0; i < events_num; ++i) {
            int fd = -1;
  40b5ce:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%rsp)
  40b5d5:	ff 
            u_int events = 0;
  40b5d6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
  40b5dd:	00 
            if (epoll_.GetFdEvents(i, fd, events) != 0) {
  40b5de:	e8 cd fb ff ff       	callq  40b1b0 <_ZN6rocket12EpollWrapper11GetFdEventsEiRiRj>
  40b5e3:	85 c0                	test   %eax,%eax
  40b5e5:	75 a9                	jne    40b590 <_ZN6rocket15EventDispatcher4loopEv+0x60>
                LOG_ERROR("loop getFdEvents error, i=%d", i);
                continue;
            }

            ProcessEvents(fd, events);
  40b5e7:	8b 54 24 0c          	mov    0xc(%rsp),%edx
  40b5eb:	8b 74 24 08          	mov    0x8(%rsp),%esi
  40b5ef:	4c 89 ff             	mov    %r15,%rdi
  40b5f2:	e8 b9 fc ff ff       	callq  40b2b0 <_ZN6rocket15EventDispatcher13ProcessEventsEij>
  40b5f7:	eb c3                	jmp    40b5bc <_ZN6rocket15EventDispatcher4loopEv+0x8c>
		}
	}
}
  40b5f9:	48 83 c4 18          	add    $0x18,%rsp
  40b5fd:	5b                   	pop    %rbx
  40b5fe:	5d                   	pop    %rbp
  40b5ff:	41 5c                	pop    %r12
  40b601:	41 5d                	pop    %r13
  40b603:	41 5e                	pop    %r14
  40b605:	41 5f                	pop    %r15
  40b607:	c3                   	retq   
  40b608:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b60f:	00 

000000000040b610 <_ZN6rocket15EventDispatcherC1EPNS_6ServerEi>:
#include "connection.h"
#include "server.h"

namespace rocket {

EventDispatcher::EventDispatcher(Server* s, const int listenfd) 
  40b610:	55                   	push   %rbp
	: listenfd_(listenfd)
    , server_(s)
    , stop_(false) {
  40b611:	48 8d 6f 10          	lea    0x10(%rdi),%rbp
#include "connection.h"
#include "server.h"

namespace rocket {

EventDispatcher::EventDispatcher(Server* s, const int listenfd) 
  40b615:	53                   	push   %rbx
  40b616:	48 89 fb             	mov    %rdi,%rbx
  40b619:	48 83 ec 08          	sub    $0x8,%rsp
	: listenfd_(listenfd)
    , server_(s)
    , stop_(false) {
  40b61d:	48 89 37             	mov    %rsi,(%rdi)
  40b620:	89 57 08             	mov    %edx,0x8(%rdi)
  40b623:	48 89 ef             	mov    %rbp,%rdi
  40b626:	e8 25 f9 ff ff       	callq  40af50 <_ZN6rocket12EpollWrapperC1Ev>
  40b62b:	c6 43 34 00          	movb   $0x0,0x34(%rbx)
    LOG_INFO("EventDispatcher");
  40b62f:	e8 fc 04 00 00       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40b634:	4c 8b 08             	mov    (%rax),%r9
  40b637:	48 89 c7             	mov    %rax,%rdi
  40b63a:	4c 8d 05 63 50 00 00 	lea    0x5063(%rip),%r8        # 4106a4 <_ZTSN6rocket12EpollWrapperE+0xc4>
  40b641:	b9 15 00 00 00       	mov    $0x15,%ecx
  40b646:	48 8d 15 c2 4f 00 00 	lea    0x4fc2(%rip),%rdx        # 41060f <_ZTSN6rocket12EpollWrapperE+0x2f>
  40b64d:	be 01 00 00 00       	mov    $0x1,%esi
  40b652:	31 c0                	xor    %eax,%eax
  40b654:	41 ff 51 20          	callq  *0x20(%r9)
	if (init() != 0)
  40b658:	48 89 df             	mov    %rbx,%rdi
  40b65b:	e8 90 fb ff ff       	callq  40b1f0 <_ZN6rocket15EventDispatcher4initEv>
  40b660:	85 c0                	test   %eax,%eax
  40b662:	75 07                	jne    40b66b <_ZN6rocket15EventDispatcherC1EPNS_6ServerEi+0x5b>
	{
		exit(EXIT_FAILURE);
	}
}
  40b664:	48 83 c4 08          	add    $0x8,%rsp
  40b668:	5b                   	pop    %rbx
  40b669:	5d                   	pop    %rbp
  40b66a:	c3                   	retq   
    , server_(s)
    , stop_(false) {
    LOG_INFO("EventDispatcher");
	if (init() != 0)
	{
		exit(EXIT_FAILURE);
  40b66b:	bf 01 00 00 00       	mov    $0x1,%edi
  40b670:	e8 5b 85 ff ff       	callq  403bd0 <exit@plt>
  40b675:	48 89 c3             	mov    %rax,%rbx
namespace rocket {

EventDispatcher::EventDispatcher(Server* s, const int listenfd) 
	: listenfd_(listenfd)
    , server_(s)
    , stop_(false) {
  40b678:	48 89 ef             	mov    %rbp,%rdi
  40b67b:	e8 d0 f9 ff ff       	callq  40b050 <_ZN6rocket12EpollWrapperD1Ev>
  40b680:	48 89 df             	mov    %rbx,%rdi
  40b683:	e8 18 8b ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40b688:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b68f:	00 

000000000040b690 <_ZN6rocket15EventDispatcherD1Ev>:
	{
		exit(EXIT_FAILURE);
	}
}

EventDispatcher::~EventDispatcher() {
  40b690:	48 83 c7 10          	add    $0x10,%rdi
  40b694:	e9 b7 f9 ff ff       	jmpq   40b050 <_ZN6rocket12EpollWrapperD1Ev>
  40b699:	90                   	nop
  40b69a:	90                   	nop
  40b69b:	90                   	nop
  40b69c:	90                   	nop
  40b69d:	90                   	nop
  40b69e:	90                   	nop
  40b69f:	90                   	nop

000000000040b6a0 <_ZN6rocket12EventWrapper9InitEventEv>:
  40b6a0:	53                   	push   %rbx
  40b6a1:	48 89 fb             	mov    %rdi,%rbx
  40b6a4:	48 8d 7f 08          	lea    0x8(%rdi),%rdi
  40b6a8:	31 f6                	xor    %esi,%esi
  40b6aa:	e8 61 86 ff ff       	callq  403d10 <pthread_mutex_init@plt>
  40b6af:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
  40b6b3:	31 f6                	xor    %esi,%esi
  40b6b5:	e8 d6 86 ff ff       	callq  403d90 <pthread_cond_init@plt>
  40b6ba:	c6 03 00             	movb   $0x0,(%rbx)
  40b6bd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%rbx)
  40b6c4:	5b                   	pop    %rbx
  40b6c5:	c3                   	retq   
  40b6c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b6cd:	00 00 00 

000000000040b6d0 <_ZN6rocket12EventWrapperC1Ev>:
  40b6d0:	e9 cb ff ff ff       	jmpq   40b6a0 <_ZN6rocket12EventWrapper9InitEventEv>
  40b6d5:	90                   	nop
  40b6d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b6dd:	00 00 00 

000000000040b6e0 <_ZN6rocket12EventWrapper9DestEventEv>:
  40b6e0:	53                   	push   %rbx
  40b6e1:	48 89 fb             	mov    %rdi,%rbx
  40b6e4:	48 8d 7f 30          	lea    0x30(%rdi),%rdi
  40b6e8:	e8 a3 83 ff ff       	callq  403a90 <pthread_cond_destroy@plt>
  40b6ed:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
  40b6f1:	5b                   	pop    %rbx
  40b6f2:	e9 69 8a ff ff       	jmpq   404160 <pthread_mutex_destroy@plt>
  40b6f7:	90                   	nop
  40b6f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b6ff:	00 

000000000040b700 <_ZN6rocket12EventWrapperD1Ev>:
  40b700:	e9 db ff ff ff       	jmpq   40b6e0 <_ZN6rocket12EventWrapper9DestEventEv>
  40b705:	90                   	nop
  40b706:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b70d:	00 00 00 

000000000040b710 <_ZN6rocket12EventWrapper3SetEv>:
  40b710:	55                   	push   %rbp
  40b711:	48 8d 6f 08          	lea    0x8(%rdi),%rbp
  40b715:	53                   	push   %rbx
  40b716:	48 89 fb             	mov    %rdi,%rbx
  40b719:	48 83 ec 08          	sub    $0x8,%rsp
  40b71d:	48 89 ef             	mov    %rbp,%rdi
  40b720:	e8 fb 89 ff ff       	callq  404120 <pthread_mutex_lock@plt>
  40b725:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
  40b729:	e8 72 84 ff ff       	callq  403ba0 <pthread_cond_signal@plt>
  40b72e:	83 43 04 01          	addl   $0x1,0x4(%rbx)
  40b732:	48 83 c4 08          	add    $0x8,%rsp
  40b736:	48 89 ef             	mov    %rbp,%rdi
  40b739:	5b                   	pop    %rbx
  40b73a:	5d                   	pop    %rbp
  40b73b:	e9 90 8a ff ff       	jmpq   4041d0 <pthread_mutex_unlock@plt>

000000000040b740 <_ZN6rocket12EventWrapper4WaitEj>:
  40b740:	41 55                	push   %r13
  40b742:	41 54                	push   %r12
  40b744:	41 89 f4             	mov    %esi,%r12d
  40b747:	55                   	push   %rbp
  40b748:	48 8d 6f 08          	lea    0x8(%rdi),%rbp
  40b74c:	53                   	push   %rbx
  40b74d:	48 89 fb             	mov    %rdi,%rbx
  40b750:	48 83 ec 18          	sub    $0x18,%rsp
  40b754:	c6 07 01             	movb   $0x1,(%rdi)
  40b757:	48 89 ef             	mov    %rbp,%rdi
  40b75a:	e8 c1 89 ff ff       	callq  404120 <pthread_mutex_lock@plt>
  40b75f:	8b 53 04             	mov    0x4(%rbx),%edx
  40b762:	85 d2                	test   %edx,%edx
  40b764:	74 2a                	je     40b790 <_ZN6rocket12EventWrapper4WaitEj+0x50>
  40b766:	83 ea 01             	sub    $0x1,%edx
  40b769:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  40b76f:	89 53 04             	mov    %edx,0x4(%rbx)
  40b772:	48 89 ef             	mov    %rbp,%rdi
  40b775:	e8 56 8a ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
  40b77a:	c6 03 00             	movb   $0x0,(%rbx)
  40b77d:	48 83 c4 18          	add    $0x18,%rsp
  40b781:	44 89 e8             	mov    %r13d,%eax
  40b784:	5b                   	pop    %rbx
  40b785:	5d                   	pop    %rbp
  40b786:	41 5c                	pop    %r12
  40b788:	41 5d                	pop    %r13
  40b78a:	c3                   	retq   
  40b78b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40b790:	45 85 e4             	test   %r12d,%r12d
  40b793:	41 bd 02 00 00 00    	mov    $0x2,%r13d
  40b799:	74 d7                	je     40b772 <_ZN6rocket12EventWrapper4WaitEj+0x32>
  40b79b:	31 ff                	xor    %edi,%edi
  40b79d:	e8 fe 8a ff ff       	callq  4042a0 <time@plt>
  40b7a2:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  40b7a7:	48 89 c6             	mov    %rax,%rsi
  40b7aa:	44 89 e0             	mov    %r12d,%eax
  40b7ad:	f7 e2                	mul    %edx
  40b7af:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
  40b7b3:	c1 ea 06             	shr    $0x6,%edx
  40b7b6:	89 d1                	mov    %edx,%ecx
  40b7b8:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
  40b7be:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
  40b7c2:	48 89 ee             	mov    %rbp,%rsi
  40b7c5:	48 89 04 24          	mov    %rax,(%rsp)
  40b7c9:	41 29 d4             	sub    %edx,%r12d
  40b7cc:	48 89 e2             	mov    %rsp,%rdx
  40b7cf:	41 69 c4 40 42 0f 00 	imul   $0xf4240,%r12d,%eax
  40b7d6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40b7db:	e8 c0 84 ff ff       	callq  403ca0 <pthread_cond_timedwait@plt>
  40b7e0:	83 f8 6e             	cmp    $0x6e,%eax
  40b7e3:	74 8d                	je     40b772 <_ZN6rocket12EventWrapper4WaitEj+0x32>
  40b7e5:	85 c0                	test   %eax,%eax
  40b7e7:	41 bd ff ff ff ff    	mov    $0xffffffff,%r13d
  40b7ed:	75 83                	jne    40b772 <_ZN6rocket12EventWrapper4WaitEj+0x32>
  40b7ef:	8b 43 04             	mov    0x4(%rbx),%eax
  40b7f2:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  40b7f8:	85 c0                	test   %eax,%eax
  40b7fa:	0f 84 72 ff ff ff    	je     40b772 <_ZN6rocket12EventWrapper4WaitEj+0x32>
  40b800:	83 e8 01             	sub    $0x1,%eax
  40b803:	89 43 04             	mov    %eax,0x4(%rbx)
  40b806:	e9 67 ff ff ff       	jmpq   40b772 <_ZN6rocket12EventWrapper4WaitEj+0x32>
  40b80b:	90                   	nop
  40b80c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040b810 <_ZN6rocket12EventWrapper10WaitAlwaysEv>:
  40b810:	41 54                	push   %r12
  40b812:	55                   	push   %rbp
  40b813:	48 8d 6f 08          	lea    0x8(%rdi),%rbp
  40b817:	53                   	push   %rbx
  40b818:	48 89 fb             	mov    %rdi,%rbx
  40b81b:	c6 07 01             	movb   $0x1,(%rdi)
  40b81e:	48 89 ef             	mov    %rbp,%rdi
  40b821:	e8 fa 88 ff ff       	callq  404120 <pthread_mutex_lock@plt>
  40b826:	8b 43 04             	mov    0x4(%rbx),%eax
  40b829:	85 c0                	test   %eax,%eax
  40b82b:	74 23                	je     40b850 <_ZN6rocket12EventWrapper10WaitAlwaysEv+0x40>
  40b82d:	83 e8 01             	sub    $0x1,%eax
  40b830:	45 31 e4             	xor    %r12d,%r12d
  40b833:	89 43 04             	mov    %eax,0x4(%rbx)
  40b836:	48 89 ef             	mov    %rbp,%rdi
  40b839:	e8 92 89 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
  40b83e:	44 89 e0             	mov    %r12d,%eax
  40b841:	c6 03 00             	movb   $0x0,(%rbx)
  40b844:	5b                   	pop    %rbx
  40b845:	5d                   	pop    %rbp
  40b846:	41 5c                	pop    %r12
  40b848:	c3                   	retq   
  40b849:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40b850:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
  40b854:	48 89 ee             	mov    %rbp,%rsi
  40b857:	e8 74 87 ff ff       	callq  403fd0 <pthread_cond_wait@plt>
  40b85c:	85 c0                	test   %eax,%eax
  40b85e:	75 18                	jne    40b878 <_ZN6rocket12EventWrapper10WaitAlwaysEv+0x68>
  40b860:	8b 43 04             	mov    0x4(%rbx),%eax
  40b863:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  40b869:	85 c0                	test   %eax,%eax
  40b86b:	74 c9                	je     40b836 <_ZN6rocket12EventWrapper10WaitAlwaysEv+0x26>
  40b86d:	83 e8 01             	sub    $0x1,%eax
  40b870:	89 43 04             	mov    %eax,0x4(%rbx)
  40b873:	eb c1                	jmp    40b836 <_ZN6rocket12EventWrapper10WaitAlwaysEv+0x26>
  40b875:	0f 1f 00             	nopl   (%rax)
  40b878:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
  40b87e:	eb b6                	jmp    40b836 <_ZN6rocket12EventWrapper10WaitAlwaysEv+0x26>

000000000040b880 <_ZN6rocket7load_soEPKc>:
  40b880:	41 54                	push   %r12
  40b882:	55                   	push   %rbp
  40b883:	49 89 fc             	mov    %rdi,%r12
  40b886:	53                   	push   %rbx
  40b887:	48 8b 1d 82 86 20 00 	mov    0x208682(%rip),%rbx        # 613f10 <_DYNAMIC+0x288>
  40b88e:	48 8b 3b             	mov    (%rbx),%rdi
  40b891:	48 85 ff             	test   %rdi,%rdi
  40b894:	74 05                	je     40b89b <_ZN6rocket7load_soEPKc+0x1b>
  40b896:	e8 55 85 ff ff       	callq  403df0 <dlclose@plt>
  40b89b:	31 c0                	xor    %eax,%eax
  40b89d:	b9 06 00 00 00       	mov    $0x6,%ecx
  40b8a2:	48 89 df             	mov    %rbx,%rdi
  40b8a5:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  40b8a8:	45 31 c9             	xor    %r9d,%r9d
  40b8ab:	31 d2                	xor    %edx,%edx
  40b8ad:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40b8b3:	31 ff                	xor    %edi,%edi
  40b8b5:	be 00 00 08 00       	mov    $0x80000,%esi
  40b8ba:	b1 22                	mov    $0x22,%cl
  40b8bc:	e8 9f 89 ff ff       	callq  404260 <mmap@plt>
  40b8c1:	be 02 00 00 00       	mov    $0x2,%esi
  40b8c6:	4c 89 e7             	mov    %r12,%rdi
  40b8c9:	e8 52 87 ff ff       	callq  404020 <dlopen@plt>
  40b8ce:	45 31 c9             	xor    %r9d,%r9d
  40b8d1:	48 89 c5             	mov    %rax,%rbp
  40b8d4:	31 d2                	xor    %edx,%edx
  40b8d6:	31 ff                	xor    %edi,%edi
  40b8d8:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40b8de:	b9 22 00 00 00       	mov    $0x22,%ecx
  40b8e3:	be 00 00 08 00       	mov    $0x80000,%esi
  40b8e8:	e8 73 89 ff ff       	callq  404260 <mmap@plt>
  40b8ed:	48 85 ed             	test   %rbp,%rbp
  40b8f0:	0f 84 c0 00 00 00    	je     40b9b6 <_ZN6rocket7load_soEPKc+0x136>
  40b8f6:	48 8d 35 7a 4e 00 00 	lea    0x4e7a(%rip),%rsi        # 410777 <_ZTSN6rocket12EpollWrapperE+0x197>
  40b8fd:	48 89 ef             	mov    %rbp,%rdi
  40b900:	e8 5b 87 ff ff       	callq  404060 <dlsym@plt>
  40b905:	48 85 c0             	test   %rax,%rax
  40b908:	0f 84 84 00 00 00    	je     40b992 <_ZN6rocket7load_soEPKc+0x112>
  40b90e:	48 8d 35 62 4e 00 00 	lea    0x4e62(%rip),%rsi        # 410777 <_ZTSN6rocket12EpollWrapperE+0x197>
  40b915:	48 89 ef             	mov    %rbp,%rdi
  40b918:	e8 43 87 ff ff       	callq  404060 <dlsym@plt>
  40b91d:	48 8d 35 66 4e 00 00 	lea    0x4e66(%rip),%rsi        # 41078a <_ZTSN6rocket12EpollWrapperE+0x1aa>
  40b924:	48 89 ef             	mov    %rbp,%rdi
  40b927:	48 89 43 08          	mov    %rax,0x8(%rbx)
  40b92b:	e8 30 87 ff ff       	callq  404060 <dlsym@plt>
  40b930:	48 8d 35 67 4e 00 00 	lea    0x4e67(%rip),%rsi        # 41079e <_ZTSN6rocket12EpollWrapperE+0x1be>
  40b937:	48 89 ef             	mov    %rbp,%rdi
  40b93a:	48 89 43 10          	mov    %rax,0x10(%rbx)
  40b93e:	e8 1d 87 ff ff       	callq  404060 <dlsym@plt>
  40b943:	48 8d 35 68 4e 00 00 	lea    0x4e68(%rip),%rsi        # 4107b2 <_ZTSN6rocket12EpollWrapperE+0x1d2>
  40b94a:	48 89 ef             	mov    %rbp,%rdi
  40b94d:	48 89 43 18          	mov    %rax,0x18(%rbx)
  40b951:	e8 0a 87 ff ff       	callq  404060 <dlsym@plt>
  40b956:	48 8d 35 6b 4e 00 00 	lea    0x4e6b(%rip),%rsi        # 4107c8 <_ZTSN6rocket12EpollWrapperE+0x1e8>
  40b95d:	48 89 ef             	mov    %rbp,%rdi
  40b960:	48 89 43 20          	mov    %rax,0x20(%rbx)
  40b964:	e8 f7 86 ff ff       	callq  404060 <dlsym@plt>
  40b969:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  40b96e:	48 89 43 28          	mov    %rax,0x28(%rbx)
  40b972:	0f 84 a0 00 00 00    	je     40ba18 <_ZN6rocket7load_soEPKc+0x198>
  40b978:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
  40b97d:	0f 84 8c 00 00 00    	je     40ba0f <_ZN6rocket7load_soEPKc+0x18f>
  40b983:	48 85 c0             	test   %rax,%rax
  40b986:	74 60                	je     40b9e8 <_ZN6rocket7load_soEPKc+0x168>
  40b988:	48 89 2b             	mov    %rbp,(%rbx)
  40b98b:	31 c0                	xor    %eax,%eax
  40b98d:	5b                   	pop    %rbx
  40b98e:	5d                   	pop    %rbp
  40b98f:	41 5c                	pop    %r12
  40b991:	c3                   	retq   
  40b992:	48 8b 05 d7 85 20 00 	mov    0x2085d7(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40b999:	48 8d 15 b8 4e 00 00 	lea    0x4eb8(%rip),%rdx        # 410858 <_ZTSN6rocket12EpollWrapperE+0x278>
  40b9a0:	be 01 00 00 00       	mov    $0x1,%esi
  40b9a5:	48 8b 38             	mov    (%rax),%rdi
  40b9a8:	31 c0                	xor    %eax,%eax
  40b9aa:	e8 b1 81 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40b9af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40b9b4:	eb d7                	jmp    40b98d <_ZN6rocket7load_soEPKc+0x10d>
  40b9b6:	e8 15 84 ff ff       	callq  403dd0 <dlerror@plt>
  40b9bb:	49 89 c0             	mov    %rax,%r8
  40b9be:	48 8b 05 ab 85 20 00 	mov    0x2085ab(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40b9c5:	48 8d 15 8d 4d 00 00 	lea    0x4d8d(%rip),%rdx        # 410759 <_ZTSN6rocket12EpollWrapperE+0x179>
  40b9cc:	4c 89 e1             	mov    %r12,%rcx
  40b9cf:	be 01 00 00 00       	mov    $0x1,%esi
  40b9d4:	48 8b 38             	mov    (%rax),%rdi
  40b9d7:	31 c0                	xor    %eax,%eax
  40b9d9:	e8 82 81 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40b9de:	bf 01 00 00 00       	mov    $0x1,%edi
  40b9e3:	e8 e8 81 ff ff       	callq  403bd0 <exit@plt>
  40b9e8:	48 8d 15 41 4e 00 00 	lea    0x4e41(%rip),%rdx        # 410830 <_ZTSN6rocket12EpollWrapperE+0x250>
  40b9ef:	48 8b 05 7a 85 20 00 	mov    0x20857a(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40b9f6:	be 01 00 00 00       	mov    $0x1,%esi
  40b9fb:	48 8b 38             	mov    (%rax),%rdi
  40b9fe:	31 c0                	xor    %eax,%eax
  40ba00:	e8 5b 81 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40ba05:	bf 01 00 00 00       	mov    $0x1,%edi
  40ba0a:	e8 c1 81 ff ff       	callq  403bd0 <exit@plt>
  40ba0f:	48 8d 15 f2 4d 00 00 	lea    0x4df2(%rip),%rdx        # 410808 <_ZTSN6rocket12EpollWrapperE+0x228>
  40ba16:	eb d7                	jmp    40b9ef <_ZN6rocket7load_soEPKc+0x16f>
  40ba18:	48 8d 15 c1 4d 00 00 	lea    0x4dc1(%rip),%rdx        # 4107e0 <_ZTSN6rocket12EpollWrapperE+0x200>
  40ba1f:	eb ce                	jmp    40b9ef <_ZN6rocket7load_soEPKc+0x16f>
  40ba21:	90                   	nop
  40ba22:	90                   	nop
  40ba23:	90                   	nop
  40ba24:	90                   	nop
  40ba25:	90                   	nop
  40ba26:	90                   	nop
  40ba27:	90                   	nop
  40ba28:	90                   	nop
  40ba29:	90                   	nop
  40ba2a:	90                   	nop
  40ba2b:	90                   	nop
  40ba2c:	90                   	nop
  40ba2d:	90                   	nop
  40ba2e:	90                   	nop
  40ba2f:	90                   	nop

000000000040ba30 <_ZN9LogConfig10parseLevelERKSs>:

#define LOG_BUF_SIZE 2048


int LogConfig::parseLevel(const std::string& level)
{
  40ba30:	55                   	push   %rbp
  40ba31:	53                   	push   %rbx
    const char* level_str[] = { "debug", "info", "warn", "error" };
  40ba32:	48 8d 05 4b 49 00 00 	lea    0x494b(%rip),%rax        # 410384 <_IO_stdin_used+0x4>
  40ba39:	31 db                	xor    %ebx,%ebx

#define LOG_BUF_SIZE 2048


int LogConfig::parseLevel(const std::string& level)
{
  40ba3b:	48 83 ec 28          	sub    $0x28,%rsp
  40ba3f:	48 8b 2e             	mov    (%rsi),%rbp
    const char* level_str[] = { "debug", "info", "warn", "error" };
  40ba42:	48 8d 35 3b 49 00 00 	lea    0x493b(%rip),%rsi        # 410384 <_IO_stdin_used+0x4>
  40ba49:	48 89 04 24          	mov    %rax,(%rsp)
  40ba4d:	48 8d 05 c3 4e 00 00 	lea    0x4ec3(%rip),%rax        # 410917 <_ZTSN6rocket12EpollWrapperE+0x337>
  40ba54:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40ba59:	48 8d 05 bc 4e 00 00 	lea    0x4ebc(%rip),%rax        # 41091c <_ZTSN6rocket12EpollWrapperE+0x33c>

    for (int i = LEVEL_DEBUG; i <= LEVEL_ERROR; ++i)
    {
        if (0 == strcasecmp(level.c_str(), level_str[i]))
  40ba60:	48 89 ef             	mov    %rbp,%rdi
#define LOG_BUF_SIZE 2048


int LogConfig::parseLevel(const std::string& level)
{
    const char* level_str[] = { "debug", "info", "warn", "error" };
  40ba63:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40ba68:	48 8d 05 1b 4b 00 00 	lea    0x4b1b(%rip),%rax        # 41058a <_ZTSN6rocket10ConnectionE+0x2a>
  40ba6f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

    for (int i = LEVEL_DEBUG; i <= LEVEL_ERROR; ++i)
    {
        if (0 == strcasecmp(level.c_str(), level_str[i]))
  40ba74:	e8 97 81 ff ff       	callq  403c10 <strcasecmp@plt>
  40ba79:	85 c0                	test   %eax,%eax
  40ba7b:	74 1a                	je     40ba97 <_ZN9LogConfig10parseLevelERKSs+0x67>
  40ba7d:	48 83 c3 01          	add    $0x1,%rbx

int LogConfig::parseLevel(const std::string& level)
{
    const char* level_str[] = { "debug", "info", "warn", "error" };

    for (int i = LEVEL_DEBUG; i <= LEVEL_ERROR; ++i)
  40ba81:	48 83 fb 04          	cmp    $0x4,%rbx
  40ba85:	74 19                	je     40baa0 <_ZN9LogConfig10parseLevelERKSs+0x70>
  40ba87:	48 8b 34 dc          	mov    (%rsp,%rbx,8),%rsi
    {
        if (0 == strcasecmp(level.c_str(), level_str[i]))
  40ba8b:	48 89 ef             	mov    %rbp,%rdi
  40ba8e:	e8 7d 81 ff ff       	callq  403c10 <strcasecmp@plt>
  40ba93:	85 c0                	test   %eax,%eax
  40ba95:	75 e6                	jne    40ba7d <_ZN9LogConfig10parseLevelERKSs+0x4d>
            return i;
        }
    }

    return LEVEL_DEBUG;
}
  40ba97:	48 83 c4 28          	add    $0x28,%rsp

    for (int i = LEVEL_DEBUG; i <= LEVEL_ERROR; ++i)
    {
        if (0 == strcasecmp(level.c_str(), level_str[i]))
        {
            return i;
  40ba9b:	89 d8                	mov    %ebx,%eax
        }
    }

    return LEVEL_DEBUG;
}
  40ba9d:	5b                   	pop    %rbx
  40ba9e:	5d                   	pop    %rbp
  40ba9f:	c3                   	retq   
  40baa0:	48 83 c4 28          	add    $0x28,%rsp
        {
            return i;
        }
    }

    return LEVEL_DEBUG;
  40baa4:	31 c0                	xor    %eax,%eax
}
  40baa6:	5b                   	pop    %rbx
  40baa7:	5d                   	pop    %rbp
  40baa8:	c3                   	retq   
  40baa9:	90                   	nop
  40baaa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040bab0 <_ZN9LogConfig11parseRotateERKSs>:

int LogConfig::parseRotate(const std::string& rotate)
{
  40bab0:	55                   	push   %rbp
  40bab1:	53                   	push   %rbx
    const char* rotate_str[] = { "daily", "weekly", "monthly" };
  40bab2:	48 8d 05 d7 48 00 00 	lea    0x48d7(%rip),%rax        # 410390 <_IO_stdin_used+0x10>
  40bab9:	31 db                	xor    %ebx,%ebx

    return LEVEL_DEBUG;
}

int LogConfig::parseRotate(const std::string& rotate)
{
  40babb:	48 83 ec 28          	sub    $0x28,%rsp
  40babf:	48 8b 2e             	mov    (%rsi),%rbp
    const char* rotate_str[] = { "daily", "weekly", "monthly" };
  40bac2:	48 8d 35 c7 48 00 00 	lea    0x48c7(%rip),%rsi        # 410390 <_IO_stdin_used+0x10>
  40bac9:	48 89 04 24          	mov    %rax,(%rsp)
  40bacd:	48 8d 05 4d 4e 00 00 	lea    0x4e4d(%rip),%rax        # 410921 <_ZTSN6rocket12EpollWrapperE+0x341>
  40bad4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40bad9:	48 8d 05 48 4e 00 00 	lea    0x4e48(%rip),%rax        # 410928 <_ZTSN6rocket12EpollWrapperE+0x348>

    for (int i = ROTATE_DAILY; i <= ROTATE_MONTHLY; ++i)
    {
        if (0 == strcasecmp(rotate.c_str(), rotate_str[i]))
  40bae0:	48 89 ef             	mov    %rbp,%rdi
    return LEVEL_DEBUG;
}

int LogConfig::parseRotate(const std::string& rotate)
{
    const char* rotate_str[] = { "daily", "weekly", "monthly" };
  40bae3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)

    for (int i = ROTATE_DAILY; i <= ROTATE_MONTHLY; ++i)
    {
        if (0 == strcasecmp(rotate.c_str(), rotate_str[i]))
  40bae8:	e8 23 81 ff ff       	callq  403c10 <strcasecmp@plt>
  40baed:	85 c0                	test   %eax,%eax
  40baef:	74 1a                	je     40bb0b <_ZN9LogConfig11parseRotateERKSs+0x5b>
  40baf1:	48 83 c3 01          	add    $0x1,%rbx

int LogConfig::parseRotate(const std::string& rotate)
{
    const char* rotate_str[] = { "daily", "weekly", "monthly" };

    for (int i = ROTATE_DAILY; i <= ROTATE_MONTHLY; ++i)
  40baf5:	48 83 fb 03          	cmp    $0x3,%rbx
  40baf9:	74 1d                	je     40bb18 <_ZN9LogConfig11parseRotateERKSs+0x68>
  40bafb:	48 8b 34 dc          	mov    (%rsp,%rbx,8),%rsi
    {
        if (0 == strcasecmp(rotate.c_str(), rotate_str[i]))
  40baff:	48 89 ef             	mov    %rbp,%rdi
  40bb02:	e8 09 81 ff ff       	callq  403c10 <strcasecmp@plt>
  40bb07:	85 c0                	test   %eax,%eax
  40bb09:	75 e6                	jne    40baf1 <_ZN9LogConfig11parseRotateERKSs+0x41>
            return i;
        }
    }

    return ROTATE_DAILY;
}
  40bb0b:	48 83 c4 28          	add    $0x28,%rsp

    for (int i = ROTATE_DAILY; i <= ROTATE_MONTHLY; ++i)
    {
        if (0 == strcasecmp(rotate.c_str(), rotate_str[i]))
        {
            return i;
  40bb0f:	89 d8                	mov    %ebx,%eax
        }
    }

    return ROTATE_DAILY;
}
  40bb11:	5b                   	pop    %rbx
  40bb12:	5d                   	pop    %rbp
  40bb13:	c3                   	retq   
  40bb14:	0f 1f 40 00          	nopl   0x0(%rax)
  40bb18:	48 83 c4 28          	add    $0x28,%rsp
        {
            return i;
        }
    }

    return ROTATE_DAILY;
  40bb1c:	31 c0                	xor    %eax,%eax
}
  40bb1e:	5b                   	pop    %rbx
  40bb1f:	5d                   	pop    %rbp
  40bb20:	c3                   	retq   
  40bb21:	90                   	nop
  40bb22:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40bb29:	1f 84 00 00 00 00 00 

000000000040bb30 <_ZN6Logger9getLoggerEv>:
    std::queue<std::string> _file_queue;
};

Logger& Logger::getLogger()
{
    static LoggerImpl logger;
  40bb30:	80 3d c1 93 20 00 00 	cmpb   $0x0,0x2093c1(%rip)        # 614ef8 <_ZGVZN6Logger9getLoggerEvE6logger>
  40bb37:	74 0f                	je     40bb48 <_ZN6Logger9getLoggerEv+0x18>
    return logger;
}
  40bb39:	48 8d 05 80 8a 20 00 	lea    0x208a80(%rip),%rax        # 6145c0 <_ZZN6Logger9getLoggerEvE6logger>
  40bb40:	c3                   	retq   
  40bb41:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    Mutex _mutex;
    std::queue<std::string> _file_queue;
};

Logger& Logger::getLogger()
{
  40bb48:	41 57                	push   %r15
  40bb4a:	41 56                	push   %r14
    static LoggerImpl logger;
  40bb4c:	48 8d 3d a5 93 20 00 	lea    0x2093a5(%rip),%rdi        # 614ef8 <_ZGVZN6Logger9getLoggerEvE6logger>
    Mutex _mutex;
    std::queue<std::string> _file_queue;
};

Logger& Logger::getLogger()
{
  40bb53:	41 55                	push   %r13
  40bb55:	41 54                	push   %r12
  40bb57:	55                   	push   %rbp
  40bb58:	53                   	push   %rbx
  40bb59:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
    static LoggerImpl logger;
  40bb60:	e8 db 7f ff ff       	callq  403b40 <__cxa_guard_acquire@plt>
  40bb65:	85 c0                	test   %eax,%eax
  40bb67:	75 19                	jne    40bb82 <_ZN6Logger9getLoggerEv+0x52>
    return logger;
}
  40bb69:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  40bb70:	48 8d 05 49 8a 20 00 	lea    0x208a49(%rip),%rax        # 6145c0 <_ZZN6Logger9getLoggerEvE6logger>
  40bb77:	5b                   	pop    %rbx
  40bb78:	5d                   	pop    %rbp
  40bb79:	41 5c                	pop    %r12
  40bb7b:	41 5d                	pop    %r13
  40bb7d:	41 5e                	pop    %r14
  40bb7f:	41 5f                	pop    %r15
  40bb81:	c3                   	retq   
}

class LoggerImpl : public Logger
{
public:
    LoggerImpl() : _size(0)
  40bb82:	48 8b 05 f7 83 20 00 	mov    0x2083f7(%rip),%rax        # 613f80 <_DYNAMIC+0x2f8>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  40bb89:	48 8b 2d d0 83 20 00 	mov    0x2083d0(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
class Mutex
{
public:
    Mutex()
    {
        int ret = pthread_mutex_init(&_mutex, NULL);
  40bb90:	48 8d 3d e1 92 20 00 	lea    0x2092e1(%rip),%rdi        # 614e78 <_ZZN6Logger9getLoggerEvE6logger+0x8b8>
  40bb97:	31 f6                	xor    %esi,%esi
    int rotate;
    unsigned count;
    size_t size;
    bool display;  // display to screen

    LogConfig() : file(), level(LEVEL_DEBUG), rotate(ROTATE_DAILY), count(10), size(104857600), display(true)
  40bb99:	c7 05 3d 8a 20 00 00 	movl   $0x0,0x208a3d(%rip)        # 6145e0 <_ZZN6Logger9getLoggerEvE6logger+0x20>
  40bba0:	00 00 00 
  40bba3:	c7 05 37 8a 20 00 00 	movl   $0x0,0x208a37(%rip)        # 6145e4 <_ZZN6Logger9getLoggerEvE6logger+0x24>
  40bbaa:	00 00 00 
  40bbad:	c7 05 31 8a 20 00 0a 	movl   $0xa,0x208a31(%rip)        # 6145e8 <_ZZN6Logger9getLoggerEvE6logger+0x28>
  40bbb4:	00 00 00 
  40bbb7:	48 c7 05 2e 8a 20 00 	movq   $0x6400000,0x208a2e(%rip)        # 6145f0 <_ZZN6Logger9getLoggerEvE6logger+0x30>
  40bbbe:	00 00 40 06 
  40bbc2:	48 83 c0 10          	add    $0x10,%rax
  40bbc6:	c6 05 2b 8a 20 00 01 	movb   $0x1,0x208a2b(%rip)        # 6145f8 <_ZZN6Logger9getLoggerEvE6logger+0x38>
  40bbcd:	48 c7 05 98 8a 20 00 	movq   $0x0,0x208a98(%rip)        # 614670 <_ZZN6Logger9getLoggerEvE6logger+0xb0>
  40bbd4:	00 00 00 00 
  40bbd8:	48 89 05 e1 89 20 00 	mov    %rax,0x2089e1(%rip)        # 6145c0 <_ZZN6Logger9getLoggerEvE6logger>
  40bbdf:	48 8d 45 18          	lea    0x18(%rbp),%rax
  40bbe3:	48 89 05 ee 89 20 00 	mov    %rax,0x2089ee(%rip)        # 6145d8 <_ZZN6Logger9getLoggerEvE6logger+0x18>
class Mutex
{
public:
    Mutex()
    {
        int ret = pthread_mutex_init(&_mutex, NULL);
  40bbea:	e8 21 81 ff ff       	callq  403d10 <pthread_mutex_init@plt>
        assert(ret == 0);
  40bbef:	85 c0                	test   %eax,%eax
  40bbf1:	0f 85 3e 05 00 00    	jne    40c135 <_ZN6Logger9getLoggerEv+0x605>
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }
  40bbf7:	48 8d 5c 24 40       	lea    0x40(%rsp),%rbx
  40bbfc:	31 f6                	xor    %esi,%esi
        _initialized = true;
  40bbfe:	c6 05 9b 92 20 00 01 	movb   $0x1,0x20929b(%rip)        # 614ea0 <_ZZN6Logger9getLoggerEvE6logger+0x8e0>
	iterator _M_start;
	iterator _M_finish;

	_Deque_impl()
	: _Tp_alloc_type(), _M_map(0), _M_map_size(0),
	  _M_start(), _M_finish()
  40bc05:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  40bc0c:	00 00 
  40bc0e:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  40bc15:	00 00 
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }
  40bc17:	48 89 df             	mov    %rbx,%rdi
      _Deque_iterator(_Tp* __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() _GLIBCXX_NOEXCEPT
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }
  40bc1a:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  40bc21:	00 00 
  40bc23:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  40bc2a:	00 00 
  40bc2c:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  40bc33:	00 00 
  40bc35:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
  40bc3c:	00 00 
  40bc3e:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
  40bc45:	00 00 
  40bc47:	48 c7 44 24 78 00 00 	movq   $0x0,0x78(%rsp)
  40bc4e:	00 00 
  40bc50:	48 c7 84 24 80 00 00 	movq   $0x0,0x80(%rsp)
  40bc57:	00 00 00 00 00 
  40bc5c:	48 c7 84 24 88 00 00 	movq   $0x0,0x88(%rsp)
  40bc63:	00 00 00 00 00 
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }
  40bc68:	e8 73 11 00 00       	callq  40cde0 <_ZNSt11_Deque_baseISsSaISsEE17_M_initialize_mapEm>

#if __cplusplus >= 201103L
      _Deque_base(_Deque_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
	_M_initialize_map(0);
  40bc6d:	48 8d 3d 34 92 20 00 	lea    0x209234(%rip),%rdi        # 614ea8 <_ZZN6Logger9getLoggerEvE6logger+0x8e8>
  40bc74:	31 f6                	xor    %esi,%esi
	{ }

#if __cplusplus >= 201103L
	_Deque_impl(_Tp_alloc_type&& __a) _GLIBCXX_NOEXCEPT
	: _Tp_alloc_type(std::move(__a)), _M_map(0), _M_map_size(0),
	  _M_start(), _M_finish()
  40bc76:	48 c7 05 27 92 20 00 	movq   $0x0,0x209227(%rip)        # 614ea8 <_ZZN6Logger9getLoggerEvE6logger+0x8e8>
  40bc7d:	00 00 00 00 
  40bc81:	48 c7 05 24 92 20 00 	movq   $0x0,0x209224(%rip)        # 614eb0 <_ZZN6Logger9getLoggerEvE6logger+0x8f0>
  40bc88:	00 00 00 00 
      _Deque_iterator(_Tp* __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() _GLIBCXX_NOEXCEPT
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }
  40bc8c:	48 c7 05 21 92 20 00 	movq   $0x0,0x209221(%rip)        # 614eb8 <_ZZN6Logger9getLoggerEvE6logger+0x8f8>
  40bc93:	00 00 00 00 
  40bc97:	48 c7 05 1e 92 20 00 	movq   $0x0,0x20921e(%rip)        # 614ec0 <_ZZN6Logger9getLoggerEvE6logger+0x900>
  40bc9e:	00 00 00 00 
  40bca2:	48 c7 05 1b 92 20 00 	movq   $0x0,0x20921b(%rip)        # 614ec8 <_ZZN6Logger9getLoggerEvE6logger+0x908>
  40bca9:	00 00 00 00 
  40bcad:	48 c7 05 18 92 20 00 	movq   $0x0,0x209218(%rip)        # 614ed0 <_ZZN6Logger9getLoggerEvE6logger+0x910>
  40bcb4:	00 00 00 00 
  40bcb8:	48 c7 05 15 92 20 00 	movq   $0x0,0x209215(%rip)        # 614ed8 <_ZZN6Logger9getLoggerEvE6logger+0x918>
  40bcbf:	00 00 00 00 
  40bcc3:	48 c7 05 12 92 20 00 	movq   $0x0,0x209212(%rip)        # 614ee0 <_ZZN6Logger9getLoggerEvE6logger+0x920>
  40bcca:	00 00 00 00 
  40bcce:	48 c7 05 0f 92 20 00 	movq   $0x0,0x20920f(%rip)        # 614ee8 <_ZZN6Logger9getLoggerEvE6logger+0x928>
  40bcd5:	00 00 00 00 
  40bcd9:	48 c7 05 0c 92 20 00 	movq   $0x0,0x20920c(%rip)        # 614ef0 <_ZZN6Logger9getLoggerEvE6logger+0x930>
  40bce0:	00 00 00 00 

#if __cplusplus >= 201103L
      _Deque_base(_Deque_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
	_M_initialize_map(0);
  40bce4:	e8 f7 10 00 00       	callq  40cde0 <_ZNSt11_Deque_baseISsSaISsEE17_M_initialize_mapEm>
	if (__x._M_impl._M_map)
  40bce9:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  40bcee:	48 85 c0             	test   %rax,%rax
  40bcf1:	0f 84 56 03 00 00    	je     40c04d <_ZN6Logger9getLoggerEv+0x51d>
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bcf7:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
      _Deque_iterator() _GLIBCXX_NOEXCEPT
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }
  40bcfc:	4c 8b 3d b5 91 20 00 	mov    0x2091b5(%rip),%r15        # 614eb8 <_ZZN6Logger9getLoggerEvE6logger+0x8f8>
  40bd03:	48 8b 15 b6 91 20 00 	mov    0x2091b6(%rip),%rdx        # 614ec0 <_ZZN6Logger9getLoggerEvE6logger+0x900>
  40bd0a:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
  40bd0f:	4c 8b 0d c2 91 20 00 	mov    0x2091c2(%rip),%r9        # 614ed8 <_ZZN6Logger9getLoggerEvE6logger+0x918>
  40bd16:	4c 8b 15 ab 91 20 00 	mov    0x2091ab(%rip),%r10        # 614ec8 <_ZZN6Logger9getLoggerEvE6logger+0x908>
  40bd1d:	48 89 0d 94 91 20 00 	mov    %rcx,0x209194(%rip)        # 614eb8 <_ZZN6Logger9getLoggerEvE6logger+0x8f8>
  40bd24:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
  40bd29:	48 89 35 a8 91 20 00 	mov    %rsi,0x2091a8(%rip)        # 614ed8 <_ZZN6Logger9getLoggerEvE6logger+0x918>
  40bd30:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
  40bd35:	4c 8b 25 94 91 20 00 	mov    0x209194(%rip),%r12        # 614ed0 <_ZZN6Logger9getLoggerEvE6logger+0x910>
      __b = _GLIBCXX_MOVE(__tmp);
  40bd3c:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bd41:	48 89 0d 78 91 20 00 	mov    %rcx,0x209178(%rip)        # 614ec0 <_ZZN6Logger9getLoggerEvE6logger+0x900>
  40bd48:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  40bd4d:	48 8b 15 94 91 20 00 	mov    0x209194(%rip),%rdx        # 614ee8 <_ZZN6Logger9getLoggerEvE6logger+0x928>
  40bd54:	4c 8b 05 95 91 20 00 	mov    0x209195(%rip),%r8        # 614ef0 <_ZZN6Logger9getLoggerEvE6logger+0x930>
      __b = _GLIBCXX_MOVE(__tmp);
  40bd5b:	4c 89 7c 24 50       	mov    %r15,0x50(%rsp)
  40bd60:	4c 89 54 24 60       	mov    %r10,0x60(%rsp)
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bd65:	48 89 0d 5c 91 20 00 	mov    %rcx,0x20915c(%rip)        # 614ec8 <_ZZN6Logger9getLoggerEvE6logger+0x908>
  40bd6c:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
      __b = _GLIBCXX_MOVE(__tmp);
  40bd71:	4c 89 4c 24 70       	mov    %r9,0x70(%rsp)
  40bd76:	4c 89 64 24 68       	mov    %r12,0x68(%rsp)
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bd7b:	48 89 0d 4e 91 20 00 	mov    %rcx,0x20914e(%rip)        # 614ed0 <_ZZN6Logger9getLoggerEvE6logger+0x910>
  40bd82:	48 8b 0d 57 91 20 00 	mov    0x209157(%rip),%rcx        # 614ee0 <_ZZN6Logger9getLoggerEvE6logger+0x920>
  40bd89:	48 89 35 50 91 20 00 	mov    %rsi,0x209150(%rip)        # 614ee0 <_ZZN6Logger9getLoggerEvE6logger+0x920>
  40bd90:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
  40bd97:	00 
      __b = _GLIBCXX_MOVE(__tmp);
  40bd98:	48 89 94 24 80 00 00 	mov    %rdx,0x80(%rsp)
  40bd9f:	00 
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
  40bda0:	48 8b 15 01 91 20 00 	mov    0x209101(%rip),%rdx        # 614ea8 <_ZZN6Logger9getLoggerEvE6logger+0x8e8>
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
  40bda7:	48 89 4c 24 78       	mov    %rcx,0x78(%rsp)
  40bdac:	49 89 cd             	mov    %rcx,%r13
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bdaf:	48 89 35 32 91 20 00 	mov    %rsi,0x209132(%rip)        # 614ee8 <_ZZN6Logger9getLoggerEvE6logger+0x928>
  40bdb6:	48 8b b4 24 88 00 00 	mov    0x88(%rsp),%rsi
  40bdbd:	00 
      __b = _GLIBCXX_MOVE(__tmp);
  40bdbe:	4c 89 84 24 88 00 00 	mov    %r8,0x88(%rsp)
  40bdc5:	00 
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bdc6:	48 89 35 23 91 20 00 	mov    %rsi,0x209123(%rip)        # 614ef0 <_ZZN6Logger9getLoggerEvE6logger+0x930>
  40bdcd:	48 89 05 d4 90 20 00 	mov    %rax,0x2090d4(%rip)        # 614ea8 <_ZZN6Logger9getLoggerEvE6logger+0x8e8>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
  40bdd4:	48 8b 05 d5 90 20 00 	mov    0x2090d5(%rip),%rax        # 614eb0 <_ZZN6Logger9getLoggerEvE6logger+0x8f0>
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
  40bddb:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bde0:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
      __b = _GLIBCXX_MOVE(__tmp);
  40bde5:	4c 89 64 24 20       	mov    %r12,0x20(%rsp)
  40bdea:	4d 89 cc             	mov    %r9,%r12
  40bded:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
  40bdf2:	48 89 15 b7 90 20 00 	mov    %rdx,0x2090b7(%rip)        # 614eb0 <_ZZN6Logger9getLoggerEvE6logger+0x8f0>
   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
  40bdf9:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40bdfe:	48 8d 50 08          	lea    0x8(%rax),%rdx
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40be02:	48 8d 44 24 3f       	lea    0x3f(%rsp),%rax
  40be07:	4c 39 c2             	cmp    %r8,%rdx
  40be0a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40be0f:	0f 83 88 00 00 00    	jae    40be9d <_ZN6Logger9getLoggerEv+0x36d>
  40be15:	0f 1f 00             	nopl   (%rax)
	    __node < __last._M_node; ++__node)
	 std::_Destroy(*__node, *__node + _S_buffer_size(),
		       _M_get_Tp_allocator());
  40be18:	48 8b 1a             	mov    (%rdx),%rbx
  40be1b:	4c 8d b3 00 02 00 00 	lea    0x200(%rbx),%r14
  40be22:	eb 0d                	jmp    40be31 <_ZN6Logger9getLoggerEv+0x301>
  40be24:	0f 1f 40 00          	nopl   0x0(%rax)
  40be28:	48 83 c3 08          	add    $0x8,%rbx
  40be2c:	49 39 de             	cmp    %rbx,%r14
  40be2f:	74 5f                	je     40be90 <_ZN6Logger9getLoggerEv+0x360>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40be31:	48 8b 03             	mov    (%rbx),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40be34:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40be38:	48 39 ef             	cmp    %rbp,%rdi
  40be3b:	74 eb                	je     40be28 <_ZN6Logger9getLoggerEv+0x2f8>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40be3d:	48 83 3d 33 81 20 00 	cmpq   $0x0,0x208133(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40be44:	00 
  40be45:	0f 84 b5 00 00 00    	je     40bf00 <_ZN6Logger9getLoggerEv+0x3d0>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40be4b:	be ff ff ff ff       	mov    $0xffffffff,%esi
  40be50:	f0 0f c1 70 f8       	lock xadd %esi,-0x8(%rax)
  40be55:	89 f0                	mov    %esi,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40be57:	85 c0                	test   %eax,%eax
  40be59:	7f cd                	jg     40be28 <_ZN6Logger9getLoggerEv+0x2f8>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40be5b:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
  40be60:	48 83 c3 08          	add    $0x8,%rbx
  40be64:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  40be69:	4c 89 54 24 10       	mov    %r10,0x10(%rsp)
  40be6e:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  40be73:	e8 f8 7e ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40be78:	49 39 de             	cmp    %rbx,%r14
  40be7b:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
  40be80:	4c 8b 54 24 10       	mov    0x10(%rsp),%r10
  40be85:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40be8a:	75 a5                	jne    40be31 <_ZN6Logger9getLoggerEv+0x301>
  40be8c:	0f 1f 40 00          	nopl   0x0(%rax)
   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
  40be90:	48 83 c2 08          	add    $0x8,%rdx
  40be94:	4c 39 c2             	cmp    %r8,%rdx
  40be97:	0f 82 7b ff ff ff    	jb     40be18 <_ZN6Logger9getLoggerEv+0x2e8>
	    __node < __last._M_node; ++__node)
	 std::_Destroy(*__node, *__node + _S_buffer_size(),
		       _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  40be9d:	4c 39 44 24 20       	cmp    %r8,0x20(%rsp)
  40bea2:	0f 84 50 01 00 00    	je     40bff8 <_ZN6Logger9getLoggerEv+0x4c8>
  40bea8:	4d 39 fa             	cmp    %r15,%r10
  40beab:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40beb0:	75 0f                	jne    40bec1 <_ZN6Logger9getLoggerEv+0x391>
  40beb2:	eb 5e                	jmp    40bf12 <_ZN6Logger9getLoggerEv+0x3e2>
  40beb4:	0f 1f 40 00          	nopl   0x0(%rax)
  40beb8:	49 83 c7 08          	add    $0x8,%r15
  40bebc:	4d 39 d7             	cmp    %r10,%r15
  40bebf:	74 51                	je     40bf12 <_ZN6Logger9getLoggerEv+0x3e2>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40bec1:	49 8b 07             	mov    (%r15),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40bec4:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40bec8:	48 39 ef             	cmp    %rbp,%rdi
  40becb:	74 eb                	je     40beb8 <_ZN6Logger9getLoggerEv+0x388>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40becd:	48 83 3d a3 80 20 00 	cmpq   $0x0,0x2080a3(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40bed4:	00 
  40bed5:	0f 84 0d 01 00 00    	je     40bfe8 <_ZN6Logger9getLoggerEv+0x4b8>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40bedb:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40bee0:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40bee5:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40bee7:	85 c0                	test   %eax,%eax
  40bee9:	7f cd                	jg     40beb8 <_ZN6Logger9getLoggerEv+0x388>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40beeb:	48 89 de             	mov    %rbx,%rsi
  40beee:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
  40bef3:	e8 78 7e ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40bef8:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
  40befd:	eb b9                	jmp    40beb8 <_ZN6Logger9getLoggerEv+0x388>
  40beff:	90                   	nop
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40bf00:	8b 70 f8             	mov    -0x8(%rax),%esi
    *__mem += __val;
  40bf03:	44 8d 5e ff          	lea    -0x1(%rsi),%r11d
  40bf07:	44 89 58 f8          	mov    %r11d,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40bf0b:	89 f0                	mov    %esi,%eax
  40bf0d:	e9 45 ff ff ff       	jmpq   40be57 <_ZN6Logger9getLoggerEv+0x327>
  40bf12:	4d 39 e5             	cmp    %r12,%r13
  40bf15:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40bf1a:	75 0d                	jne    40bf29 <_ZN6Logger9getLoggerEv+0x3f9>
  40bf1c:	eb 40                	jmp    40bf5e <_ZN6Logger9getLoggerEv+0x42e>
  40bf1e:	66 90                	xchg   %ax,%ax
  40bf20:	49 83 c5 08          	add    $0x8,%r13
  40bf24:	4d 39 e5             	cmp    %r12,%r13
  40bf27:	74 35                	je     40bf5e <_ZN6Logger9getLoggerEv+0x42e>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40bf29:	49 8b 45 00          	mov    0x0(%r13),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40bf2d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40bf31:	48 39 ef             	cmp    %rbp,%rdi
  40bf34:	74 ea                	je     40bf20 <_ZN6Logger9getLoggerEv+0x3f0>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40bf36:	48 83 3d 3a 80 20 00 	cmpq   $0x0,0x20803a(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40bf3d:	00 
  40bf3e:	0f 84 94 00 00 00    	je     40bfd8 <_ZN6Logger9getLoggerEv+0x4a8>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40bf44:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40bf49:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40bf4e:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40bf50:	85 c0                	test   %eax,%eax
  40bf52:	7f cc                	jg     40bf20 <_ZN6Logger9getLoggerEv+0x3f0>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40bf54:	48 89 de             	mov    %rbx,%rsi
  40bf57:	e8 14 7e ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40bf5c:	eb c2                	jmp    40bf20 <_ZN6Logger9getLoggerEv+0x3f0>

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() _GLIBCXX_NOEXCEPT
    {
      if (this->_M_impl._M_map)
  40bf5e:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
  40bf63:	48 85 ff             	test   %rdi,%rdi
  40bf66:	74 33                	je     40bf9b <_ZN6Logger9getLoggerEv+0x46b>
	{
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
			   this->_M_impl._M_finish._M_node + 1);
  40bf68:	48 8b 84 24 88 00 00 	mov    0x88(%rsp),%rax
  40bf6f:	00 
  40bf70:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  40bf75:	48 8d 68 08          	lea    0x8(%rax),%rbp
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
  40bf79:	48 39 dd             	cmp    %rbx,%rbp
  40bf7c:	76 18                	jbe    40bf96 <_ZN6Logger9getLoggerEv+0x466>
  40bf7e:	66 90                	xchg   %ax,%ax
  40bf80:	48 8b 3b             	mov    (%rbx),%rdi
  40bf83:	48 83 c3 08          	add    $0x8,%rbx
  40bf87:	e8 24 7c ff ff       	callq  403bb0 <_ZdlPv@plt>
  40bf8c:	48 39 dd             	cmp    %rbx,%rbp
  40bf8f:	77 ef                	ja     40bf80 <_ZN6Logger9getLoggerEv+0x450>
  40bf91:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
  40bf96:	e8 15 7c ff ff       	callq  403bb0 <_ZdlPv@plt>
    std::queue<std::string> _file_queue;
};

Logger& Logger::getLogger()
{
    static LoggerImpl logger;
  40bf9b:	48 8d 3d 56 8f 20 00 	lea    0x208f56(%rip),%rdi        # 614ef8 <_ZGVZN6Logger9getLoggerEvE6logger>
class LoggerImpl : public Logger
{
public:
    LoggerImpl() : _size(0)
    {
        _file = NULL;
  40bfa2:	48 c7 05 23 86 20 00 	movq   $0x0,0x208623(%rip)        # 6145d0 <_ZZN6Logger9getLoggerEvE6logger+0x10>
  40bfa9:	00 00 00 00 
        _initialized = false;
  40bfad:	c6 05 14 86 20 00 00 	movb   $0x0,0x208614(%rip)        # 6145c8 <_ZZN6Logger9getLoggerEvE6logger+0x8>
    std::queue<std::string> _file_queue;
};

Logger& Logger::getLogger()
{
    static LoggerImpl logger;
  40bfb4:	e8 07 7e ff ff       	callq  403dc0 <__cxa_guard_release@plt>
  40bfb9:	48 8b 3d e0 7e 20 00 	mov    0x207ee0(%rip),%rdi        # 613ea0 <_DYNAMIC+0x218>
  40bfc0:	48 8d 15 81 84 20 00 	lea    0x208481(%rip),%rdx        # 614448 <__dso_handle>
  40bfc7:	48 8d 35 f2 85 20 00 	lea    0x2085f2(%rip),%rsi        # 6145c0 <_ZZN6Logger9getLoggerEvE6logger>
  40bfce:	e8 fd 7c ff ff       	callq  403cd0 <__cxa_atexit@plt>
  40bfd3:	e9 91 fb ff ff       	jmpq   40bb69 <_ZN6Logger9getLoggerEv+0x39>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40bfd8:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40bfdb:	8d 72 ff             	lea    -0x1(%rdx),%esi
  40bfde:	89 70 f8             	mov    %esi,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40bfe1:	89 d0                	mov    %edx,%eax
  40bfe3:	e9 68 ff ff ff       	jmpq   40bf50 <_ZN6Logger9getLoggerEv+0x420>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40bfe8:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40bfeb:	8d 72 ff             	lea    -0x1(%rdx),%esi
  40bfee:	89 70 f8             	mov    %esi,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40bff1:	89 d0                	mov    %edx,%eax
  40bff3:	e9 ef fe ff ff       	jmpq   40bee7 <_ZN6Logger9getLoggerEv+0x3b7>
  40bff8:	4d 39 e7             	cmp    %r12,%r15
  40bffb:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40c000:	75 1b                	jne    40c01d <_ZN6Logger9getLoggerEv+0x4ed>
  40c002:	e9 57 ff ff ff       	jmpq   40bf5e <_ZN6Logger9getLoggerEv+0x42e>
  40c007:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c00e:	00 00 
  40c010:	49 83 c7 08          	add    $0x8,%r15
  40c014:	4d 39 e7             	cmp    %r12,%r15
  40c017:	0f 84 41 ff ff ff    	je     40bf5e <_ZN6Logger9getLoggerEv+0x42e>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c01d:	49 8b 07             	mov    (%r15),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40c020:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40c024:	48 39 ef             	cmp    %rbp,%rdi
  40c027:	74 e7                	je     40c010 <_ZN6Logger9getLoggerEv+0x4e0>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40c029:	48 83 3d 47 7f 20 00 	cmpq   $0x0,0x207f47(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40c030:	00 
  40c031:	74 45                	je     40c078 <_ZN6Logger9getLoggerEv+0x548>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40c033:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40c038:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40c03d:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40c03f:	85 c0                	test   %eax,%eax
  40c041:	7f cd                	jg     40c010 <_ZN6Logger9getLoggerEv+0x4e0>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c043:	48 89 de             	mov    %rbx,%rsi
  40c046:	e8 25 7d ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40c04b:	eb c3                	jmp    40c010 <_ZN6Logger9getLoggerEv+0x4e0>
  40c04d:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
  40c052:	4c 8b 64 24 70       	mov    0x70(%rsp),%r12
  40c057:	4c 8b 84 24 88 00 00 	mov    0x88(%rsp),%r8
  40c05e:	00 
  40c05f:	4c 8b 54 24 60       	mov    0x60(%rsp),%r10
#if __cplusplus >= 201103L
      _Deque_base(_Deque_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
	_M_initialize_map(0);
	if (__x._M_impl._M_map)
  40c064:	4c 8b 7c 24 50       	mov    0x50(%rsp),%r15
  40c069:	4c 8b 6c 24 78       	mov    0x78(%rsp),%r13
  40c06e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  40c073:	e9 81 fd ff ff       	jmpq   40bdf9 <_ZN6Logger9getLoggerEv+0x2c9>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40c078:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40c07b:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40c07e:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40c081:	89 d0                	mov    %edx,%eax
  40c083:	eb ba                	jmp    40c03f <_ZN6Logger9getLoggerEv+0x50f>
  40c085:	49 89 c4             	mov    %rax,%r12
}

class LoggerImpl : public Logger
{
public:
    LoggerImpl() : _size(0)
  40c088:	48 89 df             	mov    %rbx,%rdi
  40c08b:	4c 89 e3             	mov    %r12,%rbx
  40c08e:	e8 9d 0a 00 00       	callq  40cb30 <_ZNSt5dequeISsSaISsEED1Ev>
    }

    ~Mutex()
    {
        if (_initialized)
  40c093:	80 3d 06 8e 20 00 00 	cmpb   $0x0,0x208e06(%rip)        # 614ea0 <_ZZN6Logger9getLoggerEvE6logger+0x8e0>
  40c09a:	75 2e                	jne    40c0ca <_ZN6Logger9getLoggerEv+0x59a>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40c09c:	48 8b 05 35 85 20 00 	mov    0x208535(%rip),%rax        # 6145d8 <_ZZN6Logger9getLoggerEvE6logger+0x18>
  40c0a3:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40c0a7:	48 39 ef             	cmp    %rbp,%rdi
  40c0aa:	74 0a                	je     40c0b6 <_ZN6Logger9getLoggerEv+0x586>
  40c0ac:	48 8d 74 24 3f       	lea    0x3f(%rsp),%rsi
  40c0b1:	e8 6a 82 ff ff       	callq  404320 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
    std::queue<std::string> _file_queue;
};

Logger& Logger::getLogger()
{
    static LoggerImpl logger;
  40c0b6:	48 8d 3d 3b 8e 20 00 	lea    0x208e3b(%rip),%rdi        # 614ef8 <_ZGVZN6Logger9getLoggerEvE6logger>
  40c0bd:	e8 2e 80 ff ff       	callq  4040f0 <__cxa_guard_abort@plt>
  40c0c2:	48 89 df             	mov    %rbx,%rdi
  40c0c5:	e8 d6 80 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
        {
            _initialized = false;
            int ret = pthread_mutex_destroy(&_mutex);
  40c0ca:	48 8d 3d a7 8d 20 00 	lea    0x208da7(%rip),%rdi        # 614e78 <_ZZN6Logger9getLoggerEvE6logger+0x8b8>

    ~Mutex()
    {
        if (_initialized)
        {
            _initialized = false;
  40c0d1:	c6 05 c8 8d 20 00 00 	movb   $0x0,0x208dc8(%rip)        # 614ea0 <_ZZN6Logger9getLoggerEvE6logger+0x8e0>
            int ret = pthread_mutex_destroy(&_mutex);
  40c0d8:	e8 83 80 ff ff       	callq  404160 <pthread_mutex_destroy@plt>
            perror("pthread_mutex_destroy");
  40c0dd:	48 8d 3d f0 47 00 00 	lea    0x47f0(%rip),%rdi        # 4108d4 <_ZTSN6rocket12EpollWrapperE+0x2f4>
    ~Mutex()
    {
        if (_initialized)
        {
            _initialized = false;
            int ret = pthread_mutex_destroy(&_mutex);
  40c0e4:	41 89 c4             	mov    %eax,%r12d
            perror("pthread_mutex_destroy");
  40c0e7:	e8 44 80 ff ff       	callq  404130 <perror@plt>
  40c0ec:	48 8d 0d 85 8d 20 00 	lea    0x208d85(%rip),%rcx        # 614e78 <_ZZN6Logger9getLoggerEvE6logger+0x8b8>
  40c0f3:	48 8d 35 f0 47 00 00 	lea    0x47f0(%rip),%rsi        # 4108ea <_ZTSN6rocket12EpollWrapperE+0x30a>
  40c0fa:	31 c0                	xor    %eax,%eax
  40c0fc:	44 89 e2             	mov    %r12d,%edx
  40c0ff:	bf 01 00 00 00       	mov    $0x1,%edi
  40c104:	e8 f7 7a ff ff       	callq  403c00 <__printf_chk@plt>
            printf("~Mutex ret=%d, %p\n", ret, this);
            assert(ret == 0);
  40c109:	45 85 e4             	test   %r12d,%r12d
  40c10c:	74 8e                	je     40c09c <_ZN6Logger9getLoggerEv+0x56c>
  40c10e:	48 8d 0d 9b 48 00 00 	lea    0x489b(%rip),%rcx        # 4109b0 <_ZZN5MutexD4EvE19__PRETTY_FUNCTION__>
  40c115:	48 8d 35 66 47 00 00 	lea    0x4766(%rip),%rsi        # 410882 <_ZTSN6rocket12EpollWrapperE+0x2a2>
  40c11c:	48 8d 3d 68 47 00 00 	lea    0x4768(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40c123:	ba 35 00 00 00       	mov    $0x35,%edx
  40c128:	e8 b3 7a ff ff       	callq  403be0 <__assert_fail@plt>
  40c12d:	48 89 c3             	mov    %rax,%rbx
  40c130:	e9 5e ff ff ff       	jmpq   40c093 <_ZN6Logger9getLoggerEv+0x563>
{
public:
    Mutex()
    {
        int ret = pthread_mutex_init(&_mutex, NULL);
        assert(ret == 0);
  40c135:	48 8d 0d 64 48 00 00 	lea    0x4864(%rip),%rcx        # 4109a0 <_ZZN5MutexC4EvE19__PRETTY_FUNCTION__>
  40c13c:	48 8d 35 3f 47 00 00 	lea    0x473f(%rip),%rsi        # 410882 <_ZTSN6rocket12EpollWrapperE+0x2a2>
  40c143:	48 8d 3d 41 47 00 00 	lea    0x4741(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40c14a:	ba 29 00 00 00       	mov    $0x29,%edx
  40c14f:	e8 8c 7a ff ff       	callq  403be0 <__assert_fail@plt>
  40c154:	90                   	nop
  40c155:	90                   	nop
  40c156:	90                   	nop
  40c157:	90                   	nop
  40c158:	90                   	nop
  40c159:	90                   	nop
  40c15a:	90                   	nop
  40c15b:	90                   	nop
  40c15c:	90                   	nop
  40c15d:	90                   	nop
  40c15e:	90                   	nop
  40c15f:	90                   	nop

000000000040c160 <_ZN10LoggerImpl8setLevelEi>:
        }

        _config = config;
    }

    virtual void setLevel(int level)
  40c160:	41 54                	push   %r12
  40c162:	55                   	push   %rbp
class Guard
{
public:
    Guard(Mutex& mutex) : _mutex(&mutex)
    {
        if (_mutex)
  40c163:	48 89 fd             	mov    %rdi,%rbp
  40c166:	48 81 c5 b8 08 00 00 	add    $0x8b8,%rbp
  40c16d:	53                   	push   %rbx
  40c16e:	41 89 f4             	mov    %esi,%r12d
  40c171:	48 89 fb             	mov    %rdi,%rbx
  40c174:	74 10                	je     40c186 <_ZN10LoggerImpl8setLevelEi+0x26>
        }
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&_mutex);
  40c176:	48 89 ef             	mov    %rbp,%rdi
  40c179:	e8 a2 7f ff ff       	callq  404120 <pthread_mutex_lock@plt>
        assert(ret == 0);
  40c17e:	85 c0                	test   %eax,%eax
  40c180:	0f 85 b5 00 00 00    	jne    40c23b <_ZN10LoggerImpl8setLevelEi+0xdb>
    {
        Guard guard(_mutex);
        assert(_initialized);
  40c186:	80 7b 08 00          	cmpb   $0x0,0x8(%rbx)
  40c18a:	0f 84 8c 00 00 00    	je     40c21c <_ZN10LoggerImpl8setLevelEi+0xbc>
        if (level < LEVEL_DEBUG || level > LEVEL_ERROR)
  40c190:	41 83 fc 03          	cmp    $0x3,%r12d
  40c194:	77 4a                	ja     40c1e0 <_ZN10LoggerImpl8setLevelEi+0x80>
        }
    }

    ~Guard()
    {
        if (_mutex)
  40c196:	48 85 ed             	test   %rbp,%rbp
        {
            return;
        }
        _config.level = level;
  40c199:	44 89 63 20          	mov    %r12d,0x20(%rbx)
  40c19d:	74 32                	je     40c1d1 <_ZN10LoggerImpl8setLevelEi+0x71>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c19f:	48 89 ef             	mov    %rbp,%rdi
  40c1a2:	e8 29 80 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40c1a7:	48 8d 3d fd 46 00 00 	lea    0x46fd(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c1ae:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40c1b0:	e8 7b 7f ff ff       	callq  404130 <perror@plt>
  40c1b5:	48 8d 35 04 47 00 00 	lea    0x4704(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40c1bc:	31 c0                	xor    %eax,%eax
  40c1be:	48 89 e9             	mov    %rbp,%rcx
  40c1c1:	89 da                	mov    %ebx,%edx
  40c1c3:	bf 01 00 00 00       	mov    $0x1,%edi
  40c1c8:	e8 33 7a ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40c1cd:	85 db                	test   %ebx,%ebx
  40c1cf:	75 46                	jne    40c217 <_ZN10LoggerImpl8setLevelEi+0xb7>
    }
  40c1d1:	5b                   	pop    %rbx
  40c1d2:	5d                   	pop    %rbp
  40c1d3:	41 5c                	pop    %r12
  40c1d5:	c3                   	retq   
  40c1d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c1dd:	00 00 00 
        }
    }

    ~Guard()
    {
        if (_mutex)
  40c1e0:	48 85 ed             	test   %rbp,%rbp
  40c1e3:	74 ec                	je     40c1d1 <_ZN10LoggerImpl8setLevelEi+0x71>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c1e5:	48 89 ef             	mov    %rbp,%rdi
  40c1e8:	e8 e3 7f ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40c1ed:	48 8d 3d b7 46 00 00 	lea    0x46b7(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c1f4:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40c1f6:	e8 35 7f ff ff       	callq  404130 <perror@plt>
  40c1fb:	48 8d 35 be 46 00 00 	lea    0x46be(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40c202:	31 c0                	xor    %eax,%eax
  40c204:	48 89 e9             	mov    %rbp,%rcx
  40c207:	89 da                	mov    %ebx,%edx
  40c209:	bf 01 00 00 00       	mov    $0x1,%edi
  40c20e:	e8 ed 79 ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40c213:	85 db                	test   %ebx,%ebx
  40c215:	74 ba                	je     40c1d1 <_ZN10LoggerImpl8setLevelEi+0x71>
  40c217:	e8 4c 81 ff ff       	callq  404368 <_ZN5Mutex6unlockEv.part.4>
    }

    virtual void setLevel(int level)
    {
        Guard guard(_mutex);
        assert(_initialized);
  40c21c:	48 8d 0d dd 47 00 00 	lea    0x47dd(%rip),%rcx        # 410a00 <_ZZN10LoggerImpl8setLevelEiE19__PRETTY_FUNCTION__>
  40c223:	48 8d 35 6a 46 00 00 	lea    0x466a(%rip),%rsi        # 410894 <_ZTSN6rocket12EpollWrapperE+0x2b4>
  40c22a:	48 8d 3d 6d 46 00 00 	lea    0x466d(%rip),%rdi        # 41089e <_ZTSN6rocket12EpollWrapperE+0x2be>
  40c231:	ba 5b 00 00 00       	mov    $0x5b,%edx
  40c236:	e8 a5 79 ff ff       	callq  403be0 <__assert_fail@plt>
  40c23b:	e8 08 81 ff ff       	callq  404348 <_ZN5Mutex4lockEv.part.3>

000000000040c240 <_ZN10LoggerImplD1Ev>:
    }

    return ROTATE_DAILY;
}

class LoggerImpl : public Logger
  40c240:	41 57                	push   %r15
  40c242:	41 56                	push   %r14
  40c244:	41 55                	push   %r13
  40c246:	41 54                	push   %r12
  40c248:	49 89 fc             	mov    %rdi,%r12
  40c24b:	55                   	push   %rbp
  40c24c:	53                   	push   %rbx
  40c24d:	48 83 ec 48          	sub    $0x48,%rsp
  40c251:	48 8b 05 28 7d 20 00 	mov    0x207d28(%rip),%rax        # 613f80 <_DYNAMIC+0x2f8>
      _Deque_iterator() _GLIBCXX_NOEXCEPT
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }
  40c258:	4c 8b 8f 30 09 00 00 	mov    0x930(%rdi),%r9
  40c25f:	4c 8b af 18 09 00 00 	mov    0x918(%rdi),%r13
  40c266:	4c 8b 87 20 09 00 00 	mov    0x920(%rdi),%r8
  40c26d:	48 8b 8f f8 08 00 00 	mov    0x8f8(%rdi),%rcx
  40c274:	4c 8b 9f 08 09 00 00 	mov    0x908(%rdi),%r11
  40c27b:	48 83 c0 10          	add    $0x10,%rax
  40c27f:	48 89 07             	mov    %rax,(%rdi)
  40c282:	48 8b 87 10 09 00 00 	mov    0x910(%rdi),%rax
   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
  40c289:	4c 8d 78 08          	lea    0x8(%rax),%r15
  40c28d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40c292:	4d 39 f9             	cmp    %r15,%r9
  40c295:	0f 86 b0 00 00 00    	jbe    40c34b <_ZN10LoggerImplD1Ev+0x10b>
  40c29b:	48 8b 2d be 7c 20 00 	mov    0x207cbe(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c2a2:	48 8d 44 24 3f       	lea    0x3f(%rsp),%rax
  40c2a7:	4c 89 fb             	mov    %r15,%rbx
  40c2aa:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  40c2af:	4c 89 6c 24 18       	mov    %r13,0x18(%rsp)
  40c2b4:	49 89 cf             	mov    %rcx,%r15
  40c2b7:	48 89 04 24          	mov    %rax,(%rsp)
  40c2bb:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  40c2c0:	49 89 ec             	mov    %rbp,%r12
  40c2c3:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  40c2c8:	4c 89 cd             	mov    %r9,%rbp
  40c2cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	    __node < __last._M_node; ++__node)
	 std::_Destroy(*__node, *__node + _S_buffer_size(),
		       _M_get_Tp_allocator());
  40c2d0:	4c 8b 33             	mov    (%rbx),%r14
  40c2d3:	4d 8d ae 00 02 00 00 	lea    0x200(%r14),%r13
  40c2da:	eb 0d                	jmp    40c2e9 <_ZN10LoggerImplD1Ev+0xa9>
  40c2dc:	0f 1f 40 00          	nopl   0x0(%rax)
  40c2e0:	49 83 c6 08          	add    $0x8,%r14
  40c2e4:	4d 39 f5             	cmp    %r14,%r13
  40c2e7:	74 3f                	je     40c328 <_ZN10LoggerImplD1Ev+0xe8>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c2e9:	49 8b 06             	mov    (%r14),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40c2ec:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40c2f0:	4c 39 e7             	cmp    %r12,%rdi
  40c2f3:	74 eb                	je     40c2e0 <_ZN10LoggerImplD1Ev+0xa0>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40c2f5:	48 83 3d 7b 7c 20 00 	cmpq   $0x0,0x207c7b(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40c2fc:	00 
  40c2fd:	0f 84 9d 01 00 00    	je     40c4a0 <_ZN10LoggerImplD1Ev+0x260>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40c303:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40c308:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40c30d:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40c30f:	85 c0                	test   %eax,%eax
  40c311:	7f cd                	jg     40c2e0 <_ZN10LoggerImplD1Ev+0xa0>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c313:	48 8b 34 24          	mov    (%rsp),%rsi
  40c317:	49 83 c6 08          	add    $0x8,%r14
  40c31b:	e8 50 7a ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40c320:	4d 39 f5             	cmp    %r14,%r13
  40c323:	75 c4                	jne    40c2e9 <_ZN10LoggerImplD1Ev+0xa9>
  40c325:	0f 1f 00             	nopl   (%rax)
   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
  40c328:	48 83 c3 08          	add    $0x8,%rbx
  40c32c:	48 39 dd             	cmp    %rbx,%rbp
  40c32f:	77 9f                	ja     40c2d0 <_ZN10LoggerImplD1Ev+0x90>
  40c331:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
  40c336:	4c 8b 6c 24 18       	mov    0x18(%rsp),%r13
  40c33b:	49 89 e9             	mov    %rbp,%r9
  40c33e:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  40c343:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12
  40c348:	4c 89 f9             	mov    %r15,%rcx
	    __node < __last._M_node; ++__node)
	 std::_Destroy(*__node, *__node + _S_buffer_size(),
		       _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  40c34b:	4c 3b 4c 24 08       	cmp    0x8(%rsp),%r9
  40c350:	0f 84 ec 01 00 00    	je     40c542 <_ZN10LoggerImplD1Ev+0x302>
  40c356:	4c 39 d9             	cmp    %r11,%rcx
  40c359:	74 64                	je     40c3bf <_ZN10LoggerImplD1Ev+0x17f>
  40c35b:	48 8b 2d fe 7b 20 00 	mov    0x207bfe(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  40c362:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40c367:	4d 89 c6             	mov    %r8,%r14
  40c36a:	4d 89 df             	mov    %r11,%r15
  40c36d:	eb 0a                	jmp    40c379 <_ZN10LoggerImplD1Ev+0x139>
  40c36f:	90                   	nop
  40c370:	48 83 c1 08          	add    $0x8,%rcx
  40c374:	49 39 cf             	cmp    %rcx,%r15
  40c377:	74 43                	je     40c3bc <_ZN10LoggerImplD1Ev+0x17c>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c379:	48 8b 01             	mov    (%rcx),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40c37c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40c380:	48 39 ef             	cmp    %rbp,%rdi
  40c383:	74 eb                	je     40c370 <_ZN10LoggerImplD1Ev+0x130>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40c385:	48 83 3d eb 7b 20 00 	cmpq   $0x0,0x207beb(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40c38c:	00 
  40c38d:	0f 84 9d 01 00 00    	je     40c530 <_ZN10LoggerImplD1Ev+0x2f0>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40c393:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40c398:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40c39d:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40c39f:	85 c0                	test   %eax,%eax
  40c3a1:	7f cd                	jg     40c370 <_ZN10LoggerImplD1Ev+0x130>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c3a3:	48 89 de             	mov    %rbx,%rsi
  40c3a6:	48 89 0c 24          	mov    %rcx,(%rsp)
  40c3aa:	e8 c1 79 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40c3af:	48 8b 0c 24          	mov    (%rsp),%rcx
  40c3b3:	48 83 c1 08          	add    $0x8,%rcx
  40c3b7:	49 39 cf             	cmp    %rcx,%r15
  40c3ba:	75 bd                	jne    40c379 <_ZN10LoggerImplD1Ev+0x139>
  40c3bc:	4d 89 f0             	mov    %r14,%r8
  40c3bf:	4d 39 c5             	cmp    %r8,%r13
  40c3c2:	74 58                	je     40c41c <_ZN10LoggerImplD1Ev+0x1dc>
  40c3c4:	48 8b 2d 95 7b 20 00 	mov    0x207b95(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  40c3cb:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40c3d0:	4d 89 c6             	mov    %r8,%r14
  40c3d3:	eb 0c                	jmp    40c3e1 <_ZN10LoggerImplD1Ev+0x1a1>
  40c3d5:	0f 1f 00             	nopl   (%rax)
  40c3d8:	49 83 c6 08          	add    $0x8,%r14
  40c3dc:	4d 39 f5             	cmp    %r14,%r13
  40c3df:	74 3b                	je     40c41c <_ZN10LoggerImplD1Ev+0x1dc>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c3e1:	49 8b 06             	mov    (%r14),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40c3e4:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40c3e8:	48 39 ef             	cmp    %rbp,%rdi
  40c3eb:	74 eb                	je     40c3d8 <_ZN10LoggerImplD1Ev+0x198>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40c3ed:	48 83 3d 83 7b 20 00 	cmpq   $0x0,0x207b83(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40c3f4:	00 
  40c3f5:	0f 84 25 01 00 00    	je     40c520 <_ZN10LoggerImplD1Ev+0x2e0>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40c3fb:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40c400:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40c405:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40c407:	85 c0                	test   %eax,%eax
  40c409:	7f cd                	jg     40c3d8 <_ZN10LoggerImplD1Ev+0x198>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c40b:	48 89 de             	mov    %rbx,%rsi
  40c40e:	49 83 c6 08          	add    $0x8,%r14
  40c412:	e8 59 79 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40c417:	4d 39 f5             	cmp    %r14,%r13
  40c41a:	75 c5                	jne    40c3e1 <_ZN10LoggerImplD1Ev+0x1a1>

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() _GLIBCXX_NOEXCEPT
    {
      if (this->_M_impl._M_map)
  40c41c:	49 8b bc 24 e8 08 00 	mov    0x8e8(%r12),%rdi
  40c423:	00 
  40c424:	48 85 ff             	test   %rdi,%rdi
  40c427:	74 3d                	je     40c466 <_ZN10LoggerImplD1Ev+0x226>
	{
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
			   this->_M_impl._M_finish._M_node + 1);
  40c429:	49 8b 84 24 30 09 00 	mov    0x930(%r12),%rax
  40c430:	00 
  40c431:	49 8b 9c 24 10 09 00 	mov    0x910(%r12),%rbx
  40c438:	00 
  40c439:	48 8d 68 08          	lea    0x8(%rax),%rbp
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
  40c43d:	48 39 dd             	cmp    %rbx,%rbp
  40c440:	76 1f                	jbe    40c461 <_ZN10LoggerImplD1Ev+0x221>
  40c442:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40c448:	48 8b 3b             	mov    (%rbx),%rdi
  40c44b:	48 83 c3 08          	add    $0x8,%rbx
  40c44f:	e8 5c 77 ff ff       	callq  403bb0 <_ZdlPv@plt>
  40c454:	48 39 dd             	cmp    %rbx,%rbp
  40c457:	77 ef                	ja     40c448 <_ZN10LoggerImplD1Ev+0x208>
  40c459:	49 8b bc 24 e8 08 00 	mov    0x8e8(%r12),%rdi
  40c460:	00 
  40c461:	e8 4a 77 ff ff       	callq  403bb0 <_ZdlPv@plt>
        _initialized = true;
    }

    ~Mutex()
    {
        if (_initialized)
  40c466:	41 80 bc 24 e0 08 00 	cmpb   $0x0,0x8e0(%r12)
  40c46d:	00 00 
  40c46f:	75 3f                	jne    40c4b0 <_ZN10LoggerImplD1Ev+0x270>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c471:	49 8b 44 24 18       	mov    0x18(%r12),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40c476:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40c47a:	48 3b 3d df 7a 20 00 	cmp    0x207adf(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40c481:	0f 85 23 01 00 00    	jne    40c5aa <_ZN10LoggerImplD1Ev+0x36a>
  40c487:	48 83 c4 48          	add    $0x48,%rsp
  40c48b:	5b                   	pop    %rbx
  40c48c:	5d                   	pop    %rbp
  40c48d:	41 5c                	pop    %r12
  40c48f:	41 5d                	pop    %r13
  40c491:	41 5e                	pop    %r14
  40c493:	41 5f                	pop    %r15
  40c495:	c3                   	retq   
  40c496:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c49d:	00 00 00 
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40c4a0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40c4a3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40c4a6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40c4a9:	89 d0                	mov    %edx,%eax
  40c4ab:	e9 5f fe ff ff       	jmpq   40c30f <_ZN10LoggerImplD1Ev+0xcf>
  40c4b0:	49 8d ac 24 b8 08 00 	lea    0x8b8(%r12),%rbp
  40c4b7:	00 
        {
            _initialized = false;
  40c4b8:	41 c6 84 24 e0 08 00 	movb   $0x0,0x8e0(%r12)
  40c4bf:	00 00 
            int ret = pthread_mutex_destroy(&_mutex);
  40c4c1:	48 89 ef             	mov    %rbp,%rdi
  40c4c4:	e8 97 7c ff ff       	callq  404160 <pthread_mutex_destroy@plt>
            perror("pthread_mutex_destroy");
  40c4c9:	48 8d 3d 04 44 00 00 	lea    0x4404(%rip),%rdi        # 4108d4 <_ZTSN6rocket12EpollWrapperE+0x2f4>
    ~Mutex()
    {
        if (_initialized)
        {
            _initialized = false;
            int ret = pthread_mutex_destroy(&_mutex);
  40c4d0:	89 c3                	mov    %eax,%ebx
            perror("pthread_mutex_destroy");
  40c4d2:	e8 59 7c ff ff       	callq  404130 <perror@plt>
  40c4d7:	48 8d 35 0c 44 00 00 	lea    0x440c(%rip),%rsi        # 4108ea <_ZTSN6rocket12EpollWrapperE+0x30a>
  40c4de:	31 c0                	xor    %eax,%eax
  40c4e0:	48 89 e9             	mov    %rbp,%rcx
  40c4e3:	89 da                	mov    %ebx,%edx
  40c4e5:	bf 01 00 00 00       	mov    $0x1,%edi
  40c4ea:	e8 11 77 ff ff       	callq  403c00 <__printf_chk@plt>
            printf("~Mutex ret=%d, %p\n", ret, this);
            assert(ret == 0);
  40c4ef:	85 db                	test   %ebx,%ebx
  40c4f1:	0f 84 7a ff ff ff    	je     40c471 <_ZN10LoggerImplD1Ev+0x231>
  40c4f7:	48 8d 0d b2 44 00 00 	lea    0x44b2(%rip),%rcx        # 4109b0 <_ZZN5MutexD4EvE19__PRETTY_FUNCTION__>
  40c4fe:	48 8d 35 7d 43 00 00 	lea    0x437d(%rip),%rsi        # 410882 <_ZTSN6rocket12EpollWrapperE+0x2a2>
  40c505:	48 8d 3d 7f 43 00 00 	lea    0x437f(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40c50c:	ba 35 00 00 00       	mov    $0x35,%edx
  40c511:	e8 ca 76 ff ff       	callq  403be0 <__assert_fail@plt>
  40c516:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c51d:	00 00 00 
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40c520:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40c523:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40c526:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40c529:	89 d0                	mov    %edx,%eax
  40c52b:	e9 d7 fe ff ff       	jmpq   40c407 <_ZN10LoggerImplD1Ev+0x1c7>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40c530:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40c533:	44 8d 4a ff          	lea    -0x1(%rdx),%r9d
  40c537:	44 89 48 f8          	mov    %r9d,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40c53b:	89 d0                	mov    %edx,%eax
  40c53d:	e9 5d fe ff ff       	jmpq   40c39f <_ZN10LoggerImplD1Ev+0x15f>
  40c542:	49 39 cd             	cmp    %rcx,%r13
  40c545:	0f 84 d1 fe ff ff    	je     40c41c <_ZN10LoggerImplD1Ev+0x1dc>
  40c54b:	48 8b 2d 0e 7a 20 00 	mov    0x207a0e(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c552:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40c557:	49 89 ce             	mov    %rcx,%r14
  40c55a:	eb 11                	jmp    40c56d <_ZN10LoggerImplD1Ev+0x32d>
  40c55c:	0f 1f 40 00          	nopl   0x0(%rax)
  40c560:	49 83 c6 08          	add    $0x8,%r14
  40c564:	4d 39 f5             	cmp    %r14,%r13
  40c567:	0f 84 af fe ff ff    	je     40c41c <_ZN10LoggerImplD1Ev+0x1dc>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c56d:	49 8b 06             	mov    (%r14),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40c570:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40c574:	48 39 ef             	cmp    %rbp,%rdi
  40c577:	74 e7                	je     40c560 <_ZN10LoggerImplD1Ev+0x320>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40c579:	48 83 3d f7 79 20 00 	cmpq   $0x0,0x2079f7(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40c580:	00 
  40c581:	74 1a                	je     40c59d <_ZN10LoggerImplD1Ev+0x35d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40c583:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40c588:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40c58d:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40c58f:	85 c0                	test   %eax,%eax
  40c591:	7f cd                	jg     40c560 <_ZN10LoggerImplD1Ev+0x320>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c593:	48 89 de             	mov    %rbx,%rsi
  40c596:	e8 d5 77 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40c59b:	eb c3                	jmp    40c560 <_ZN10LoggerImplD1Ev+0x320>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40c59d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40c5a0:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40c5a3:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40c5a6:	89 d0                	mov    %edx,%eax
  40c5a8:	eb e5                	jmp    40c58f <_ZN10LoggerImplD1Ev+0x34f>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40c5aa:	48 83 3d c6 79 20 00 	cmpq   $0x0,0x2079c6(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40c5b1:	00 
  40c5b2:	74 23                	je     40c5d7 <_ZN10LoggerImplD1Ev+0x397>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40c5b4:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40c5b9:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40c5be:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40c5c0:	85 c0                	test   %eax,%eax
  40c5c2:	0f 8f bf fe ff ff    	jg     40c487 <_ZN10LoggerImplD1Ev+0x247>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40c5c8:	48 8d 74 24 3f       	lea    0x3f(%rsp),%rsi
  40c5cd:	e8 9e 77 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40c5d2:	e9 b0 fe ff ff       	jmpq   40c487 <_ZN10LoggerImplD1Ev+0x247>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40c5d7:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40c5da:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40c5dd:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40c5e0:	89 d0                	mov    %edx,%eax
  40c5e2:	eb dc                	jmp    40c5c0 <_ZN10LoggerImplD1Ev+0x380>
  40c5e4:	90                   	nop
  40c5e5:	90                   	nop
  40c5e6:	90                   	nop
  40c5e7:	90                   	nop
  40c5e8:	90                   	nop
  40c5e9:	90                   	nop
  40c5ea:	90                   	nop
  40c5eb:	90                   	nop
  40c5ec:	90                   	nop
  40c5ed:	90                   	nop
  40c5ee:	90                   	nop
  40c5ef:	90                   	nop

000000000040c5f0 <_ZN5Mutex6unlockEv>:
    {
        int ret = pthread_mutex_lock(&_mutex);
        assert(ret == 0);
    }

    void unlock()
  40c5f0:	55                   	push   %rbp
  40c5f1:	53                   	push   %rbx
  40c5f2:	48 89 fd             	mov    %rdi,%rbp
  40c5f5:	48 83 ec 08          	sub    $0x8,%rsp
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c5f9:	e8 d2 7b ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40c5fe:	48 8d 3d a6 42 00 00 	lea    0x42a6(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c605:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40c607:	e8 24 7b ff ff       	callq  404130 <perror@plt>
  40c60c:	48 8d 35 ad 42 00 00 	lea    0x42ad(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40c613:	31 c0                	xor    %eax,%eax
  40c615:	48 89 e9             	mov    %rbp,%rcx
  40c618:	89 da                	mov    %ebx,%edx
  40c61a:	bf 01 00 00 00       	mov    $0x1,%edi
  40c61f:	e8 dc 75 ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40c624:	85 db                	test   %ebx,%ebx
  40c626:	75 07                	jne    40c62f <_ZN5Mutex6unlockEv+0x3f>
    }
  40c628:	48 83 c4 08          	add    $0x8,%rsp
  40c62c:	5b                   	pop    %rbx
  40c62d:	5d                   	pop    %rbp
  40c62e:	c3                   	retq   
  40c62f:	e8 34 7d ff ff       	callq  404368 <_ZN5Mutex6unlockEv.part.4>
  40c634:	90                   	nop
  40c635:	90                   	nop
  40c636:	90                   	nop
  40c637:	90                   	nop
  40c638:	90                   	nop
  40c639:	90                   	nop
  40c63a:	90                   	nop
  40c63b:	90                   	nop
  40c63c:	90                   	nop
  40c63d:	90                   	nop
  40c63e:	90                   	nop
  40c63f:	90                   	nop

000000000040c640 <_ZN10LoggerImpl4initER9LogConfig>:
    {
        _file = NULL;
        _initialized = false;
    }

    virtual void init(LogConfig& config)
  40c640:	41 54                	push   %r12
  40c642:	55                   	push   %rbp
class Guard
{
public:
    Guard(Mutex& mutex) : _mutex(&mutex)
    {
        if (_mutex)
  40c643:	48 89 fd             	mov    %rdi,%rbp
  40c646:	53                   	push   %rbx
  40c647:	49 89 f4             	mov    %rsi,%r12
  40c64a:	48 89 fb             	mov    %rdi,%rbx
  40c64d:	48 83 ec 10          	sub    $0x10,%rsp
  40c651:	48 81 c5 b8 08 00 00 	add    $0x8b8,%rbp
  40c658:	74 56                	je     40c6b0 <_ZN10LoggerImpl4initER9LogConfig+0x70>
        }
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&_mutex);
  40c65a:	48 89 ef             	mov    %rbp,%rdi
  40c65d:	e8 be 7a ff ff       	callq  404120 <pthread_mutex_lock@plt>
        assert(ret == 0);
  40c662:	85 c0                	test   %eax,%eax
  40c664:	0f 85 3d 01 00 00    	jne    40c7a7 <_ZN10LoggerImpl4initER9LogConfig+0x167>
    {
        Guard guard(_mutex);

        if (!_initialized)
  40c66a:	80 7b 08 00          	cmpb   $0x0,0x8(%rbx)
  40c66e:	74 46                	je     40c6b6 <_ZN10LoggerImpl4initER9LogConfig+0x76>
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c670:	48 89 ef             	mov    %rbp,%rdi
  40c673:	e8 58 7b ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40c678:	48 8d 3d 2c 42 00 00 	lea    0x422c(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c67f:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40c681:	e8 aa 7a ff ff       	callq  404130 <perror@plt>
  40c686:	48 8d 35 33 42 00 00 	lea    0x4233(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40c68d:	31 c0                	xor    %eax,%eax
  40c68f:	48 89 e9             	mov    %rbp,%rcx
  40c692:	89 da                	mov    %ebx,%edx
  40c694:	bf 01 00 00 00       	mov    $0x1,%edi
  40c699:	e8 62 75 ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40c69e:	85 db                	test   %ebx,%ebx
  40c6a0:	0f 85 06 01 00 00    	jne    40c7ac <_ZN10LoggerImpl4initER9LogConfig+0x16c>
            std::time_t tt = time(NULL);
            _tm_rotate = *localtime(&tt);
            _config = config;
            openLogFile();
        }
    }
  40c6a6:	48 83 c4 10          	add    $0x10,%rsp
  40c6aa:	5b                   	pop    %rbx
  40c6ab:	5d                   	pop    %rbp
  40c6ac:	41 5c                	pop    %r12
  40c6ae:	c3                   	retq   
  40c6af:	90                   	nop

    virtual void init(LogConfig& config)
    {
        Guard guard(_mutex);

        if (!_initialized)
  40c6b0:	80 7f 08 00          	cmpb   $0x0,0x8(%rdi)
  40c6b4:	75 f0                	jne    40c6a6 <_ZN10LoggerImpl4initER9LogConfig+0x66>
        {
            _initialized = true;
            std::time_t tt = time(NULL);
  40c6b6:	31 ff                	xor    %edi,%edi
    {
        Guard guard(_mutex);

        if (!_initialized)
        {
            _initialized = true;
  40c6b8:	c6 43 08 01          	movb   $0x1,0x8(%rbx)
            std::time_t tt = time(NULL);
  40c6bc:	e8 df 7b ff ff       	callq  4042a0 <time@plt>
            _tm_rotate = *localtime(&tt);
  40c6c1:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
        Guard guard(_mutex);

        if (!_initialized)
        {
            _initialized = true;
            std::time_t tt = time(NULL);
  40c6c6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
            _tm_rotate = *localtime(&tt);
  40c6cb:	e8 80 7a ff ff       	callq  404150 <localtime@plt>
  40c6d0:	48 8b 10             	mov    (%rax),%rdx

private:
    Mutex* _mutex;
};

struct LogConfig
  40c6d3:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  40c6d7:	4c 89 e6             	mov    %r12,%rsi
  40c6da:	48 89 53 40          	mov    %rdx,0x40(%rbx)
  40c6de:	48 8b 50 08          	mov    0x8(%rax),%rdx
  40c6e2:	48 89 53 48          	mov    %rdx,0x48(%rbx)
  40c6e6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  40c6ea:	48 89 53 50          	mov    %rdx,0x50(%rbx)
  40c6ee:	48 8b 50 18          	mov    0x18(%rax),%rdx
  40c6f2:	48 89 53 58          	mov    %rdx,0x58(%rbx)
  40c6f6:	48 8b 50 20          	mov    0x20(%rax),%rdx
  40c6fa:	48 89 53 60          	mov    %rdx,0x60(%rbx)
  40c6fe:	48 8b 50 28          	mov    0x28(%rax),%rdx
  40c702:	48 89 53 68          	mov    %rdx,0x68(%rbx)
  40c706:	48 8b 40 30          	mov    0x30(%rax),%rax
  40c70a:	48 89 43 70          	mov    %rax,0x70(%rbx)
  40c70e:	e8 ad 78 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>
  40c713:	41 8b 44 24 08       	mov    0x8(%r12),%eax
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c718:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  40c71c:	89 43 20             	mov    %eax,0x20(%rbx)
  40c71f:	41 8b 44 24 0c       	mov    0xc(%r12),%eax
    }

protected:
    void openLogFile()
    {
        if (_config.file.empty())
  40c724:	48 83 7f e8 00       	cmpq   $0x0,-0x18(%rdi)
  40c729:	89 43 24             	mov    %eax,0x24(%rbx)
  40c72c:	41 8b 44 24 10       	mov    0x10(%r12),%eax
  40c731:	89 43 28             	mov    %eax,0x28(%rbx)
  40c734:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  40c739:	48 89 43 30          	mov    %rax,0x30(%rbx)
  40c73d:	41 0f b6 44 24 20    	movzbl 0x20(%r12),%eax
  40c743:	88 43 38             	mov    %al,0x38(%rbx)
  40c746:	75 18                	jne    40c760 <_ZN10LoggerImpl4initER9LogConfig+0x120>
        }
    }

    ~Guard()
    {
        if (_mutex)
  40c748:	48 85 ed             	test   %rbp,%rbp
  40c74b:	0f 85 1f ff ff ff    	jne    40c670 <_ZN10LoggerImpl4initER9LogConfig+0x30>
  40c751:	e9 50 ff ff ff       	jmpq   40c6a6 <_ZN10LoggerImpl4initER9LogConfig+0x66>
  40c756:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c75d:	00 00 00 
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40c760:	48 8d 35 96 41 00 00 	lea    0x4196(%rip),%rsi        # 4108fd <_ZTSN6rocket12EpollWrapperE+0x31d>
  40c767:	e8 f4 74 ff ff       	callq  403c60 <fopen@plt>
        if (_file == NULL)
  40c76c:	48 85 c0             	test   %rax,%rax
        if (_config.file.empty())
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40c76f:	48 89 43 10          	mov    %rax,0x10(%rbx)
        if (_file == NULL)
  40c773:	75 d3                	jne    40c748 <_ZN10LoggerImpl4initER9LogConfig+0x108>
        {
            fprintf(stderr, "failed to open %s: %s\n",
                    _config.file.c_str(), strerror(errno));
  40c775:	e8 96 77 ff ff       	callq  403f10 <__errno_location@plt>
  40c77a:	8b 38                	mov    (%rax),%edi
  40c77c:	e8 bf 76 ff ff       	callq  403e40 <strerror@plt>
  40c781:	49 89 c0             	mov    %rax,%r8
# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
			__va_arg_pack ());
  40c784:	48 8b 05 e5 77 20 00 	mov    0x2077e5(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40c78b:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
  40c78f:	48 8d 15 6a 41 00 00 	lea    0x416a(%rip),%rdx        # 410900 <_ZTSN6rocket12EpollWrapperE+0x320>
  40c796:	be 01 00 00 00       	mov    $0x1,%esi
  40c79b:	48 8b 38             	mov    (%rax),%rdi
  40c79e:	31 c0                	xor    %eax,%eax
  40c7a0:	e8 bb 73 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40c7a5:	eb a1                	jmp    40c748 <_ZN10LoggerImpl4initER9LogConfig+0x108>
  40c7a7:	e8 9c 7b ff ff       	callq  404348 <_ZN5Mutex4lockEv.part.3>
  40c7ac:	e8 b7 7b ff ff       	callq  404368 <_ZN5Mutex6unlockEv.part.4>
  40c7b1:	48 89 c3             	mov    %rax,%rbx
  40c7b4:	48 85 ed             	test   %rbp,%rbp
  40c7b7:	74 08                	je     40c7c1 <_ZN10LoggerImpl4initER9LogConfig+0x181>
        {
            _mutex->unlock();
  40c7b9:	48 89 ef             	mov    %rbp,%rdi
  40c7bc:	e8 2f fe ff ff       	callq  40c5f0 <_ZN5Mutex6unlockEv>
  40c7c1:	48 89 df             	mov    %rbx,%rdi
  40c7c4:	e8 d7 79 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40c7c9:	90                   	nop
  40c7ca:	90                   	nop
  40c7cb:	90                   	nop
  40c7cc:	90                   	nop
  40c7cd:	90                   	nop
  40c7ce:	90                   	nop
  40c7cf:	90                   	nop

000000000040c7d0 <_ZN10LoggerImpl8reconfigER9LogConfig>:
            _config = config;
            openLogFile();
        }
    }

    virtual void reconfig(LogConfig& config)
  40c7d0:	41 55                	push   %r13
  40c7d2:	41 54                	push   %r12
class Guard
{
public:
    Guard(Mutex& mutex) : _mutex(&mutex)
    {
        if (_mutex)
  40c7d4:	49 89 fc             	mov    %rdi,%r12
  40c7d7:	55                   	push   %rbp
  40c7d8:	53                   	push   %rbx
  40c7d9:	48 89 f5             	mov    %rsi,%rbp
  40c7dc:	48 89 fb             	mov    %rdi,%rbx
  40c7df:	48 83 ec 08          	sub    $0x8,%rsp
  40c7e3:	49 81 c4 b8 08 00 00 	add    $0x8b8,%r12
  40c7ea:	74 10                	je     40c7fc <_ZN10LoggerImpl8reconfigER9LogConfig+0x2c>
        }
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&_mutex);
  40c7ec:	4c 89 e7             	mov    %r12,%rdi
  40c7ef:	e8 2c 79 ff ff       	callq  404120 <pthread_mutex_lock@plt>
        assert(ret == 0);
  40c7f4:	85 c0                	test   %eax,%eax
  40c7f6:	0f 85 a8 01 00 00    	jne    40c9a4 <_ZN10LoggerImpl8reconfigER9LogConfig+0x1d4>
    {
        Guard guard(_mutex);

        assert(_initialized);
  40c7fc:	80 7b 08 00          	cmpb   $0x0,0x8(%rbx)
  40c800:	0f 84 7f 01 00 00    	je     40c985 <_ZN10LoggerImpl8reconfigER9LogConfig+0x1b5>
  40c806:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  40c80a:	48 8b 75 00          	mov    0x0(%rbp),%rsi

        if (_config.file != config.file)
  40c80e:	4c 8d 6b 18          	lea    0x18(%rbx),%r13
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40c812:	48 8b 57 e8          	mov    -0x18(%rdi),%rdx
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
  40c816:	48 3b 56 e8          	cmp    -0x18(%rsi),%rdx
  40c81a:	0f 84 e8 00 00 00    	je     40c908 <_ZN10LoggerImpl8reconfigER9LogConfig+0x138>
        }
    }

    void closeLogFile()
    {
        if (_file)
  40c820:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  40c824:	48 85 ff             	test   %rdi,%rdi
  40c827:	74 0d                	je     40c836 <_ZN10LoggerImpl8reconfigER9LogConfig+0x66>
        {
            fclose(_file);
  40c829:	e8 e2 77 ff ff       	callq  404010 <fclose@plt>
            _file = NULL;
  40c82e:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  40c835:	00 
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  40c836:	48 89 ee             	mov    %rbp,%rsi
  40c839:	4c 89 ef             	mov    %r13,%rdi
  40c83c:	e8 7f 77 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>

private:
    Mutex* _mutex;
};

struct LogConfig
  40c841:	8b 45 08             	mov    0x8(%rbp),%eax
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40c844:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  40c848:	89 43 20             	mov    %eax,0x20(%rbx)
  40c84b:	8b 45 0c             	mov    0xc(%rbp),%eax
    }

protected:
    void openLogFile()
    {
        if (_config.file.empty())
  40c84e:	48 83 7f e8 00       	cmpq   $0x0,-0x18(%rdi)
  40c853:	89 43 24             	mov    %eax,0x24(%rbx)
  40c856:	8b 45 10             	mov    0x10(%rbp),%eax
  40c859:	89 43 28             	mov    %eax,0x28(%rbx)
  40c85c:	48 8b 45 18          	mov    0x18(%rbp),%rax
  40c860:	48 89 43 30          	mov    %rax,0x30(%rbx)
  40c864:	0f b6 45 20          	movzbl 0x20(%rbp),%eax
  40c868:	88 43 38             	mov    %al,0x38(%rbx)
  40c86b:	75 4b                	jne    40c8b8 <_ZN10LoggerImpl8reconfigER9LogConfig+0xe8>
        }
    }

    ~Guard()
    {
        if (_mutex)
  40c86d:	4d 85 e4             	test   %r12,%r12
  40c870:	74 36                	je     40c8a8 <_ZN10LoggerImpl8reconfigER9LogConfig+0xd8>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c872:	4c 89 e7             	mov    %r12,%rdi
  40c875:	e8 56 79 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40c87a:	48 8d 3d 2a 40 00 00 	lea    0x402a(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c881:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40c883:	e8 a8 78 ff ff       	callq  404130 <perror@plt>
}

__extern_always_inline int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c888:	48 8d 35 31 40 00 00 	lea    0x4031(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40c88f:	31 c0                	xor    %eax,%eax
  40c891:	4c 89 e1             	mov    %r12,%rcx
  40c894:	89 da                	mov    %ebx,%edx
  40c896:	bf 01 00 00 00       	mov    $0x1,%edi
  40c89b:	e8 60 73 ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40c8a0:	85 db                	test   %ebx,%ebx
  40c8a2:	0f 85 d8 00 00 00    	jne    40c980 <_ZN10LoggerImpl8reconfigER9LogConfig+0x1b0>
            openLogFile();
            return;
        }

        _config = config;
    }
  40c8a8:	48 83 c4 08          	add    $0x8,%rsp
  40c8ac:	5b                   	pop    %rbx
  40c8ad:	5d                   	pop    %rbp
  40c8ae:	41 5c                	pop    %r12
  40c8b0:	41 5d                	pop    %r13
  40c8b2:	c3                   	retq   
  40c8b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        if (_config.file.empty())
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40c8b8:	48 8d 35 3e 40 00 00 	lea    0x403e(%rip),%rsi        # 4108fd <_ZTSN6rocket12EpollWrapperE+0x31d>
  40c8bf:	e8 9c 73 ff ff       	callq  403c60 <fopen@plt>
        if (_file == NULL)
  40c8c4:	48 85 c0             	test   %rax,%rax
        if (_config.file.empty())
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40c8c7:	48 89 43 10          	mov    %rax,0x10(%rbx)
        if (_file == NULL)
  40c8cb:	75 a0                	jne    40c86d <_ZN10LoggerImpl8reconfigER9LogConfig+0x9d>
        {
            fprintf(stderr, "failed to open %s: %s\n",
                    _config.file.c_str(), strerror(errno));
  40c8cd:	e8 3e 76 ff ff       	callq  403f10 <__errno_location@plt>
  40c8d2:	8b 38                	mov    (%rax),%edi
  40c8d4:	e8 67 75 ff ff       	callq  403e40 <strerror@plt>
  40c8d9:	49 89 c0             	mov    %rax,%r8
# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
			__va_arg_pack ());
  40c8dc:	48 8b 05 8d 76 20 00 	mov    0x20768d(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40c8e3:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
  40c8e7:	48 8d 15 12 40 00 00 	lea    0x4012(%rip),%rdx        # 410900 <_ZTSN6rocket12EpollWrapperE+0x320>
  40c8ee:	be 01 00 00 00       	mov    $0x1,%esi
  40c8f3:	48 8b 38             	mov    (%rax),%rdi
  40c8f6:	31 c0                	xor    %eax,%eax
  40c8f8:	e8 63 72 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40c8fd:	e9 6b ff ff ff       	jmpq   40c86d <_ZN10LoggerImpl8reconfigER9LogConfig+0x9d>
  40c902:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40c908:	e8 e3 76 ff ff       	callq  403ff0 <memcmp@plt>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
  40c90d:	85 c0                	test   %eax,%eax
  40c90f:	0f 85 0b ff ff ff    	jne    40c820 <_ZN10LoggerImpl8reconfigER9LogConfig+0x50>
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }
  40c915:	48 89 ee             	mov    %rbp,%rsi
  40c918:	4c 89 ef             	mov    %r13,%rdi
  40c91b:	e8 a0 76 ff ff       	callq  403fc0 <_ZNSs6assignERKSs@plt>

private:
    Mutex* _mutex;
};

struct LogConfig
  40c920:	8b 45 08             	mov    0x8(%rbp),%eax
        }
    }

    ~Guard()
    {
        if (_mutex)
  40c923:	4d 85 e4             	test   %r12,%r12

private:
    Mutex* _mutex;
};

struct LogConfig
  40c926:	89 43 20             	mov    %eax,0x20(%rbx)
  40c929:	8b 45 0c             	mov    0xc(%rbp),%eax
  40c92c:	89 43 24             	mov    %eax,0x24(%rbx)
  40c92f:	8b 45 10             	mov    0x10(%rbp),%eax
  40c932:	89 43 28             	mov    %eax,0x28(%rbx)
  40c935:	48 8b 45 18          	mov    0x18(%rbp),%rax
  40c939:	48 89 43 30          	mov    %rax,0x30(%rbx)
  40c93d:	0f b6 45 20          	movzbl 0x20(%rbp),%eax
  40c941:	88 43 38             	mov    %al,0x38(%rbx)
        }
    }

    ~Guard()
    {
        if (_mutex)
  40c944:	0f 84 5e ff ff ff    	je     40c8a8 <_ZN10LoggerImpl8reconfigER9LogConfig+0xd8>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c94a:	4c 89 e7             	mov    %r12,%rdi
  40c94d:	e8 7e 78 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40c952:	48 8d 3d 52 3f 00 00 	lea    0x3f52(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40c959:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40c95b:	e8 d0 77 ff ff       	callq  404130 <perror@plt>
}

__extern_always_inline int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c960:	48 8d 35 59 3f 00 00 	lea    0x3f59(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40c967:	31 c0                	xor    %eax,%eax
  40c969:	4c 89 e1             	mov    %r12,%rcx
  40c96c:	89 da                	mov    %ebx,%edx
  40c96e:	bf 01 00 00 00       	mov    $0x1,%edi
  40c973:	e8 88 72 ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40c978:	85 db                	test   %ebx,%ebx
  40c97a:	0f 84 28 ff ff ff    	je     40c8a8 <_ZN10LoggerImpl8reconfigER9LogConfig+0xd8>
  40c980:	e8 e3 79 ff ff       	callq  404368 <_ZN5Mutex6unlockEv.part.4>

    virtual void reconfig(LogConfig& config)
    {
        Guard guard(_mutex);

        assert(_initialized);
  40c985:	48 8d 0d 34 40 00 00 	lea    0x4034(%rip),%rcx        # 4109c0 <_ZZN10LoggerImpl8reconfigER9LogConfigE19__PRETTY_FUNCTION__>
  40c98c:	48 8d 35 01 3f 00 00 	lea    0x3f01(%rip),%rsi        # 410894 <_ZTSN6rocket12EpollWrapperE+0x2b4>
  40c993:	48 8d 3d 04 3f 00 00 	lea    0x3f04(%rip),%rdi        # 41089e <_ZTSN6rocket12EpollWrapperE+0x2be>
  40c99a:	ba 4b 00 00 00       	mov    $0x4b,%edx
  40c99f:	e8 3c 72 ff ff       	callq  403be0 <__assert_fail@plt>
  40c9a4:	e8 9f 79 ff ff       	callq  404348 <_ZN5Mutex4lockEv.part.3>
  40c9a9:	48 89 c3             	mov    %rax,%rbx
        }
    }

    ~Guard()
    {
        if (_mutex)
  40c9ac:	4d 85 e4             	test   %r12,%r12
  40c9af:	74 08                	je     40c9b9 <_ZN10LoggerImpl8reconfigER9LogConfig+0x1e9>
        {
            _mutex->unlock();
  40c9b1:	4c 89 e7             	mov    %r12,%rdi
  40c9b4:	e8 37 fc ff ff       	callq  40c5f0 <_ZN5Mutex6unlockEv>
  40c9b9:	48 89 df             	mov    %rbx,%rdi
  40c9bc:	e8 df 77 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40c9c1:	90                   	nop
  40c9c2:	90                   	nop
  40c9c3:	90                   	nop
  40c9c4:	90                   	nop
  40c9c5:	90                   	nop
  40c9c6:	90                   	nop
  40c9c7:	90                   	nop
  40c9c8:	90                   	nop
  40c9c9:	90                   	nop
  40c9ca:	90                   	nop
  40c9cb:	90                   	nop
  40c9cc:	90                   	nop
  40c9cd:	90                   	nop
  40c9ce:	90                   	nop
  40c9cf:	90                   	nop

000000000040c9d0 <_ZN10LoggerImpl7setFileEPKc>:
            return;
        }
        _config.level = level;
    }

    virtual void setFile(const char* file)
  40c9d0:	41 55                	push   %r13
  40c9d2:	41 54                	push   %r12
  40c9d4:	49 89 f4             	mov    %rsi,%r12
  40c9d7:	55                   	push   %rbp
  40c9d8:	53                   	push   %rbx
class Guard
{
public:
    Guard(Mutex& mutex) : _mutex(&mutex)
    {
        if (_mutex)
  40c9d9:	48 89 fd             	mov    %rdi,%rbp
  40c9dc:	48 89 fb             	mov    %rdi,%rbx
  40c9df:	48 83 ec 08          	sub    $0x8,%rsp
  40c9e3:	48 81 c5 b8 08 00 00 	add    $0x8b8,%rbp
  40c9ea:	74 10                	je     40c9fc <_ZN10LoggerImpl7setFileEPKc+0x2c>
        }
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&_mutex);
  40c9ec:	48 89 ef             	mov    %rbp,%rdi
  40c9ef:	e8 2c 77 ff ff       	callq  404120 <pthread_mutex_lock@plt>
        assert(ret == 0);
  40c9f4:	85 c0                	test   %eax,%eax
  40c9f6:	0f 85 05 01 00 00    	jne    40cb01 <_ZN10LoggerImpl7setFileEPKc+0x131>
    {
        Guard guard(_mutex);
        assert(_initialized);
  40c9fc:	80 7b 08 00          	cmpb   $0x0,0x8(%rbx)
  40ca00:	0f 84 dc 00 00 00    	je     40cae2 <_ZN10LoggerImpl7setFileEPKc+0x112>
        if (_config.file != file)
  40ca06:	4c 8d 6b 18          	lea    0x18(%rbx),%r13
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
  40ca0a:	4c 89 e6             	mov    %r12,%rsi
  40ca0d:	4c 89 ef             	mov    %r13,%rdi
  40ca10:	e8 fb 73 ff ff       	callq  403e10 <_ZNKSs7compareEPKc@plt>
  40ca15:	85 c0                	test   %eax,%eax
  40ca17:	74 37                	je     40ca50 <_ZN10LoggerImpl7setFileEPKc+0x80>
        }
    }

    void closeLogFile()
    {
        if (_file)
  40ca19:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  40ca1d:	48 85 ff             	test   %rdi,%rdi
  40ca20:	74 0d                	je     40ca2f <_ZN10LoggerImpl7setFileEPKc+0x5f>
        {
            fclose(_file);
  40ca22:	e8 e9 75 ff ff       	callq  404010 <fclose@plt>
            _file = NULL;
  40ca27:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  40ca2e:	00 

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }
  40ca2f:	4c 89 e7             	mov    %r12,%rdi
  40ca32:	e8 29 73 ff ff       	callq  403d60 <strlen@plt>
       */
      basic_string&
      assign(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->assign(__s, traits_type::length(__s));
  40ca37:	4c 89 e6             	mov    %r12,%rsi
  40ca3a:	48 89 c2             	mov    %rax,%rdx
  40ca3d:	4c 89 ef             	mov    %r13,%rdi
  40ca40:	e8 3b 75 ff ff       	callq  403f80 <_ZNSs6assignEPKcm@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40ca45:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
    }

protected:
    void openLogFile()
    {
        if (_config.file.empty())
  40ca49:	48 83 7f e8 00       	cmpq   $0x0,-0x18(%rdi)
  40ca4e:	75 48                	jne    40ca98 <_ZN10LoggerImpl7setFileEPKc+0xc8>
        }
    }

    ~Guard()
    {
        if (_mutex)
  40ca50:	48 85 ed             	test   %rbp,%rbp
  40ca53:	74 32                	je     40ca87 <_ZN10LoggerImpl7setFileEPKc+0xb7>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40ca55:	48 89 ef             	mov    %rbp,%rdi
  40ca58:	e8 73 77 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40ca5d:	48 8d 3d 47 3e 00 00 	lea    0x3e47(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40ca64:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40ca66:	e8 c5 76 ff ff       	callq  404130 <perror@plt>
  40ca6b:	48 8d 35 4e 3e 00 00 	lea    0x3e4e(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40ca72:	31 c0                	xor    %eax,%eax
  40ca74:	48 89 e9             	mov    %rbp,%rcx
  40ca77:	89 da                	mov    %ebx,%edx
  40ca79:	bf 01 00 00 00       	mov    $0x1,%edi
  40ca7e:	e8 7d 71 ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40ca83:	85 db                	test   %ebx,%ebx
  40ca85:	75 7f                	jne    40cb06 <_ZN10LoggerImpl7setFileEPKc+0x136>
        {
            closeLogFile();
            _config.file = file;
            openLogFile();
        }
    }
  40ca87:	48 83 c4 08          	add    $0x8,%rsp
  40ca8b:	5b                   	pop    %rbx
  40ca8c:	5d                   	pop    %rbp
  40ca8d:	41 5c                	pop    %r12
  40ca8f:	41 5d                	pop    %r13
  40ca91:	c3                   	retq   
  40ca92:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        if (_config.file.empty())
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40ca98:	48 8d 35 5e 3e 00 00 	lea    0x3e5e(%rip),%rsi        # 4108fd <_ZTSN6rocket12EpollWrapperE+0x31d>
  40ca9f:	e8 bc 71 ff ff       	callq  403c60 <fopen@plt>
        if (_file == NULL)
  40caa4:	48 85 c0             	test   %rax,%rax
        if (_config.file.empty())
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40caa7:	48 89 43 10          	mov    %rax,0x10(%rbx)
        if (_file == NULL)
  40caab:	75 a3                	jne    40ca50 <_ZN10LoggerImpl7setFileEPKc+0x80>
        {
            fprintf(stderr, "failed to open %s: %s\n",
                    _config.file.c_str(), strerror(errno));
  40caad:	e8 5e 74 ff ff       	callq  403f10 <__errno_location@plt>
  40cab2:	8b 38                	mov    (%rax),%edi
  40cab4:	e8 87 73 ff ff       	callq  403e40 <strerror@plt>
  40cab9:	49 89 c0             	mov    %rax,%r8
# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
			__va_arg_pack ());
  40cabc:	48 8b 05 ad 74 20 00 	mov    0x2074ad(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40cac3:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
  40cac7:	48 8d 15 32 3e 00 00 	lea    0x3e32(%rip),%rdx        # 410900 <_ZTSN6rocket12EpollWrapperE+0x320>
  40cace:	be 01 00 00 00       	mov    $0x1,%esi
  40cad3:	48 8b 38             	mov    (%rax),%rdi
  40cad6:	31 c0                	xor    %eax,%eax
  40cad8:	e8 83 70 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40cadd:	e9 6e ff ff ff       	jmpq   40ca50 <_ZN10LoggerImpl7setFileEPKc+0x80>
    }

    virtual void setFile(const char* file)
    {
        Guard guard(_mutex);
        assert(_initialized);
  40cae2:	48 8d 0d 57 3f 00 00 	lea    0x3f57(%rip),%rcx        # 410a40 <_ZZN10LoggerImpl7setFileEPKcE19__PRETTY_FUNCTION__>
  40cae9:	48 8d 35 a4 3d 00 00 	lea    0x3da4(%rip),%rsi        # 410894 <_ZTSN6rocket12EpollWrapperE+0x2b4>
  40caf0:	48 8d 3d a7 3d 00 00 	lea    0x3da7(%rip),%rdi        # 41089e <_ZTSN6rocket12EpollWrapperE+0x2be>
  40caf7:	ba 66 00 00 00       	mov    $0x66,%edx
  40cafc:	e8 df 70 ff ff       	callq  403be0 <__assert_fail@plt>
  40cb01:	e8 42 78 ff ff       	callq  404348 <_ZN5Mutex4lockEv.part.3>
  40cb06:	e8 5d 78 ff ff       	callq  404368 <_ZN5Mutex6unlockEv.part.4>
  40cb0b:	48 89 c3             	mov    %rax,%rbx
        }
    }

    ~Guard()
    {
        if (_mutex)
  40cb0e:	48 85 ed             	test   %rbp,%rbp
  40cb11:	74 08                	je     40cb1b <_ZN10LoggerImpl7setFileEPKc+0x14b>
        {
            _mutex->unlock();
  40cb13:	48 89 ef             	mov    %rbp,%rdi
  40cb16:	e8 d5 fa ff ff       	callq  40c5f0 <_ZN5Mutex6unlockEv>
  40cb1b:	48 89 df             	mov    %rbx,%rdi
  40cb1e:	e8 7d 76 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40cb23:	90                   	nop
  40cb24:	90                   	nop
  40cb25:	90                   	nop
  40cb26:	90                   	nop
  40cb27:	90                   	nop
  40cb28:	90                   	nop
  40cb29:	90                   	nop
  40cb2a:	90                   	nop
  40cb2b:	90                   	nop
  40cb2c:	90                   	nop
  40cb2d:	90                   	nop
  40cb2e:	90                   	nop
  40cb2f:	90                   	nop

000000000040cb30 <_ZNSt5dequeISsSaISsEED1Ev>:
      /**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       */
      ~deque() _GLIBCXX_NOEXCEPT
  40cb30:	41 57                	push   %r15
  40cb32:	41 56                	push   %r14
  40cb34:	41 55                	push   %r13
  40cb36:	41 54                	push   %r12
  40cb38:	49 89 fc             	mov    %rdi,%r12
  40cb3b:	55                   	push   %rbp
  40cb3c:	53                   	push   %rbx
  40cb3d:	48 83 ec 48          	sub    $0x48,%rsp
      _Deque_iterator() _GLIBCXX_NOEXCEPT
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }
  40cb41:	48 8b 47 28          	mov    0x28(%rdi),%rax
  40cb45:	4c 8b 4f 48          	mov    0x48(%rdi),%r9
  40cb49:	4c 8b 57 30          	mov    0x30(%rdi),%r10
  40cb4d:	4c 8b 47 38          	mov    0x38(%rdi),%r8
  40cb51:	4c 8b 6f 10          	mov    0x10(%rdi),%r13
  40cb55:	4c 8b 5f 20          	mov    0x20(%rdi),%r11
   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
  40cb59:	4c 8d 78 08          	lea    0x8(%rax),%r15
  40cb5d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40cb62:	4d 39 f9             	cmp    %r15,%r9
  40cb65:	0f 86 b0 00 00 00    	jbe    40cc1b <_ZNSt5dequeISsSaISsEED1Ev+0xeb>
  40cb6b:	48 8b 2d ee 73 20 00 	mov    0x2073ee(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40cb72:	48 8d 44 24 3f       	lea    0x3f(%rsp),%rax
  40cb77:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  40cb7c:	4c 89 54 24 18       	mov    %r10,0x18(%rsp)
  40cb81:	4c 89 cb             	mov    %r9,%rbx
  40cb84:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  40cb89:	48 89 04 24          	mov    %rax,(%rsp)
  40cb8d:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  40cb92:	49 89 ec             	mov    %rbp,%r12
  40cb95:	4c 89 fd             	mov    %r15,%rbp
  40cb98:	4d 89 c7             	mov    %r8,%r15
  40cb9b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	    __node < __last._M_node; ++__node)
	 std::_Destroy(*__node, *__node + _S_buffer_size(),
		       _M_get_Tp_allocator());
  40cba0:	4c 8b 75 00          	mov    0x0(%rbp),%r14
  40cba4:	4d 8d ae 00 02 00 00 	lea    0x200(%r14),%r13
  40cbab:	eb 0c                	jmp    40cbb9 <_ZNSt5dequeISsSaISsEED1Ev+0x89>
  40cbad:	0f 1f 00             	nopl   (%rax)
  40cbb0:	49 83 c6 08          	add    $0x8,%r14
  40cbb4:	4d 39 f5             	cmp    %r14,%r13
  40cbb7:	74 3f                	je     40cbf8 <_ZNSt5dequeISsSaISsEED1Ev+0xc8>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40cbb9:	49 8b 06             	mov    (%r14),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40cbbc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40cbc0:	4c 39 e7             	cmp    %r12,%rdi
  40cbc3:	74 eb                	je     40cbb0 <_ZNSt5dequeISsSaISsEED1Ev+0x80>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40cbc5:	48 83 3d ab 73 20 00 	cmpq   $0x0,0x2073ab(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40cbcc:	00 
  40cbcd:	0f 84 6d 01 00 00    	je     40cd40 <_ZNSt5dequeISsSaISsEED1Ev+0x210>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40cbd3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40cbd8:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40cbdd:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40cbdf:	85 c0                	test   %eax,%eax
  40cbe1:	7f cd                	jg     40cbb0 <_ZNSt5dequeISsSaISsEED1Ev+0x80>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40cbe3:	48 8b 34 24          	mov    (%rsp),%rsi
  40cbe7:	49 83 c6 08          	add    $0x8,%r14
  40cbeb:	e8 80 71 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40cbf0:	4d 39 f5             	cmp    %r14,%r13
  40cbf3:	75 c4                	jne    40cbb9 <_ZNSt5dequeISsSaISsEED1Ev+0x89>
  40cbf5:	0f 1f 00             	nopl   (%rax)
   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
  40cbf8:	48 83 c5 08          	add    $0x8,%rbp
  40cbfc:	48 39 eb             	cmp    %rbp,%rbx
  40cbff:	77 9f                	ja     40cba0 <_ZNSt5dequeISsSaISsEED1Ev+0x70>
  40cc01:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  40cc06:	4c 8b 54 24 18       	mov    0x18(%rsp),%r10
  40cc0b:	49 89 d9             	mov    %rbx,%r9
  40cc0e:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  40cc13:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12
  40cc18:	4d 89 f8             	mov    %r15,%r8
	    __node < __last._M_node; ++__node)
	 std::_Destroy(*__node, *__node + _S_buffer_size(),
		       _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  40cc1b:	4c 3b 4c 24 08       	cmp    0x8(%rsp),%r9
  40cc20:	0f 84 4a 01 00 00    	je     40cd70 <_ZNSt5dequeISsSaISsEED1Ev+0x240>
  40cc26:	4d 39 dd             	cmp    %r11,%r13
  40cc29:	74 65                	je     40cc90 <_ZNSt5dequeISsSaISsEED1Ev+0x160>
  40cc2b:	48 8b 2d 2e 73 20 00 	mov    0x20732e(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  40cc32:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40cc37:	4d 89 d6             	mov    %r10,%r14
  40cc3a:	4d 89 df             	mov    %r11,%r15
  40cc3d:	eb 0a                	jmp    40cc49 <_ZNSt5dequeISsSaISsEED1Ev+0x119>
  40cc3f:	90                   	nop
  40cc40:	49 83 c5 08          	add    $0x8,%r13
  40cc44:	4d 39 ef             	cmp    %r13,%r15
  40cc47:	74 44                	je     40cc8d <_ZNSt5dequeISsSaISsEED1Ev+0x15d>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40cc49:	49 8b 45 00          	mov    0x0(%r13),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40cc4d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40cc51:	48 39 ef             	cmp    %rbp,%rdi
  40cc54:	74 ea                	je     40cc40 <_ZNSt5dequeISsSaISsEED1Ev+0x110>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40cc56:	48 83 3d 1a 73 20 00 	cmpq   $0x0,0x20731a(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40cc5d:	00 
  40cc5e:	0f 84 fc 00 00 00    	je     40cd60 <_ZNSt5dequeISsSaISsEED1Ev+0x230>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40cc64:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40cc69:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40cc6e:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40cc70:	85 c0                	test   %eax,%eax
  40cc72:	7f cc                	jg     40cc40 <_ZNSt5dequeISsSaISsEED1Ev+0x110>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40cc74:	48 89 de             	mov    %rbx,%rsi
  40cc77:	49 83 c5 08          	add    $0x8,%r13
  40cc7b:	4c 89 04 24          	mov    %r8,(%rsp)
  40cc7f:	e8 ec 70 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40cc84:	4d 39 ef             	cmp    %r13,%r15
  40cc87:	4c 8b 04 24          	mov    (%rsp),%r8
  40cc8b:	75 bc                	jne    40cc49 <_ZNSt5dequeISsSaISsEED1Ev+0x119>
  40cc8d:	4d 89 f2             	mov    %r14,%r10
  40cc90:	4d 39 c2             	cmp    %r8,%r10
  40cc93:	74 5f                	je     40ccf4 <_ZNSt5dequeISsSaISsEED1Ev+0x1c4>
  40cc95:	48 8b 2d c4 72 20 00 	mov    0x2072c4(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  40cc9c:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40cca1:	4d 89 d5             	mov    %r10,%r13
  40cca4:	4d 89 c6             	mov    %r8,%r14
  40cca7:	eb 10                	jmp    40ccb9 <_ZNSt5dequeISsSaISsEED1Ev+0x189>
  40cca9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40ccb0:	49 83 c6 08          	add    $0x8,%r14
  40ccb4:	4d 39 f5             	cmp    %r14,%r13
  40ccb7:	74 3b                	je     40ccf4 <_ZNSt5dequeISsSaISsEED1Ev+0x1c4>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40ccb9:	49 8b 06             	mov    (%r14),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40ccbc:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40ccc0:	48 39 ef             	cmp    %rbp,%rdi
  40ccc3:	74 eb                	je     40ccb0 <_ZNSt5dequeISsSaISsEED1Ev+0x180>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40ccc5:	48 83 3d ab 72 20 00 	cmpq   $0x0,0x2072ab(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40cccc:	00 
  40cccd:	0f 84 7d 00 00 00    	je     40cd50 <_ZNSt5dequeISsSaISsEED1Ev+0x220>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40ccd3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40ccd8:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40ccdd:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40ccdf:	85 c0                	test   %eax,%eax
  40cce1:	7f cd                	jg     40ccb0 <_ZNSt5dequeISsSaISsEED1Ev+0x180>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40cce3:	48 89 de             	mov    %rbx,%rsi
  40cce6:	49 83 c6 08          	add    $0x8,%r14
  40ccea:	e8 81 70 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40ccef:	4d 39 f5             	cmp    %r14,%r13
  40ccf2:	75 c5                	jne    40ccb9 <_ZNSt5dequeISsSaISsEED1Ev+0x189>

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() _GLIBCXX_NOEXCEPT
    {
      if (this->_M_impl._M_map)
  40ccf4:	49 8b 3c 24          	mov    (%r12),%rdi
  40ccf8:	48 85 ff             	test   %rdi,%rdi
  40ccfb:	74 2d                	je     40cd2a <_ZNSt5dequeISsSaISsEED1Ev+0x1fa>
	{
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
			   this->_M_impl._M_finish._M_node + 1);
  40ccfd:	49 8b 44 24 48       	mov    0x48(%r12),%rax
  40cd02:	49 8b 5c 24 28       	mov    0x28(%r12),%rbx
  40cd07:	48 8d 68 08          	lea    0x8(%rax),%rbp
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
  40cd0b:	48 39 dd             	cmp    %rbx,%rbp
  40cd0e:	76 15                	jbe    40cd25 <_ZNSt5dequeISsSaISsEED1Ev+0x1f5>
  40cd10:	48 8b 3b             	mov    (%rbx),%rdi
  40cd13:	48 83 c3 08          	add    $0x8,%rbx
  40cd17:	e8 94 6e ff ff       	callq  403bb0 <_ZdlPv@plt>
  40cd1c:	48 39 dd             	cmp    %rbx,%rbp
  40cd1f:	77 ef                	ja     40cd10 <_ZNSt5dequeISsSaISsEED1Ev+0x1e0>
  40cd21:	49 8b 3c 24          	mov    (%r12),%rdi
  40cd25:	e8 86 6e ff ff       	callq  403bb0 <_ZdlPv@plt>
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       */
      ~deque() _GLIBCXX_NOEXCEPT
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
  40cd2a:	48 83 c4 48          	add    $0x48,%rsp
  40cd2e:	5b                   	pop    %rbx
  40cd2f:	5d                   	pop    %rbp
  40cd30:	41 5c                	pop    %r12
  40cd32:	41 5d                	pop    %r13
  40cd34:	41 5e                	pop    %r14
  40cd36:	41 5f                	pop    %r15
  40cd38:	c3                   	retq   
  40cd39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40cd40:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40cd43:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40cd46:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40cd49:	89 d0                	mov    %edx,%eax
  40cd4b:	e9 8f fe ff ff       	jmpq   40cbdf <_ZNSt5dequeISsSaISsEED1Ev+0xaf>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40cd50:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40cd53:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40cd56:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40cd59:	89 d0                	mov    %edx,%eax
  40cd5b:	e9 7f ff ff ff       	jmpq   40ccdf <_ZNSt5dequeISsSaISsEED1Ev+0x1af>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40cd60:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40cd63:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40cd66:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40cd69:	89 d0                	mov    %edx,%eax
  40cd6b:	e9 00 ff ff ff       	jmpq   40cc70 <_ZNSt5dequeISsSaISsEED1Ev+0x140>
  40cd70:	4d 39 d5             	cmp    %r10,%r13
  40cd73:	0f 84 7b ff ff ff    	je     40ccf4 <_ZNSt5dequeISsSaISsEED1Ev+0x1c4>
  40cd79:	48 8b 2d e0 71 20 00 	mov    0x2071e0(%rip),%rbp        # 613f60 <_DYNAMIC+0x2d8>
  40cd80:	48 8d 5c 24 3f       	lea    0x3f(%rsp),%rbx
  40cd85:	4d 89 d6             	mov    %r10,%r14
  40cd88:	eb 13                	jmp    40cd9d <_ZNSt5dequeISsSaISsEED1Ev+0x26d>
  40cd8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40cd90:	49 83 c5 08          	add    $0x8,%r13
  40cd94:	4d 39 ee             	cmp    %r13,%r14
  40cd97:	0f 84 57 ff ff ff    	je     40ccf4 <_ZNSt5dequeISsSaISsEED1Ev+0x1c4>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40cd9d:	49 8b 45 00          	mov    0x0(%r13),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40cda1:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40cda5:	48 39 ef             	cmp    %rbp,%rdi
  40cda8:	74 e6                	je     40cd90 <_ZNSt5dequeISsSaISsEED1Ev+0x260>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40cdaa:	48 83 3d c6 71 20 00 	cmpq   $0x0,0x2071c6(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40cdb1:	00 
  40cdb2:	74 1a                	je     40cdce <_ZNSt5dequeISsSaISsEED1Ev+0x29e>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40cdb4:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40cdb9:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40cdbe:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40cdc0:	85 c0                	test   %eax,%eax
  40cdc2:	7f cc                	jg     40cd90 <_ZNSt5dequeISsSaISsEED1Ev+0x260>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40cdc4:	48 89 de             	mov    %rbx,%rsi
  40cdc7:	e8 a4 6f ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40cdcc:	eb c2                	jmp    40cd90 <_ZNSt5dequeISsSaISsEED1Ev+0x260>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40cdce:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40cdd1:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40cdd4:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40cdd7:	89 d0                	mov    %edx,%eax
  40cdd9:	eb e5                	jmp    40cdc0 <_ZNSt5dequeISsSaISsEED1Ev+0x290>
  40cddb:	90                   	nop
  40cddc:	90                   	nop
  40cddd:	90                   	nop
  40cdde:	90                   	nop
  40cddf:	90                   	nop

000000000040cde0 <_ZNSt11_Deque_baseISsSaISsEE17_M_initialize_mapEm>:
   *
   *  The initial underlying memory layout is a bit complicated...
  */
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
  40cde0:	41 56                	push   %r14
  40cde2:	41 55                	push   %r13
  40cde4:	b8 08 00 00 00       	mov    $0x8,%eax
  40cde9:	41 54                	push   %r12
  40cdeb:	49 89 fc             	mov    %rdi,%r12
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
				  + 1);
  40cdee:	48 89 f7             	mov    %rsi,%rdi
  40cdf1:	48 c1 ef 06          	shr    $0x6,%rdi
   *
   *  The initial underlying memory layout is a bit complicated...
  */
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
  40cdf5:	55                   	push   %rbp
  40cdf6:	53                   	push   %rbx
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
				  + 1);
  40cdf7:	48 8d 5f 01          	lea    0x1(%rdi),%rbx

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
					   size_t(__num_nodes + 2));
  40cdfb:	48 83 c7 03          	add    $0x3,%rdi
   *
   *  The initial underlying memory layout is a bit complicated...
  */
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
  40cdff:	49 89 f5             	mov    %rsi,%r13
  40ce02:	48 83 ff 08          	cmp    $0x8,%rdi
  40ce06:	48 0f 42 f8          	cmovb  %rax,%rdi
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
				  + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
  40ce0a:	49 89 7c 24 08       	mov    %rdi,0x8(%r12)
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40ce0f:	48 c1 e7 03          	shl    $0x3,%rdi
  40ce13:	e8 68 73 ff ff       	callq  404180 <_Znwm@plt>
      // starts in the middle elements and grows outwards.  So nstart may be
      // the beginning of _M_map, but for small maps it may be as far in as
      // _M_map+3.

      _Tp** __nstart = (this->_M_impl._M_map
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
  40ce18:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
				  + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
					   size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
  40ce1d:	49 89 04 24          	mov    %rax,(%r12)
      // starts in the middle elements and grows outwards.  So nstart may be
      // the beginning of _M_map, but for small maps it may be as far in as
      // _M_map+3.

      _Tp** __nstart = (this->_M_impl._M_map
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
  40ce21:	48 29 da             	sub    %rbx,%rdx
  40ce24:	48 d1 ea             	shr    %rdx
  40ce27:	4c 8d 34 d0          	lea    (%rax,%rdx,8),%r14
      _Tp** __nfinish = __nstart + __num_nodes;
  40ce2b:	49 8d 2c de          	lea    (%r14,%rbx,8),%rbp
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
  40ce2f:	49 39 ee             	cmp    %rbp,%r14
  40ce32:	73 22                	jae    40ce56 <_ZNSt11_Deque_baseISsSaISsEE17_M_initialize_mapEm+0x76>
  40ce34:	4c 89 f3             	mov    %r14,%rbx
  40ce37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40ce3e:	00 00 
  40ce40:	bf 00 02 00 00       	mov    $0x200,%edi
  40ce45:	e8 36 73 ff ff       	callq  404180 <_Znwm@plt>
	    *__cur = this->_M_allocate_node();
  40ce4a:	48 89 03             	mov    %rax,(%rbx)
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
  40ce4d:	48 83 c3 08          	add    $0x8,%rbx
  40ce51:	48 39 dd             	cmp    %rbx,%rbp
  40ce54:	77 ea                	ja     40ce40 <_ZNSt11_Deque_baseISsSaISsEE17_M_initialize_mapEm+0x60>
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
  40ce56:	4d 89 74 24 28       	mov    %r14,0x28(%r12)
	_M_first = *__new_node;
  40ce5b:	49 8b 16             	mov    (%r14),%rdx

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
					+ __num_elements
  40ce5e:	41 83 e5 3f          	and    $0x3f,%r13d
					% __deque_buf_size(sizeof(_Tp)));
    }
  40ce62:	5b                   	pop    %rbx
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
	_M_last = _M_first + difference_type(_S_buffer_size());
  40ce63:	48 8d 82 00 02 00 00 	lea    0x200(%rdx),%rax
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40ce6a:	49 89 54 24 18       	mov    %rdx,0x18(%r12)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40ce6f:	49 89 44 24 20       	mov    %rax,0x20(%r12)
	  this->_M_impl._M_map_size = 0;
	  __throw_exception_again;
	}

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
  40ce74:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  40ce78:	49 89 44 24 48       	mov    %rax,0x48(%r12)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40ce7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
					+ __num_elements
					% __deque_buf_size(sizeof(_Tp)));
    }
  40ce81:	5d                   	pop    %rbp
	  __throw_exception_again;
	}

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
  40ce82:	49 89 54 24 10       	mov    %rdx,0x10(%r12)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40ce87:	49 89 44 24 38       	mov    %rax,0x38(%r12)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40ce8c:	48 8d 88 00 02 00 00 	lea    0x200(%rax),%rcx

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
					+ __num_elements
  40ce93:	4a 8d 04 e8          	lea    (%rax,%r13,8),%rax
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
	_M_last = _M_first + difference_type(_S_buffer_size());
  40ce97:	49 89 4c 24 40       	mov    %rcx,0x40(%r12)

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
					+ __num_elements
  40ce9c:	49 89 44 24 30       	mov    %rax,0x30(%r12)
					% __deque_buf_size(sizeof(_Tp)));
    }
  40cea1:	41 5c                	pop    %r12
  40cea3:	41 5d                	pop    %r13
  40cea5:	41 5e                	pop    %r14
  40cea7:	c3                   	retq   
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
	    *__cur = this->_M_allocate_node();
	}
      __catch(...)
  40cea8:	48 89 c7             	mov    %rax,%rdi
  40ceab:	e8 50 72 ff ff       	callq  404100 <__cxa_begin_catch@plt>
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
  40ceb0:	4c 39 f3             	cmp    %r14,%rbx
  40ceb3:	76 11                	jbe    40cec6 <_ZNSt11_Deque_baseISsSaISsEE17_M_initialize_mapEm+0xe6>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40ceb5:	49 8b 3e             	mov    (%r14),%rdi
  40ceb8:	49 83 c6 08          	add    $0x8,%r14
  40cebc:	e8 ef 6c ff ff       	callq  403bb0 <_ZdlPv@plt>
  40cec1:	4c 39 f3             	cmp    %r14,%rbx
  40cec4:	77 ef                	ja     40ceb5 <_ZNSt11_Deque_baseISsSaISsEE17_M_initialize_mapEm+0xd5>
	    *__cur = this->_M_allocate_node();
	}
      __catch(...)
	{
	  _M_destroy_nodes(__nstart, __cur);
	  __throw_exception_again;
  40cec6:	e8 55 6d ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40cecb:	48 89 c3             	mov    %rax,%rbx
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
	    *__cur = this->_M_allocate_node();
	}
      __catch(...)
  40cece:	e8 ad 71 ff ff       	callq  404080 <__cxa_end_catch@plt>
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      __try
	{ _M_create_nodes(__nstart, __nfinish); }
      __catch(...)
  40ced3:	48 89 df             	mov    %rbx,%rdi
  40ced6:	e8 25 72 ff ff       	callq  404100 <__cxa_begin_catch@plt>
  40cedb:	49 8b 3c 24          	mov    (%r12),%rdi
  40cedf:	e8 cc 6c ff ff       	callq  403bb0 <_ZdlPv@plt>
	{
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
	  this->_M_impl._M_map = 0;
  40cee4:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
  40ceeb:	00 
	  this->_M_impl._M_map_size = 0;
  40ceec:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
  40cef3:	00 00 
	  __throw_exception_again;
  40cef5:	e8 26 6d ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40cefa:	48 89 c3             	mov    %rax,%rbx
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      __try
	{ _M_create_nodes(__nstart, __nfinish); }
      __catch(...)
  40cefd:	e8 7e 71 ff ff       	callq  404080 <__cxa_end_catch@plt>
  40cf02:	48 89 df             	mov    %rbx,%rdi
  40cf05:	e8 96 72 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40cf0a:	90                   	nop
  40cf0b:	90                   	nop
  40cf0c:	90                   	nop
  40cf0d:	90                   	nop
  40cf0e:	90                   	nop
  40cf0f:	90                   	nop

000000000040cf10 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_>:
  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.
  template<typename _Tp, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
  40cf10:	41 57                	push   %r15
  40cf12:	41 56                	push   %r14
  40cf14:	41 55                	push   %r13
  40cf16:	41 54                	push   %r12
  40cf18:	49 89 f4             	mov    %rsi,%r12
  40cf1b:	55                   	push   %rbp
  40cf1c:	53                   	push   %rbx
  40cf1d:	48 89 fb             	mov    %rdi,%rbx
  40cf20:	48 83 ec 08          	sub    $0x8,%rsp
       *  (And consequently, %deque iterators.)
       */
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
  40cf24:	48 8b 6f 48          	mov    0x48(%rdi),%rbp
  40cf28:	48 8b 0f             	mov    (%rdi),%rcx
  40cf2b:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  40cf2f:	48 89 e8             	mov    %rbp,%rax
  40cf32:	48 29 c8             	sub    %rcx,%rax
  40cf35:	48 89 d6             	mov    %rdx,%rsi
  40cf38:	48 c1 f8 03          	sar    $0x3,%rax
  40cf3c:	48 29 c6             	sub    %rax,%rsi
  40cf3f:	48 83 fe 01          	cmp    $0x1,%rsi
  40cf43:	76 5b                	jbe    40cfa0 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x90>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40cf45:	bf 00 02 00 00       	mov    $0x200,%edi
  40cf4a:	e8 31 72 ff ff       	callq  404180 <_Znwm@plt>
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)
#endif
      {
	_M_reserve_map_at_back();
	*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
  40cf4f:	48 89 45 08          	mov    %rax,0x8(%rbp)
	__try
	  {
#if __cplusplus >= 201103L
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
  40cf53:	48 8b 7b 30          	mov    0x30(%rbx),%rdi

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40cf57:	48 85 ff             	test   %rdi,%rdi
  40cf5a:	74 08                	je     40cf64 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x54>
  40cf5c:	4c 89 e6             	mov    %r12,%rsi
  40cf5f:	e8 5c 6d ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
				    std::forward<_Args>(__args)...);
#else
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
#endif
	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
  40cf64:	48 8b 43 48          	mov    0x48(%rbx),%rax
  40cf68:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40cf6c:	48 89 53 48          	mov    %rdx,0x48(%rbx)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40cf70:	48 8b 40 08          	mov    0x8(%rax),%rax
	_M_last = _M_first + difference_type(_S_buffer_size());
  40cf74:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40cf7b:	48 89 43 38          	mov    %rax,0x38(%rbx)
						+ 1);
	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
  40cf7f:	48 89 43 30          	mov    %rax,0x30(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40cf83:	48 89 53 40          	mov    %rdx,0x40(%rbx)
	__catch(...)
	  {
	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
	    __throw_exception_again;
	  }
      }
  40cf87:	48 83 c4 08          	add    $0x8,%rsp
  40cf8b:	5b                   	pop    %rbx
  40cf8c:	5d                   	pop    %rbp
  40cf8d:	41 5c                	pop    %r12
  40cf8f:	41 5d                	pop    %r13
  40cf91:	41 5e                	pop    %r14
  40cf93:	41 5f                	pop    %r15
  40cf95:	c3                   	retq   
  40cf96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40cf9d:	00 00 00 
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
  40cfa0:	48 8b 77 28          	mov    0x28(%rdi),%rsi
  40cfa4:	48 89 e8             	mov    %rbp,%rax
  40cfa7:	48 29 f0             	sub    %rsi,%rax
  40cfaa:	48 c1 f8 03          	sar    $0x3,%rax
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
  40cfae:	4c 8d 70 02          	lea    0x2(%rax),%r14
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
  40cfb2:	4c 8d 68 01          	lea    0x1(%rax),%r13
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
  40cfb6:	4b 8d 04 36          	lea    (%r14,%r14,1),%rax
  40cfba:	48 39 c2             	cmp    %rax,%rdx
  40cfbd:	0f 87 ad 00 00 00    	ja     40d070 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x160>
  40cfc3:	48 85 d2             	test   %rdx,%rdx
  40cfc6:	0f 84 d4 00 00 00    	je     40d0a0 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x190>
	}
      else
	{
	  size_type __new_map_size = this->_M_impl._M_map_size
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;
  40cfcc:	48 8d 6c 12 02       	lea    0x2(%rdx,%rdx,1),%rbp
      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
  40cfd1:	48 b8 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rax
  40cfd8:	ff ff 1f 
  40cfdb:	48 39 c5             	cmp    %rax,%rbp
  40cfde:	0f 87 0a 01 00 00    	ja     40d0ee <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x1de>
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40cfe4:	48 8d 3c ed 00 00 00 	lea    0x0(,%rbp,8),%rdi
  40cfeb:	00 
  40cfec:	e8 8f 71 ff ff       	callq  404180 <_Znwm@plt>

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
  40cff1:	48 89 ea             	mov    %rbp,%rdx
  40cff4:	49 89 c7             	mov    %rax,%r15
	  std::copy(this->_M_impl._M_start._M_node,
		    this->_M_impl._M_finish._M_node + 1,
		    __new_nstart);
  40cff7:	48 8b 73 28          	mov    0x28(%rbx),%rsi
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
  40cffb:	4c 29 f2             	sub    %r14,%rdx
  40cffe:	48 d1 ea             	shr    %rdx
	  size_type __new_map_size = this->_M_impl._M_map_size
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
  40d001:	4c 8d 34 d0          	lea    (%rax,%rdx,8),%r14
	                 + (__add_at_front ? __nodes_to_add : 0);
	  std::copy(this->_M_impl._M_start._M_node,
		    this->_M_impl._M_finish._M_node + 1,
		    __new_nstart);
  40d005:	48 8b 43 48          	mov    0x48(%rbx),%rax
  40d009:	48 8d 50 08          	lea    0x8(%rax),%rdx
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40d00d:	48 29 f2             	sub    %rsi,%rdx
  40d010:	48 89 d0             	mov    %rdx,%rax
  40d013:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40d017:	48 85 c0             	test   %rax,%rax
  40d01a:	0f 85 90 00 00 00    	jne    40d0b0 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x1a0>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40d020:	48 8b 3b             	mov    (%rbx),%rdi
  40d023:	e8 88 6b ff ff       	callq  403bb0 <_ZdlPv@plt>
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

	  this->_M_impl._M_map = __new_map;
  40d028:	4c 89 3b             	mov    %r15,(%rbx)
	  this->_M_impl._M_map_size = __new_map_size;
  40d02b:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
  40d02f:	49 c1 e5 03          	shl    $0x3,%r13
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
  40d033:	4c 89 73 28          	mov    %r14,0x28(%rbx)
	_M_first = *__new_node;
  40d037:	49 8b 06             	mov    (%r14),%rax
	}

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
  40d03a:	4b 8d 6c 2e f8       	lea    -0x8(%r14,%r13,1),%rbp
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
  40d03f:	48 89 6b 48          	mov    %rbp,0x48(%rbx)
	_M_first = *__new_node;
  40d043:	48 89 43 18          	mov    %rax,0x18(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40d047:	48 05 00 02 00 00    	add    $0x200,%rax
  40d04d:	48 89 43 20          	mov    %rax,0x20(%rbx)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40d051:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40d055:	48 89 43 38          	mov    %rax,0x38(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40d059:	48 05 00 02 00 00    	add    $0x200,%rax
  40d05f:	48 89 43 40          	mov    %rax,0x40(%rbx)
  40d063:	e9 dd fe ff ff       	jmpq   40cf45 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x35>
  40d068:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40d06f:	00 
      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
	{
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
					 - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
  40d070:	4c 29 f2             	sub    %r14,%rdx
  40d073:	48 d1 ea             	shr    %rdx
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
	{
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
  40d076:	4c 8d 34 d1          	lea    (%rcx,%rdx,8),%r14
					 - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
	  if (__new_nstart < this->_M_impl._M_start._M_node)
  40d07a:	4c 39 f6             	cmp    %r14,%rsi
  40d07d:	76 41                	jbe    40d0c0 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x1b0>
	    std::copy(this->_M_impl._M_start._M_node,
		      this->_M_impl._M_finish._M_node + 1,
		      __new_nstart);
  40d07f:	48 8d 55 08          	lea    0x8(%rbp),%rdx
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40d083:	48 29 f2             	sub    %rsi,%rdx
  40d086:	48 89 d0             	mov    %rdx,%rax
  40d089:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40d08d:	48 85 c0             	test   %rax,%rax
  40d090:	74 9d                	je     40d02f <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x11f>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
  40d092:	4c 89 f7             	mov    %r14,%rdi
  40d095:	49 c1 e5 03          	shl    $0x3,%r13
  40d099:	e8 22 6e ff ff       	callq  403ec0 <memmove@plt>
  40d09e:	eb 93                	jmp    40d033 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x123>
	}
      else
	{
	  size_type __new_map_size = this->_M_impl._M_map_size
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;
  40d0a0:	bd 03 00 00 00       	mov    $0x3,%ebp
  40d0a5:	e9 3a ff ff ff       	jmpq   40cfe4 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0xd4>
  40d0aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40d0b0:	4c 89 f7             	mov    %r14,%rdi
  40d0b3:	e8 08 6e ff ff       	callq  403ec0 <memmove@plt>
  40d0b8:	e9 63 ff ff ff       	jmpq   40d020 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x110>
  40d0bd:	0f 1f 00             	nopl   (%rax)
		      this->_M_impl._M_finish._M_node + 1,
		      __new_nstart);
	  else
	    std::copy_backward(this->_M_impl._M_start._M_node,
			       this->_M_impl._M_finish._M_node + 1,
			       __new_nstart + __old_num_nodes);
  40d0c0:	48 8d 55 08          	lea    0x8(%rbp),%rdx
  40d0c4:	49 c1 e5 03          	shl    $0x3,%r13
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40d0c8:	48 29 f2             	sub    %rsi,%rdx
  40d0cb:	48 89 d0             	mov    %rdx,%rax
  40d0ce:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40d0d2:	48 85 c0             	test   %rax,%rax
  40d0d5:	0f 84 58 ff ff ff    	je     40d033 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x123>
  40d0db:	4c 89 ef             	mov    %r13,%rdi
  40d0de:	48 29 d7             	sub    %rdx,%rdi
	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
  40d0e1:	4c 01 f7             	add    %r14,%rdi
  40d0e4:	e8 d7 6d ff ff       	callq  403ec0 <memmove@plt>
  40d0e9:	e9 45 ff ff ff       	jmpq   40d033 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_+0x123>
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();
  40d0ee:	e8 9d 6f ff ff       	callq  404090 <_ZSt17__throw_bad_allocv@plt>
#endif
	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
						+ 1);
	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
	  }
	__catch(...)
  40d0f3:	48 89 c7             	mov    %rax,%rdi
  40d0f6:	e8 05 70 ff ff       	callq  404100 <__cxa_begin_catch@plt>
	  {
	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
  40d0fb:	48 8b 43 48          	mov    0x48(%rbx),%rax
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40d0ff:	48 8b 78 08          	mov    0x8(%rax),%rdi
  40d103:	e8 a8 6a ff ff       	callq  403bb0 <_ZdlPv@plt>
	    __throw_exception_again;
  40d108:	e8 13 6b ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40d10d:	48 89 c3             	mov    %rax,%rbx
#endif
	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
						+ 1);
	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
	  }
	__catch(...)
  40d110:	e8 6b 6f ff ff       	callq  404080 <__cxa_end_catch@plt>
  40d115:	48 89 df             	mov    %rbx,%rdi
  40d118:	e8 83 70 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40d11d:	90                   	nop
  40d11e:	90                   	nop
  40d11f:	90                   	nop

000000000040d120 <_ZN10LoggerImpl5doLogEiPKciS1_z>:
            _config.file = file;
            openLogFile();
        }
    }

    virtual void doLog(int level, const char* file, const int line, const char* format, ...)
  40d120:	41 57                	push   %r15
  40d122:	41 56                	push   %r14
  40d124:	41 89 ce             	mov    %ecx,%r14d
  40d127:	41 55                	push   %r13
  40d129:	41 54                	push   %r12
  40d12b:	49 89 d5             	mov    %rdx,%r13
  40d12e:	55                   	push   %rbp
  40d12f:	53                   	push   %rbx
  40d130:	48 63 ee             	movslq %esi,%rbp
  40d133:	48 89 fb             	mov    %rdi,%rbx
  40d136:	48 81 ec a8 01 00 00 	sub    $0x1a8,%rsp
  40d13d:	84 c0                	test   %al,%al
  40d13f:	4c 89 8c 24 18 01 00 	mov    %r9,0x118(%rsp)
  40d146:	00 
  40d147:	74 40                	je     40d189 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x69>
  40d149:	0f 29 84 24 20 01 00 	movaps %xmm0,0x120(%rsp)
  40d150:	00 
  40d151:	0f 29 8c 24 30 01 00 	movaps %xmm1,0x130(%rsp)
  40d158:	00 
  40d159:	0f 29 94 24 40 01 00 	movaps %xmm2,0x140(%rsp)
  40d160:	00 
  40d161:	0f 29 9c 24 50 01 00 	movaps %xmm3,0x150(%rsp)
  40d168:	00 
  40d169:	0f 29 a4 24 60 01 00 	movaps %xmm4,0x160(%rsp)
  40d170:	00 
  40d171:	0f 29 ac 24 70 01 00 	movaps %xmm5,0x170(%rsp)
  40d178:	00 
  40d179:	0f 29 b4 24 80 01 00 	movaps %xmm6,0x180(%rsp)
  40d180:	00 
  40d181:	0f 29 bc 24 90 01 00 	movaps %xmm7,0x190(%rsp)
  40d188:	00 
class Guard
{
public:
    Guard(Mutex& mutex) : _mutex(&mutex)
    {
        if (_mutex)
  40d189:	49 89 dc             	mov    %rbx,%r12
  40d18c:	4d 89 c7             	mov    %r8,%r15
  40d18f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40d196:	00 00 
  40d198:	48 89 84 24 e8 00 00 	mov    %rax,0xe8(%rsp)
  40d19f:	00 
  40d1a0:	31 c0                	xor    %eax,%eax
  40d1a2:	49 81 c4 b8 08 00 00 	add    $0x8b8,%r12
  40d1a9:	74 75                	je     40d220 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x100>
        }
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&_mutex);
  40d1ab:	4c 89 e7             	mov    %r12,%rdi
  40d1ae:	e8 6d 6f ff ff       	callq  404120 <pthread_mutex_lock@plt>
        assert(ret == 0);
  40d1b3:	85 c0                	test   %eax,%eax
  40d1b5:	0f 85 72 07 00 00    	jne    40d92d <_ZN10LoggerImpl5doLogEiPKciS1_z+0x80d>
    {
        Guard guard(_mutex);

        if (level < _config.level) return;
  40d1bb:	3b 6b 20             	cmp    0x20(%rbx),%ebp
  40d1be:	7d 65                	jge    40d225 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x105>
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40d1c0:	4c 89 e7             	mov    %r12,%rdi
  40d1c3:	e8 08 70 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40d1c8:	48 8d 3d dc 36 00 00 	lea    0x36dc(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40d1cf:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40d1d1:	e8 5a 6f ff ff       	callq  404130 <perror@plt>
}

__extern_always_inline int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40d1d6:	48 8d 35 e3 36 00 00 	lea    0x36e3(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40d1dd:	31 c0                	xor    %eax,%eax
  40d1df:	4c 89 e1             	mov    %r12,%rcx
  40d1e2:	89 da                	mov    %ebx,%edx
  40d1e4:	bf 01 00 00 00       	mov    $0x1,%edi
  40d1e9:	e8 12 6a ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40d1ee:	85 db                	test   %ebx,%ebx
  40d1f0:	0f 85 87 03 00 00    	jne    40d57d <_ZN10LoggerImpl5doLogEiPKciS1_z+0x45d>
        {
            fprintf(_file, "%s\n", _log_buf);
            fflush(_file);
            _size += len + 1;
        }
    }
  40d1f6:	48 8b 84 24 e8 00 00 	mov    0xe8(%rsp),%rax
  40d1fd:	00 
  40d1fe:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40d205:	00 00 
  40d207:	0f 85 1b 07 00 00    	jne    40d928 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x808>
  40d20d:	48 81 c4 a8 01 00 00 	add    $0x1a8,%rsp
  40d214:	5b                   	pop    %rbx
  40d215:	5d                   	pop    %rbp
  40d216:	41 5c                	pop    %r12
  40d218:	41 5d                	pop    %r13
  40d21a:	41 5e                	pop    %r14
  40d21c:	41 5f                	pop    %r15
  40d21e:	c3                   	retq   
  40d21f:	90                   	nop

    virtual void doLog(int level, const char* file, const int line, const char* format, ...)
    {
        Guard guard(_mutex);

        if (level < _config.level) return;
  40d220:	3b 6b 20             	cmp    0x20(%rbx),%ebp
  40d223:	7c d1                	jl     40d1f6 <_ZN10LoggerImpl5doLogEiPKciS1_z+0xd6>
  40d225:	83 fd 03             	cmp    $0x3,%ebp
  40d228:	be 03 00 00 00       	mov    $0x3,%esi
  40d22d:	48 0f 4f ee          	cmovg  %rsi,%rbp

        if (level > LEVEL_ERROR) level = LEVEL_ERROR;

        // if (!_initialized) return;

        std::time_t tt = time(NULL);
  40d231:	31 ff                	xor    %edi,%edi
  40d233:	e8 68 70 ff ff       	callq  4042a0 <time@plt>
        _tm_now = *localtime(&tt);
  40d238:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi

        if (level > LEVEL_ERROR) level = LEVEL_ERROR;

        // if (!_initialized) return;

        std::time_t tt = time(NULL);
  40d23d:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
        _tm_now = *localtime(&tt);
  40d242:	e8 09 6f ff ff       	callq  404150 <localtime@plt>
  40d247:	48 8b 10             	mov    (%rax),%rdx
        }
    }

    void closeLogFile()
    {
        if (_file)
  40d24a:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
        if (level > LEVEL_ERROR) level = LEVEL_ERROR;

        // if (!_initialized) return;

        std::time_t tt = time(NULL);
        _tm_now = *localtime(&tt);
  40d24e:	48 89 53 78          	mov    %rdx,0x78(%rbx)
  40d252:	48 8b 50 08          	mov    0x8(%rax),%rdx
  40d256:	48 89 93 80 00 00 00 	mov    %rdx,0x80(%rbx)
  40d25d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  40d261:	48 89 93 88 00 00 00 	mov    %rdx,0x88(%rbx)
  40d268:	48 8b 50 18          	mov    0x18(%rax),%rdx
  40d26c:	48 89 93 90 00 00 00 	mov    %rdx,0x90(%rbx)
  40d273:	48 8b 50 20          	mov    0x20(%rax),%rdx
  40d277:	48 89 93 98 00 00 00 	mov    %rdx,0x98(%rbx)
  40d27e:	48 8b 50 28          	mov    0x28(%rax),%rdx
  40d282:	48 89 93 a0 00 00 00 	mov    %rdx,0xa0(%rbx)
  40d289:	48 8b 40 30          	mov    0x30(%rax),%rax
  40d28d:	48 89 83 a8 00 00 00 	mov    %rax,0xa8(%rbx)
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40d294:	48 8b 43 18          	mov    0x18(%rbx),%rax
        }
    }

    void rotateLogFile()
    {
        if (_config.file.empty())
  40d298:	48 83 78 e8 00       	cmpq   $0x0,-0x18(%rax)
  40d29d:	0f 85 e5 02 00 00    	jne    40d588 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x468>
        }
    }

    void closeLogFile()
    {
        if (_file)
  40d2a3:	48 85 ff             	test   %rdi,%rdi
  40d2a6:	0f 84 24 01 00 00    	je     40d3d0 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b0>
        {
            fclose(_file);
  40d2ac:	e8 5f 6d ff ff       	callq  404010 <fclose@plt>
            _file = NULL;
  40d2b1:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  40d2b8:	00 
  40d2b9:	8b 8b 84 00 00 00    	mov    0x84(%rbx),%ecx
  40d2bf:	e9 12 01 00 00       	jmpq   40d3d6 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b6>
  40d2c4:	0f 1f 40 00          	nopl   0x0(%rax)
        }
    }

    std::string getLogFileName(struct tm xtm)
    {
        if (_config.file.empty()) return "";
  40d2c8:	48 8d 54 24 1f       	lea    0x1f(%rsp),%rdx
  40d2cd:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
  40d2d2:	48 8d 35 4b 31 00 00 	lea    0x314b(%rip),%rsi        # 410424 <_ZStL19piecewise_construct+0x8>
  40d2d9:	e8 42 6b ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40d2de:	48 8b 05 7b 6c 20 00 	mov    0x206c7b(%rip),%rax        # 613f60 <_DYNAMIC+0x2d8>
  40d2e5:	48 89 04 24          	mov    %rax,(%rsp)
                _file_queue.pop();
            }

            closeLogFile();
            std::string baklog = getLogFileName(_tm_rotate);
            rename(_config.file.c_str(), baklog.c_str());
  40d2e9:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  40d2ed:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  40d2f2:	e8 89 6f ff ff       	callq  404280 <rename@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40d2f7:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
    }

protected:
    void openLogFile()
    {
        if (_config.file.empty())
  40d2fb:	48 83 7f e8 00       	cmpq   $0x0,-0x18(%rdi)
  40d300:	0f 85 b2 04 00 00    	jne    40d7b8 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x698>
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish._M_cur
	    != this->_M_impl._M_finish._M_last - 1)
  40d306:	48 8b 83 28 09 00 00 	mov    0x928(%rbx),%rax
       *  done in constant time.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish._M_cur
  40d30d:	48 8b bb 18 09 00 00 	mov    0x918(%rbx),%rdi
	    != this->_M_impl._M_finish._M_last - 1)
  40d314:	48 83 e8 08          	sub    $0x8,%rax
       *  done in constant time.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish._M_cur
  40d318:	48 39 c7             	cmp    %rax,%rdi
  40d31b:	0f 84 3f 05 00 00    	je     40d860 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x740>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40d321:	48 85 ff             	test   %rdi,%rdi
  40d324:	74 11                	je     40d337 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x217>
  40d326:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  40d32b:	e8 90 69 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
  40d330:	48 8b bb 18 09 00 00 	mov    0x918(%rbx),%rdi
	    != this->_M_impl._M_finish._M_last - 1)
	  {
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
	    ++this->_M_impl._M_finish._M_cur;
  40d337:	48 83 c7 08          	add    $0x8,%rdi
  40d33b:	48 89 bb 18 09 00 00 	mov    %rdi,0x918(%rbx)
            std::string baklog = getLogFileName(_tm_rotate);
            rename(_config.file.c_str(), baklog.c_str());
            openLogFile();

            _file_queue.push(baklog);
            _tm_rotate = _tm_now;
  40d342:	48 8b 43 78          	mov    0x78(%rbx),%rax
            _size = 0;
  40d346:	48 c7 83 b0 00 00 00 	movq   $0x0,0xb0(%rbx)
  40d34d:	00 00 00 00 
            std::string baklog = getLogFileName(_tm_rotate);
            rename(_config.file.c_str(), baklog.c_str());
            openLogFile();

            _file_queue.push(baklog);
            _tm_rotate = _tm_now;
  40d351:	48 89 43 40          	mov    %rax,0x40(%rbx)
  40d355:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
  40d35c:	48 89 43 48          	mov    %rax,0x48(%rbx)
  40d360:	48 8b 83 88 00 00 00 	mov    0x88(%rbx),%rax
  40d367:	48 89 43 50          	mov    %rax,0x50(%rbx)
  40d36b:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
  40d372:	48 89 43 58          	mov    %rax,0x58(%rbx)
  40d376:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
  40d37d:	48 89 43 60          	mov    %rax,0x60(%rbx)
  40d381:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
  40d388:	48 89 43 68          	mov    %rax,0x68(%rbx)
  40d38c:	48 8b 83 a8 00 00 00 	mov    0xa8(%rbx),%rax
  40d393:	48 89 43 70          	mov    %rax,0x70(%rbx)
  40d397:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40d39c:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40d3a0:	48 3b 3c 24          	cmp    (%rsp),%rdi
  40d3a4:	74 2a                	je     40d3d0 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b0>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40d3a6:	48 83 3d ca 6b 20 00 	cmpq   $0x0,0x206bca(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40d3ad:	00 
  40d3ae:	0f 84 c2 04 00 00    	je     40d876 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x756>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40d3b4:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40d3b9:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40d3be:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40d3c0:	85 c0                	test   %eax,%eax
  40d3c2:	7f 0c                	jg     40d3d0 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b0>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40d3c4:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
  40d3c9:	e8 a2 69 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40d3ce:	66 90                	xchg   %ax,%ax
  40d3d0:	8b 8b 84 00 00 00    	mov    0x84(%rbx),%ecx
        std::time_t tt = time(NULL);
        _tm_now = *localtime(&tt);

        rotateLogFile();

        const char* level_str[] = { "DEBUG", "INFO ", "WARN ", "ERROR" };
  40d3d6:	48 8d 05 68 35 00 00 	lea    0x3568(%rip),%rax        # 410945 <_ZTSN6rocket12EpollWrapperE+0x365>
}

__extern_always_inline __const char *
strrchr (__const char *__s, int __c) __THROW
{
  return __builtin_strrchr (__s, __c);
  40d3dd:	4c 89 ef             	mov    %r13,%rdi
  40d3e0:	be 2f 00 00 00       	mov    $0x2f,%esi
  40d3e5:	89 0c 24             	mov    %ecx,(%rsp)
  40d3e8:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  40d3ed:	48 8d 05 57 35 00 00 	lea    0x3557(%rip),%rax        # 41094b <_ZTSN6rocket12EpollWrapperE+0x36b>
  40d3f4:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  40d3f9:	48 8d 05 51 35 00 00 	lea    0x3551(%rip),%rax        # 410951 <_ZTSN6rocket12EpollWrapperE+0x371>
  40d400:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  40d405:	48 8d 05 4b 35 00 00 	lea    0x354b(%rip),%rax        # 410957 <_ZTSN6rocket12EpollWrapperE+0x377>
  40d40c:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
  40d411:	e8 ca 69 ff ff       	callq  403de0 <strrchr@plt>
    const char* filename(const char* path)
    {
        const char* name = strrchr(path, '/');
        if (name)
        {
            return name + 1;
  40d416:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40d41a:	48 85 c0             	test   %rax,%rax
                      _tm_now.tm_hour,
                      _tm_now.tm_min,
                      _tm_now.tm_sec,
                      level_str[level],
                      filename(file),
                      line);
  40d41d:	8b bb 88 00 00 00    	mov    0x88(%rbx),%edi
#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
				  __bos (__s), __fmt, __va_arg_pack ());
  40d423:	be 01 00 00 00       	mov    $0x1,%esi
    const char* filename(const char* path)
    {
        const char* name = strrchr(path, '/');
        if (name)
        {
            return name + 1;
  40d428:	48 89 d0             	mov    %rdx,%rax
                      _tm_now.tm_hour,
                      _tm_now.tm_min,
                      _tm_now.tm_sec,
                      level_str[level],
                      filename(file),
                      line);
  40d42b:	8b 93 8c 00 00 00    	mov    0x8c(%rbx),%edx
    const char* filename(const char* path)
    {
        const char* name = strrchr(path, '/');
        if (name)
        {
            return name + 1;
  40d431:	49 0f 44 c5          	cmove  %r13,%rax
  40d435:	48 83 ec 08          	sub    $0x8,%rsp
                      _tm_now.tm_hour,
                      _tm_now.tm_min,
                      _tm_now.tm_sec,
                      level_str[level],
                      filename(file),
                      line);
  40d439:	4c 8d ab b8 00 00 00 	lea    0xb8(%rbx),%r13
  40d440:	41 56                	push   %r14
  40d442:	50                   	push   %rax
  40d443:	44 8d 4f 01          	lea    0x1(%rdi),%r9d
  40d447:	8b 43 78             	mov    0x78(%rbx),%eax
  40d44a:	ff 74 ec 78          	pushq  0x78(%rsp,%rbp,8)
  40d44e:	44 8d 82 6c 07 00 00 	lea    0x76c(%rdx),%r8d
  40d455:	4c 89 ef             	mov    %r13,%rdi
  40d458:	ba 00 08 00 00       	mov    $0x800,%edx
        {
            len += ret;
        }
        else
        {
            len += LOG_BUF_SIZE - len - 1;
  40d45d:	bd ff 07 00 00       	mov    $0x7ff,%ebp
  40d462:	50                   	push   %rax
  40d463:	8b 43 7c             	mov    0x7c(%rbx),%eax
  40d466:	50                   	push   %rax
  40d467:	8b 83 80 00 00 00    	mov    0x80(%rbx),%eax
  40d46d:	50                   	push   %rax
  40d46e:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
  40d472:	31 c0                	xor    %eax,%eax
  40d474:	51                   	push   %rcx
  40d475:	48 8d 0d e4 34 00 00 	lea    0x34e4(%rip),%rcx        # 410960 <_ZTSN6rocket12EpollWrapperE+0x380>
  40d47c:	e8 2f 6c ff ff       	callq  4040b0 <__sprintf_chk@plt>
  40d481:	41 89 c6             	mov    %eax,%r14d
                      filename(file),
                      line);

        va_list ap;

        va_start(ap, format);
  40d484:	48 8d 84 24 20 02 00 	lea    0x220(%rsp),%rax
  40d48b:	00 
  40d48c:	c7 84 24 88 00 00 00 	movl   $0x28,0x88(%rsp)
  40d493:	28 00 00 00 
  40d497:	c7 84 24 8c 00 00 00 	movl   $0x30,0x8c(%rsp)
  40d49e:	30 00 00 00 

        int ret = vsnprintf(_log_buf + len, LOG_BUF_SIZE - len, format, ap);
  40d4a2:	be 00 08 00 00       	mov    $0x800,%esi
__extern_always_inline int
__NTH (vsnprintf (char *__restrict __s, size_t __n,
		  __const char *__restrict __fmt, _G_va_list __ap))
{
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
				    __bos (__s), __fmt, __ap);
  40d4a7:	4d 89 f8             	mov    %r15,%r8
                      filename(file),
                      line);

        va_list ap;

        va_start(ap, format);
  40d4aa:	48 89 84 24 90 00 00 	mov    %rax,0x90(%rsp)
  40d4b1:	00 
  40d4b2:	48 8d 84 24 30 01 00 	lea    0x130(%rsp),%rax
  40d4b9:	00 

        int ret = vsnprintf(_log_buf + len, LOG_BUF_SIZE - len, format, ap);
  40d4ba:	44 29 f6             	sub    %r14d,%esi
  40d4bd:	48 63 f6             	movslq %esi,%rsi
  40d4c0:	48 c7 c1 ff ff ff ff 	mov    $0xffffffffffffffff,%rcx
  40d4c7:	ba 01 00 00 00       	mov    $0x1,%edx
                      filename(file),
                      line);

        va_list ap;

        va_start(ap, format);
  40d4cc:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
  40d4d3:	00 
  40d4d4:	48 83 c4 40          	add    $0x40,%rsp

        int ret = vsnprintf(_log_buf + len, LOG_BUF_SIZE - len, format, ap);
  40d4d8:	49 63 c6             	movslq %r14d,%rax
  40d4db:	48 8d bc 03 b8 00 00 	lea    0xb8(%rbx,%rax,1),%rdi
  40d4e2:	00 
  40d4e3:	4c 8d 4c 24 48       	lea    0x48(%rsp),%r9
  40d4e8:	e8 33 68 ff ff       	callq  403d20 <__vsnprintf_chk@plt>

        if (ret > 0 && ret < LOG_BUF_SIZE - len - 1)
  40d4ed:	85 c0                	test   %eax,%eax
  40d4ef:	7e 0e                	jle    40d4ff <_ZN10LoggerImpl5doLogEiPKciS1_z+0x3df>
  40d4f1:	89 ea                	mov    %ebp,%edx
  40d4f3:	44 29 f2             	sub    %r14d,%edx
        {
            len += ret;
  40d4f6:	41 01 c6             	add    %eax,%r14d
  40d4f9:	39 c2                	cmp    %eax,%edx
  40d4fb:	41 0f 4f ee          	cmovg  %r14d,%ebp
            len += LOG_BUF_SIZE - len - 1;
        }

        va_end(ap);

        if (_config.display)
  40d4ff:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  40d503:	0f 85 57 02 00 00    	jne    40d760 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x640>
        {
            fprintf(stderr, "%s\n", _log_buf);
        }

        if (_file)
  40d509:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  40d50d:	48 85 ff             	test   %rdi,%rdi
  40d510:	74 2c                	je     40d53e <_ZN10LoggerImpl5doLogEiPKciS1_z+0x41e>
# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
			__va_arg_pack ());
  40d512:	48 8d 15 5a 32 00 00 	lea    0x325a(%rip),%rdx        # 410773 <_ZTSN6rocket12EpollWrapperE+0x193>
  40d519:	4c 89 e9             	mov    %r13,%rcx
  40d51c:	be 01 00 00 00       	mov    $0x1,%esi
  40d521:	31 c0                	xor    %eax,%eax
  40d523:	e8 38 66 ff ff       	callq  403b60 <__fprintf_chk@plt>
        {
            fprintf(_file, "%s\n", _log_buf);
            fflush(_file);
  40d528:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  40d52c:	e8 7f 6d ff ff       	callq  4042b0 <fflush@plt>
            _size += len + 1;
  40d531:	83 c5 01             	add    $0x1,%ebp
  40d534:	48 63 ed             	movslq %ebp,%rbp
  40d537:	48 01 ab b0 00 00 00 	add    %rbp,0xb0(%rbx)
        }
    }

    ~Guard()
    {
        if (_mutex)
  40d53e:	4d 85 e4             	test   %r12,%r12
  40d541:	0f 84 af fc ff ff    	je     40d1f6 <_ZN10LoggerImpl5doLogEiPKciS1_z+0xd6>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40d547:	4c 89 e7             	mov    %r12,%rdi
  40d54a:	e8 81 6c ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        perror("pthread_mutex_unlock");
  40d54f:	48 8d 3d 55 33 00 00 	lea    0x3355(%rip),%rdi        # 4108ab <_ZTSN6rocket12EpollWrapperE+0x2cb>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&_mutex);
  40d556:	89 c3                	mov    %eax,%ebx
        perror("pthread_mutex_unlock");
  40d558:	e8 d3 6b ff ff       	callq  404130 <perror@plt>
}

__extern_always_inline int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40d55d:	48 8d 35 5c 33 00 00 	lea    0x335c(%rip),%rsi        # 4108c0 <_ZTSN6rocket12EpollWrapperE+0x2e0>
  40d564:	31 c0                	xor    %eax,%eax
  40d566:	4c 89 e1             	mov    %r12,%rcx
  40d569:	89 da                	mov    %ebx,%edx
  40d56b:	bf 01 00 00 00       	mov    $0x1,%edi
  40d570:	e8 8b 66 ff ff       	callq  403c00 <__printf_chk@plt>
        printf("~unlock ret=%d, %p\n", ret, this);
        assert(ret == 0);
  40d575:	85 db                	test   %ebx,%ebx
  40d577:	0f 84 79 fc ff ff    	je     40d1f6 <_ZN10LoggerImpl5doLogEiPKciS1_z+0xd6>
  40d57d:	e8 e6 6d ff ff       	callq  404368 <_ZN5Mutex6unlockEv.part.4>
  40d582:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        {
            closeLogFile();
            return;
        }

        if (!_file) {
  40d588:	48 85 ff             	test   %rdi,%rdi
  40d58b:	0f 84 3f fe ff ff    	je     40d3d0 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b0>
            return;
        }

        bool rotate = false;
        if (_size >= _config.size)
  40d591:	48 8b 43 30          	mov    0x30(%rbx),%rax
  40d595:	48 39 83 b0 00 00 00 	cmp    %rax,0xb0(%rbx)
  40d59c:	0f 82 9e 01 00 00    	jb     40d740 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x620>
        {
        }

        if (rotate)
        {
            if (_config.count > 0 && _file_queue.size() >= _config.count)
  40d5a2:	8b 53 28             	mov    0x28(%rbx),%edx
  40d5a5:	85 d2                	test   %edx,%edx
  40d5a7:	74 51                	je     40d5fa <_ZN10LoggerImpl5doLogEiPKciS1_z+0x4da>
	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
	+ (__y._M_last - __y._M_cur);
  40d5a9:	48 8b 83 30 09 00 00 	mov    0x930(%rbx),%rax
  40d5b0:	48 2b 83 10 09 00 00 	sub    0x910(%rbx),%rax
  40d5b7:	4c 8b 83 18 09 00 00 	mov    0x918(%rbx),%r8
  40d5be:	4c 2b 83 20 09 00 00 	sub    0x920(%rbx),%r8
  40d5c5:	48 8b 8b f8 08 00 00 	mov    0x8f8(%rbx),%rcx
  40d5cc:	48 c1 f8 03          	sar    $0x3,%rax
  40d5d0:	48 83 e8 01          	sub    $0x1,%rax
  40d5d4:	49 c1 f8 03          	sar    $0x3,%r8
  40d5d8:	48 c1 e0 06          	shl    $0x6,%rax
  40d5dc:	49 01 c0             	add    %rax,%r8
  40d5df:	48 8b 83 08 09 00 00 	mov    0x908(%rbx),%rax
  40d5e6:	48 29 c8             	sub    %rcx,%rax
  40d5e9:	48 c1 f8 03          	sar    $0x3,%rax
  40d5ed:	49 8d 04 00          	lea    (%r8,%rax,1),%rax
  40d5f1:	48 39 d0             	cmp    %rdx,%rax
  40d5f4:	0f 83 16 02 00 00    	jae    40d810 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x6f0>

    void closeLogFile()
    {
        if (_file)
        {
            fclose(_file);
  40d5fa:	e8 11 6a ff ff       	callq  404010 <fclose@plt>
            _file = NULL;
  40d5ff:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  40d606:	00 
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40d607:	48 8b 43 18          	mov    0x18(%rbx),%rax
  40d60b:	44 8b 43 44          	mov    0x44(%rbx),%r8d
  40d60f:	8b 7b 48             	mov    0x48(%rbx),%edi
  40d612:	8b 73 4c             	mov    0x4c(%rbx),%esi
  40d615:	8b 4b 50             	mov    0x50(%rbx),%ecx
  40d618:	8b 53 54             	mov    0x54(%rbx),%edx
        }
    }

    std::string getLogFileName(struct tm xtm)
    {
        if (_config.file.empty()) return "";
  40d61b:	48 83 78 e8 00       	cmpq   $0x0,-0x18(%rax)
  40d620:	0f 84 a2 fc ff ff    	je     40d2c8 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x1a8>
#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
				  __bos (__s), __fmt, __va_arg_pack ());
  40d626:	48 8d 84 24 80 00 00 	lea    0x80(%rsp),%rax
  40d62d:	00 
  40d62e:	48 83 ec 08          	sub    $0x8,%rsp
  40d632:	44 8d 49 01          	lea    0x1(%rcx),%r9d
  40d636:	41 50                	push   %r8
  40d638:	57                   	push   %rdi
  40d639:	44 8d 82 6c 07 00 00 	lea    0x76c(%rdx),%r8d
  40d640:	56                   	push   %rsi
  40d641:	48 8d 0d e8 32 00 00 	lea    0x32e8(%rip),%rcx        # 410930 <_ZTSN6rocket12EpollWrapperE+0x350>
  40d648:	48 89 c7             	mov    %rax,%rdi
  40d64b:	be 01 00 00 00       	mov    $0x1,%esi
  40d650:	ba 64 00 00 00       	mov    $0x64,%edx
  40d655:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40d65a:	31 c0                	xor    %eax,%eax
  40d65c:	e8 4f 6a ff ff       	callq  4040b0 <__sprintf_chk@plt>
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  40d661:	48 83 c4 20          	add    $0x20,%rsp
                xtm.tm_mon + 1,
                xtm.tm_mday,
                xtm.tm_hour,
                xtm.tm_min);

        return _config.file + "." + timestamp;
  40d665:	48 8d 73 18          	lea    0x18(%rbx),%rsi
  40d669:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
  40d66e:	48 89 cf             	mov    %rcx,%rdi
  40d671:	48 89 0c 24          	mov    %rcx,(%rsp)
  40d675:	e8 46 66 ff ff       	callq  403cc0 <_ZNSsC1ERKSs@plt>
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
  40d67a:	48 8b 3c 24          	mov    (%rsp),%rdi
  40d67e:	48 8d 35 2f 2d 00 00 	lea    0x2d2f(%rip),%rsi        # 4103b4 <_IO_stdin_used+0x34>
  40d685:	ba 01 00 00 00       	mov    $0x1,%edx
  40d68a:	e8 c1 63 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
  40d68f:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40d694:	8b 0a                	mov    (%rdx),%ecx
  40d696:	48 83 c2 04          	add    $0x4,%rdx
  40d69a:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40d6a0:	f7 d1                	not    %ecx
  40d6a2:	21 c8                	and    %ecx,%eax
  40d6a4:	25 80 80 80 80       	and    $0x80808080,%eax
  40d6a9:	74 e9                	je     40d694 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x574>
  40d6ab:	89 c1                	mov    %eax,%ecx
  40d6ad:	48 8b 3c 24          	mov    (%rsp),%rdi
  40d6b1:	c1 e9 10             	shr    $0x10,%ecx
  40d6b4:	a9 80 80 00 00       	test   $0x8080,%eax
  40d6b9:	0f 44 c1             	cmove  %ecx,%eax
  40d6bc:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40d6c0:	48 0f 44 d1          	cmove  %rcx,%rdx
  40d6c4:	00 c0                	add    %al,%al
  40d6c6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40d6cb:	48 83 da 03          	sbb    $0x3,%rdx
  40d6cf:	48 29 c2             	sub    %rax,%rdx
  40d6d2:	48 89 c6             	mov    %rax,%rsi
  40d6d5:	e8 76 63 ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40d6da:	48 8b 10             	mov    (%rax),%rdx
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  40d6dd:	48 8b 0d 7c 68 20 00 	mov    0x20687c(%rip),%rcx        # 613f60 <_DYNAMIC+0x2d8>
	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
  40d6e4:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }
  40d6e9:	48 8d 51 18          	lea    0x18(%rcx),%rdx
  40d6ed:	48 89 0c 24          	mov    %rcx,(%rsp)
  40d6f1:	48 89 10             	mov    %rdx,(%rax)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40d6f4:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40d6f9:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40d6fd:	48 39 cf             	cmp    %rcx,%rdi
  40d700:	0f 84 e3 fb ff ff    	je     40d2e9 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x1c9>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40d706:	48 83 3d 6a 68 20 00 	cmpq   $0x0,0x20686a(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40d70d:	00 
  40d70e:	0f 84 ea 01 00 00    	je     40d8fe <_ZN10LoggerImpl5doLogEiPKciS1_z+0x7de>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40d714:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40d719:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40d71e:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40d720:	85 c0                	test   %eax,%eax
  40d722:	0f 8f c1 fb ff ff    	jg     40d2e9 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x1c9>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40d728:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
  40d72d:	e8 3e 66 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40d732:	e9 b2 fb ff ff       	jmpq   40d2e9 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x1c9>
  40d737:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40d73e:	00 00 
        bool rotate = false;
        if (_size >= _config.size)
        {
            rotate = true;
        }
        else if (_config.rotate == ROTATE_DAILY &&
  40d740:	8b 43 24             	mov    0x24(%rbx),%eax
  40d743:	85 c0                	test   %eax,%eax
  40d745:	75 41                	jne    40d788 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x668>
                 _tm_now.tm_mday != _tm_rotate.tm_mday)
  40d747:	8b 4b 4c             	mov    0x4c(%rbx),%ecx
        else if (_config.rotate == ROTATE_MONTHLY &&
                 _tm_now.tm_mon != _tm_rotate.tm_mon)
        {
        }

        if (rotate)
  40d74a:	39 8b 84 00 00 00    	cmp    %ecx,0x84(%rbx)
  40d750:	0f 84 80 fc ff ff    	je     40d3d6 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b6>
  40d756:	e9 47 fe ff ff       	jmpq   40d5a2 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x482>
  40d75b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
			__va_arg_pack ());
  40d760:	48 8b 05 09 68 20 00 	mov    0x206809(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40d767:	48 8d 15 05 30 00 00 	lea    0x3005(%rip),%rdx        # 410773 <_ZTSN6rocket12EpollWrapperE+0x193>
  40d76e:	4c 89 e9             	mov    %r13,%rcx
  40d771:	be 01 00 00 00       	mov    $0x1,%esi
  40d776:	48 8b 38             	mov    (%rax),%rdi
  40d779:	31 c0                	xor    %eax,%eax
  40d77b:	e8 e0 63 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40d780:	e9 84 fd ff ff       	jmpq   40d509 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x3e9>
  40d785:	0f 1f 00             	nopl   (%rax)
        else if (_config.rotate == ROTATE_DAILY &&
                 _tm_now.tm_mday != _tm_rotate.tm_mday)
        {
            rotate = true;
        }
        else if (_config.rotate == ROTATE_WEEKLY &&
  40d788:	83 f8 01             	cmp    $0x1,%eax
  40d78b:	0f 85 3f fc ff ff    	jne    40d3d0 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b0>
                 _tm_now.tm_mday != _tm_rotate.tm_mday &&
  40d791:	8b 8b 84 00 00 00    	mov    0x84(%rbx),%ecx
        else if (_config.rotate == ROTATE_DAILY &&
                 _tm_now.tm_mday != _tm_rotate.tm_mday)
        {
            rotate = true;
        }
        else if (_config.rotate == ROTATE_WEEKLY &&
  40d797:	3b 4b 4c             	cmp    0x4c(%rbx),%ecx
  40d79a:	0f 84 36 fc ff ff    	je     40d3d6 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b6>
                 _tm_now.tm_mday != _tm_rotate.tm_mday &&
  40d7a0:	8b 43 58             	mov    0x58(%rbx),%eax
  40d7a3:	39 83 90 00 00 00    	cmp    %eax,0x90(%rbx)
  40d7a9:	0f 85 27 fc ff ff    	jne    40d3d6 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2b6>
  40d7af:	e9 ee fd ff ff       	jmpq   40d5a2 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x482>
  40d7b4:	0f 1f 40 00          	nopl   0x0(%rax)
        if (_config.file.empty())
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40d7b8:	48 8d 35 3e 31 00 00 	lea    0x313e(%rip),%rsi        # 4108fd <_ZTSN6rocket12EpollWrapperE+0x31d>
  40d7bf:	e8 9c 64 ff ff       	callq  403c60 <fopen@plt>
        if (_file == NULL)
  40d7c4:	48 85 c0             	test   %rax,%rax
        if (_config.file.empty())
        {
            return;
        }

        _file = fopen(_config.file.c_str(), "ab");
  40d7c7:	48 89 43 10          	mov    %rax,0x10(%rbx)
        if (_file == NULL)
  40d7cb:	0f 85 35 fb ff ff    	jne    40d306 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x1e6>
        {
            fprintf(stderr, "failed to open %s: %s\n",
                    _config.file.c_str(), strerror(errno));
  40d7d1:	e8 3a 67 ff ff       	callq  403f10 <__errno_location@plt>
  40d7d6:	8b 38                	mov    (%rax),%edi
  40d7d8:	e8 63 66 ff ff       	callq  403e40 <strerror@plt>
  40d7dd:	49 89 c0             	mov    %rax,%r8
  40d7e0:	48 8b 05 89 67 20 00 	mov    0x206789(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40d7e7:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
  40d7eb:	48 8d 15 0e 31 00 00 	lea    0x310e(%rip),%rdx        # 410900 <_ZTSN6rocket12EpollWrapperE+0x320>
  40d7f2:	be 01 00 00 00       	mov    $0x1,%esi
  40d7f7:	48 8b 38             	mov    (%rax),%rdi
  40d7fa:	31 c0                	xor    %eax,%eax
  40d7fc:	e8 5f 63 ff ff       	callq  403b60 <__fprintf_chk@plt>
  40d801:	e9 00 fb ff ff       	jmpq   40d306 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x1e6>
  40d806:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40d80d:	00 00 00 

        if (rotate)
        {
            if (_config.count > 0 && _file_queue.size() >= _config.count)
            {
                remove(_file_queue.front().c_str());
  40d810:	48 8b 39             	mov    (%rcx),%rdi
  40d813:	e8 18 68 ff ff       	callq  404030 <remove@plt>
       */
      void
      pop_front() _GLIBCXX_NOEXCEPT
      {
	if (this->_M_impl._M_start._M_cur
	    != this->_M_impl._M_start._M_last - 1)
  40d818:	48 8b 8b 08 09 00 00 	mov    0x908(%rbx),%rcx
       *  needed, it should be retrieved before pop_front() is called.
       */
      void
      pop_front() _GLIBCXX_NOEXCEPT
      {
	if (this->_M_impl._M_start._M_cur
  40d81f:	48 8b 83 f8 08 00 00 	mov    0x8f8(%rbx),%rax
	    != this->_M_impl._M_start._M_last - 1)
  40d826:	48 8d 51 f8          	lea    -0x8(%rcx),%rdx
       *  needed, it should be retrieved before pop_front() is called.
       */
      void
      pop_front() _GLIBCXX_NOEXCEPT
      {
	if (this->_M_impl._M_start._M_cur
  40d82a:	48 39 d0             	cmp    %rdx,%rax
  40d82d:	74 78                	je     40d8a7 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x787>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40d82f:	48 8b 10             	mov    (%rax),%rdx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40d832:	48 8d 7a e8          	lea    -0x18(%rdx),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40d836:	48 3b 3d 23 67 20 00 	cmp    0x206723(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40d83d:	75 47                	jne    40d886 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x766>
  40d83f:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	    != this->_M_impl._M_start._M_last - 1)
	  {
	    this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
	    ++this->_M_impl._M_start._M_cur;
  40d843:	48 83 c0 08          	add    $0x8,%rax
  40d847:	48 89 83 f8 08 00 00 	mov    %rax,0x8f8(%rbx)
        }
    }

    void closeLogFile()
    {
        if (_file)
  40d84e:	48 85 ff             	test   %rdi,%rdi
  40d851:	0f 84 b0 fd ff ff    	je     40d607 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x4e7>
  40d857:	e9 9e fd ff ff       	jmpq   40d5fa <_ZN10LoggerImpl5doLogEiPKciS1_z+0x4da>
  40d85c:	0f 1f 40 00          	nopl   0x0(%rax)
	  {
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
	    ++this->_M_impl._M_finish._M_cur;
	  }
	else
	  _M_push_back_aux(__x);
  40d860:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
       *  to it.  The time complexity of the operation depends on the
       *  underlying sequence.
       */
      void
      push(const value_type& __x)
      { c.push_back(__x); }
  40d865:	48 8d bb e8 08 00 00 	lea    0x8e8(%rbx),%rdi
  40d86c:	e8 9f f6 ff ff       	callq  40cf10 <_ZNSt5dequeISsSaISsEE16_M_push_back_auxIIRKSsEEEvDpOT_>
  40d871:	e9 cc fa ff ff       	jmpq   40d342 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x222>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40d876:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40d879:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40d87c:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40d87f:	89 d0                	mov    %edx,%eax
  40d881:	e9 3a fb ff ff       	jmpq   40d3c0 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x2a0>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40d886:	48 83 3d ea 66 20 00 	cmpq   $0x0,0x2066ea(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40d88d:	00 
  40d88e:	74 7e                	je     40d90e <_ZN10LoggerImpl5doLogEiPKciS1_z+0x7ee>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40d890:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40d895:	f0 0f c1 42 f8       	lock xadd %eax,-0x8(%rdx)
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40d89a:	85 c0                	test   %eax,%eax
  40d89c:	7e 7b                	jle    40d919 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x7f9>
  40d89e:	48 8b 83 f8 08 00 00 	mov    0x8f8(%rbx),%rax
  40d8a5:	eb 98                	jmp    40d83f <_ZN10LoggerImpl5doLogEiPKciS1_z+0x71f>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40d8a7:	48 8b 00             	mov    (%rax),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40d8aa:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40d8ae:	48 3b 3d ab 66 20 00 	cmp    0x2066ab(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40d8b5:	75 7b                	jne    40d932 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x812>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40d8b7:	48 8b bb 00 09 00 00 	mov    0x900(%rbx),%rdi
  40d8be:	e8 ed 62 ff ff       	callq  403bb0 <_ZdlPv@plt>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
  40d8c3:	48 8b 83 10 09 00 00 	mov    0x910(%rbx),%rax
  40d8ca:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  40d8ce:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40d8d2:	48 89 93 10 09 00 00 	mov    %rdx,0x910(%rbx)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40d8d9:	48 8b 40 08          	mov    0x8(%rax),%rax
	_M_last = _M_first + difference_type(_S_buffer_size());
  40d8dd:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40d8e4:	48 89 83 00 09 00 00 	mov    %rax,0x900(%rbx)
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
  40d8eb:	48 89 83 f8 08 00 00 	mov    %rax,0x8f8(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40d8f2:	48 89 93 08 09 00 00 	mov    %rdx,0x908(%rbx)
  40d8f9:	e9 50 ff ff ff       	jmpq   40d84e <_ZN10LoggerImpl5doLogEiPKciS1_z+0x72e>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40d8fe:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40d901:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40d904:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40d907:	89 d0                	mov    %edx,%eax
  40d909:	e9 12 fe ff ff       	jmpq   40d720 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x600>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40d90e:	8b 42 f8             	mov    -0x8(%rdx),%eax
    *__mem += __val;
  40d911:	8d 48 ff             	lea    -0x1(%rax),%ecx
  40d914:	89 4a f8             	mov    %ecx,-0x8(%rdx)
  40d917:	eb 81                	jmp    40d89a <_ZN10LoggerImpl5doLogEiPKciS1_z+0x77a>
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40d919:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
  40d91e:	e8 4d 64 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40d923:	e9 76 ff ff ff       	jmpq   40d89e <_ZN10LoggerImpl5doLogEiPKciS1_z+0x77e>
        {
            fprintf(_file, "%s\n", _log_buf);
            fflush(_file);
            _size += len + 1;
        }
    }
  40d928:	e8 23 66 ff ff       	callq  403f50 <__stack_chk_fail@plt>
  40d92d:	e8 16 6a ff ff       	callq  404348 <_ZN5Mutex4lockEv.part.3>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40d932:	48 83 3d 3e 66 20 00 	cmpq   $0x0,0x20663e(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40d939:	00 
  40d93a:	74 21                	je     40d95d <_ZN10LoggerImpl5doLogEiPKciS1_z+0x83d>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40d93c:	83 ca ff             	or     $0xffffffff,%edx
  40d93f:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40d944:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40d946:	85 c0                	test   %eax,%eax
  40d948:	0f 8f 69 ff ff ff    	jg     40d8b7 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x797>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40d94e:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
  40d953:	e8 18 64 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40d958:	e9 5a ff ff ff       	jmpq   40d8b7 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x797>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40d95d:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40d960:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40d963:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40d966:	89 d0                	mov    %edx,%eax
  40d968:	eb dc                	jmp    40d946 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x826>
  40d96a:	48 89 c3             	mov    %rax,%rbx
  40d96d:	eb 05                	jmp    40d974 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x854>
  40d96f:	48 89 c3             	mov    %rax,%rbx
  40d972:	eb 24                	jmp    40d998 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x878>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40d974:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40d979:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40d97d:	48 3b 3c 24          	cmp    (%rsp),%rdi
  40d981:	75 27                	jne    40d9aa <_ZN10LoggerImpl5doLogEiPKciS1_z+0x88a>
        }
    }

    ~Guard()
    {
        if (_mutex)
  40d983:	4d 85 e4             	test   %r12,%r12
  40d986:	74 08                	je     40d990 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x870>
        {
            _mutex->unlock();
  40d988:	4c 89 e7             	mov    %r12,%rdi
  40d98b:	e8 60 ec ff ff       	callq  40c5f0 <_ZN5Mutex6unlockEv>
  40d990:	48 89 df             	mov    %rbx,%rdi
  40d993:	e8 08 68 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40d998:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40d99d:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40d9a1:	48 3b 3d b8 65 20 00 	cmp    0x2065b8(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40d9a8:	74 d9                	je     40d983 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x863>
  40d9aa:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
  40d9af:	e8 6c 69 ff ff       	callq  404320 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.0>
  40d9b4:	eb cd                	jmp    40d983 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x863>
  40d9b6:	eb b7                	jmp    40d96f <_ZN10LoggerImpl5doLogEiPKciS1_z+0x84f>
  40d9b8:	48 89 c3             	mov    %rax,%rbx
  40d9bb:	eb c6                	jmp    40d983 <_ZN10LoggerImpl5doLogEiPKciS1_z+0x863>
  40d9bd:	90                   	nop
  40d9be:	90                   	nop
  40d9bf:	90                   	nop

000000000040d9c0 <_Z10usage_exitPKci>:

static const char *CONFIG_DEFAULT_PID_FILE = "rocket.pid";

void usage_exit(const char *program, int status)
{
    FILE *stream = status != 0 ? stderr : stdout;
  40d9c0:	85 f6                	test   %esi,%esi
static bool do_daemonize = false;

static const char *CONFIG_DEFAULT_PID_FILE = "rocket.pid";

void usage_exit(const char *program, int status)
{
  40d9c2:	53                   	push   %rbx
  40d9c3:	48 89 f9             	mov    %rdi,%rcx
  40d9c6:	89 f3                	mov    %esi,%ebx
    FILE *stream = status != 0 ? stderr : stdout;
  40d9c8:	74 26                	je     40d9f0 <_Z10usage_exitPKci+0x30>
  40d9ca:	48 8b 05 9f 65 20 00 	mov    0x20659f(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40d9d1:	48 8b 38             	mov    (%rax),%rdi
  40d9d4:	48 8d 15 65 32 00 00 	lea    0x3265(%rip),%rdx        # 410c40 <_ZTS10LoggerImpl+0x195>
  40d9db:	be 01 00 00 00       	mov    $0x1,%esi
  40d9e0:	31 c0                	xor    %eax,%eax
  40d9e2:	e8 79 61 ff ff       	callq  403b60 <__fprintf_chk@plt>
            "  -h, --help                   show help message\n"
            "  -d, --daemon                 run as a daemon\n"
            "  -v, --version                show version\n",
            program);

    exit(status);
  40d9e7:	89 df                	mov    %ebx,%edi
  40d9e9:	e8 e2 61 ff ff       	callq  403bd0 <exit@plt>
  40d9ee:	66 90                	xchg   %ax,%ax

static const char *CONFIG_DEFAULT_PID_FILE = "rocket.pid";

void usage_exit(const char *program, int status)
{
    FILE *stream = status != 0 ? stderr : stdout;
  40d9f0:	48 8b 05 91 65 20 00 	mov    0x206591(%rip),%rax        # 613f88 <_DYNAMIC+0x300>
  40d9f7:	48 8b 38             	mov    (%rax),%rdi
  40d9fa:	eb d8                	jmp    40d9d4 <_Z10usage_exitPKci+0x14>
  40d9fc:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040da00 <_Z12version_exiti>:
    exit(status);
}

void version_exit(int status)
{
    FILE *stream = status != 0 ? stderr : stdout;
  40da00:	85 ff                	test   %edi,%edi

    exit(status);
}

void version_exit(int status)
{
  40da02:	53                   	push   %rbx
  40da03:	89 fb                	mov    %edi,%ebx
    FILE *stream = status != 0 ? stderr : stdout;
  40da05:	74 29                	je     40da30 <_Z12version_exiti+0x30>
  40da07:	48 8b 05 62 65 20 00 	mov    0x206562(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40da0e:	48 8b 38             	mov    (%rax),%rdi
  40da11:	48 8d 15 a8 30 00 00 	lea    0x30a8(%rip),%rdx        # 410ac0 <_ZTS10LoggerImpl+0x15>
  40da18:	be 01 00 00 00       	mov    $0x1,%esi
  40da1d:	31 c0                	xor    %eax,%eax
  40da1f:	e8 3c 61 ff ff       	callq  403b60 <__fprintf_chk@plt>

    fprintf(stream, "Built: " __DATE__ " " __TIME__ "\n");

    exit(status);
  40da24:	89 df                	mov    %ebx,%edi
  40da26:	e8 a5 61 ff ff       	callq  403bd0 <exit@plt>
  40da2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    exit(status);
}

void version_exit(int status)
{
    FILE *stream = status != 0 ? stderr : stdout;
  40da30:	48 8b 05 51 65 20 00 	mov    0x206551(%rip),%rax        # 613f88 <_DYNAMIC+0x300>
  40da37:	48 8b 38             	mov    (%rax),%rdi
  40da3a:	eb d5                	jmp    40da11 <_Z12version_exiti+0x11>
  40da3c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040da40 <_Z13parse_optionsiPPc>:

    exit(status);
}

int parse_options(int argc, char **argv)
{
  40da40:	41 54                	push   %r12
  40da42:	55                   	push   %rbp
  40da43:	41 89 fc             	mov    %edi,%r12d
  40da46:	53                   	push   %rbx
  40da47:	48 89 f5             	mov    %rsi,%rbp
        {"daemon", no_argument, NULL, 'd'},
        {"version", no_argument, NULL, 'v'},
        {0, 0, 0, 0}
    };

    while ((c = getopt_long(argc, argv, "c:hdv", long_options, NULL)) != -1)
  40da4a:	48 8d 0d 2f 6a 20 00 	lea    0x206a2f(%rip),%rcx        # 614480 <_ZZ13parse_optionsiPPcE12long_options>
  40da51:	48 8d 15 9e 30 00 00 	lea    0x309e(%rip),%rdx        # 410af6 <_ZTS10LoggerImpl+0x4b>
  40da58:	45 31 c0             	xor    %r8d,%r8d
  40da5b:	48 89 ee             	mov    %rbp,%rsi
  40da5e:	44 89 e7             	mov    %r12d,%edi
  40da61:	e8 6a 64 ff ff       	callq  403ed0 <getopt_long@plt>
  40da66:	83 f8 ff             	cmp    $0xffffffff,%eax
  40da69:	89 c3                	mov    %eax,%ebx
  40da6b:	0f 84 8f 00 00 00    	je     40db00 <_Z13parse_optionsiPPc+0xc0>
    {
        switch (c)
  40da71:	83 fb 64             	cmp    $0x64,%ebx
  40da74:	74 3a                	je     40dab0 <_Z13parse_optionsiPPc+0x70>
  40da76:	7e 18                	jle    40da90 <_Z13parse_optionsiPPc+0x50>
  40da78:	83 fb 68             	cmp    $0x68,%ebx
  40da7b:	74 73                	je     40daf0 <_Z13parse_optionsiPPc+0xb0>
  40da7d:	83 fb 76             	cmp    $0x76,%ebx
  40da80:	75 3e                	jne    40dac0 <_Z13parse_optionsiPPc+0x80>
                break;
            case 'd':   /* daemonize */
                do_daemonize = true;
                break;
            case 'v':   /* version */
                version_exit(0);
  40da82:	31 ff                	xor    %edi,%edi
  40da84:	e8 77 ff ff ff       	callq  40da00 <_Z12version_exiti>
                break;
  40da89:	eb bf                	jmp    40da4a <_Z13parse_optionsiPPc+0xa>
  40da8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        {0, 0, 0, 0}
    };

    while ((c = getopt_long(argc, argv, "c:hdv", long_options, NULL)) != -1)
    {
        switch (c)
  40da90:	83 fb 63             	cmp    $0x63,%ebx
  40da93:	75 2b                	jne    40dac0 <_Z13parse_optionsiPPc+0x80>
        {
            case 'c':   /* config */
                opt_config = optarg;
  40da95:	48 8b 05 a4 64 20 00 	mov    0x2064a4(%rip),%rax        # 613f40 <_DYNAMIC+0x2b8>
  40da9c:	48 8b 00             	mov    (%rax),%rax
  40da9f:	48 89 05 62 74 20 00 	mov    %rax,0x207462(%rip)        # 614f08 <_ZL10opt_config>
                break;
  40daa6:	eb a2                	jmp    40da4a <_Z13parse_optionsiPPc+0xa>
  40daa8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40daaf:	00 
            case 'h':   /* help */
                usage_exit(argv[0], 0);
                break;
            case 'd':   /* daemonize */
                do_daemonize = true;
  40dab0:	c6 05 49 74 20 00 01 	movb   $0x1,0x207449(%rip)        # 614f00 <_ZL12do_daemonize>
                break;
  40dab7:	eb 91                	jmp    40da4a <_Z13parse_optionsiPPc+0xa>
  40dab9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40dac0:	48 8d 15 16 30 00 00 	lea    0x3016(%rip),%rdx        # 410add <_ZTS10LoggerImpl+0x32>
  40dac7:	48 8b 05 a2 64 20 00 	mov    0x2064a2(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40dace:	be 01 00 00 00       	mov    $0x1,%esi
  40dad3:	48 8b 38             	mov    (%rax),%rdi
  40dad6:	31 c0                	xor    %eax,%eax
  40dad8:	e8 83 60 ff ff       	callq  403b60 <__fprintf_chk@plt>
            case 'v':   /* version */
                version_exit(0);
                break;
            default:
                fprintf(stderr, "no command line options\n");
                return -1;
  40dadd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        fprintf(stderr, "no config file is specified\n");
        return -1;
    }

    return 0;
}
  40dae2:	5b                   	pop    %rbx
  40dae3:	5d                   	pop    %rbp
  40dae4:	41 5c                	pop    %r12
  40dae6:	c3                   	retq   
  40dae7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40daee:	00 00 
        {
            case 'c':   /* config */
                opt_config = optarg;
                break;
            case 'h':   /* help */
                usage_exit(argv[0], 0);
  40daf0:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
  40daf4:	31 f6                	xor    %esi,%esi
  40daf6:	e8 c5 fe ff ff       	callq  40d9c0 <_Z10usage_exitPKci>
                break;
  40dafb:	e9 4a ff ff ff       	jmpq   40da4a <_Z13parse_optionsiPPc+0xa>
                fprintf(stderr, "no command line options\n");
                return -1;
        }
    }

    if (optind < argc)
  40db00:	48 8b 05 f9 63 20 00 	mov    0x2063f9(%rip),%rax        # 613f00 <_DYNAMIC+0x278>
  40db07:	48 63 00             	movslq (%rax),%rax
  40db0a:	41 39 c4             	cmp    %eax,%r12d
  40db0d:	7f 11                	jg     40db20 <_Z13parse_optionsiPPc+0xe0>
    {
        fprintf(stderr, "unexpected argument %s\n", argv[optind]);
        return -1;
    }

    if (opt_config == NULL)
  40db0f:	48 83 3d f1 73 20 00 	cmpq   $0x0,0x2073f1(%rip)        # 614f08 <_ZL10opt_config>
  40db16:	00 
  40db17:	74 2d                	je     40db46 <_Z13parse_optionsiPPc+0x106>
        fprintf(stderr, "no config file is specified\n");
        return -1;
    }

    return 0;
}
  40db19:	5b                   	pop    %rbx
    {
        fprintf(stderr, "no config file is specified\n");
        return -1;
    }

    return 0;
  40db1a:	31 c0                	xor    %eax,%eax
}
  40db1c:	5d                   	pop    %rbp
  40db1d:	41 5c                	pop    %r12
  40db1f:	c3                   	retq   
  40db20:	48 8b 4c c5 00       	mov    0x0(%rbp,%rax,8),%rcx
  40db25:	48 8b 05 44 64 20 00 	mov    0x206444(%rip),%rax        # 613f70 <_DYNAMIC+0x2e8>
  40db2c:	48 8d 15 c9 2f 00 00 	lea    0x2fc9(%rip),%rdx        # 410afc <_ZTS10LoggerImpl+0x51>
  40db33:	be 01 00 00 00       	mov    $0x1,%esi
  40db38:	48 8b 38             	mov    (%rax),%rdi
  40db3b:	31 c0                	xor    %eax,%eax
  40db3d:	e8 1e 60 ff ff       	callq  403b60 <__fprintf_chk@plt>
    }

    if (optind < argc)
    {
        fprintf(stderr, "unexpected argument %s\n", argv[optind]);
        return -1;
  40db42:	89 d8                	mov    %ebx,%eax
  40db44:	eb 9c                	jmp    40dae2 <_Z13parse_optionsiPPc+0xa2>
  40db46:	48 8d 15 c7 2f 00 00 	lea    0x2fc7(%rip),%rdx        # 410b14 <_ZTS10LoggerImpl+0x69>
  40db4d:	e9 75 ff ff ff       	jmpq   40dac7 <_Z13parse_optionsiPPc+0x87>
  40db52:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40db59:	1f 84 00 00 00 00 00 

000000000040db60 <_Z9daemonizev>:
    }

    return 0;
}

int daemonize() {
  40db60:	55                   	push   %rbp
  40db61:	53                   	push   %rbx
  40db62:	48 83 ec 08          	sub    $0x8,%rsp
    int fd;

    switch (fork()) {
  40db66:	e8 65 65 ff ff       	callq  4040d0 <fork@plt>
  40db6b:	83 f8 ff             	cmp    $0xffffffff,%eax
  40db6e:	89 c3                	mov    %eax,%ebx
  40db70:	74 6e                	je     40dbe0 <_Z9daemonizev+0x80>
  40db72:	85 c0                	test   %eax,%eax
  40db74:	75 7a                	jne    40dbf0 <_Z9daemonizev+0x90>
    }

    /* creates a new session if the calling process is not a process group leader.
       https://linux.die.net/man/2/setsid
    */
    if (setsid() == -1)
  40db76:	e8 55 5f ff ff       	callq  403ad0 <setsid@plt>
  40db7b:	83 f8 ff             	cmp    $0xffffffff,%eax
  40db7e:	0f 84 8c 00 00 00    	je     40dc10 <_Z9daemonizev+0xb0>
      if ((__oflag & O_CREAT) != 0 && __va_arg_pack_len () < 1)
	{
	  __open_missing_mode ();
	  return __open_2 (__path, __oflag);
	}
      return __open_alias (__path, __oflag, __va_arg_pack ());
  40db84:	48 8d 3d a6 2f 00 00 	lea    0x2fa6(%rip),%rdi        # 410b31 <_ZTS10LoggerImpl+0x86>
  40db8b:	31 d2                	xor    %edx,%edx
  40db8d:	31 c0                	xor    %eax,%eax
  40db8f:	be 02 00 00 00       	mov    $0x2,%esi
  40db94:	e8 b7 66 ff ff       	callq  404250 <open@plt>
        return -1;

    //将stdin、stdout、stderr重定向到/dev/null(或称空设备，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。)
    if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
  40db99:	83 f8 ff             	cmp    $0xffffffff,%eax
  40db9c:	89 c5                	mov    %eax,%ebp
  40db9e:	74 40                	je     40dbe0 <_Z9daemonizev+0x80>
        if(dup2(fd, STDIN_FILENO) < 0) {
  40dba0:	31 f6                	xor    %esi,%esi
  40dba2:	89 c7                	mov    %eax,%edi
  40dba4:	e8 d7 5e ff ff       	callq  403a80 <dup2@plt>
  40dba9:	85 c0                	test   %eax,%eax
  40dbab:	78 67                	js     40dc14 <_Z9daemonizev+0xb4>
            perror("dup2 stdin");
            return -1;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
  40dbad:	be 01 00 00 00       	mov    $0x1,%esi
  40dbb2:	89 ef                	mov    %ebp,%edi
  40dbb4:	e8 c7 5e ff ff       	callq  403a80 <dup2@plt>
  40dbb9:	85 c0                	test   %eax,%eax
  40dbbb:	78 6a                	js     40dc27 <_Z9daemonizev+0xc7>
            perror("dup2 stdout");
            return -1;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
  40dbbd:	be 02 00 00 00       	mov    $0x2,%esi
  40dbc2:	89 ef                	mov    %ebp,%edi
  40dbc4:	e8 b7 5e ff ff       	callq  403a80 <dup2@plt>
  40dbc9:	85 c0                	test   %eax,%eax
  40dbcb:	78 6d                	js     40dc3a <_Z9daemonizev+0xda>
            perror("dup2 stderr");
            return -1;
        }

        if (fd > STDERR_FILENO) {
  40dbcd:	83 fd 02             	cmp    $0x2,%ebp
  40dbd0:	7e 0e                	jle    40dbe0 <_Z9daemonizev+0x80>
            if(close(fd) < 0) {
  40dbd2:	89 ef                	mov    %ebp,%edi
  40dbd4:	e8 27 5f ff ff       	callq  403b00 <close@plt>
  40dbd9:	85 c0                	test   %eax,%eax
  40dbdb:	78 1a                	js     40dbf7 <_Z9daemonizev+0x97>
  40dbdd:	0f 1f 00             	nopl   (%rax)
                return -1;
            }
        }
    }
    return (0);
}
  40dbe0:	48 83 c4 08          	add    $0x8,%rsp
  40dbe4:	89 d8                	mov    %ebx,%eax
  40dbe6:	5b                   	pop    %rbx
  40dbe7:	5d                   	pop    %rbp
  40dbe8:	c3                   	retq   
  40dbe9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        case -1:
            return -1;
        case 0:
            break;
        default:
            _exit(EXIT_SUCCESS);
  40dbf0:	31 ff                	xor    %edi,%edi
  40dbf2:	e8 99 60 ff ff       	callq  403c90 <_exit@plt>
            return -1;
        }

        if (fd > STDERR_FILENO) {
            if(close(fd) < 0) {
                perror("close");
  40dbf7:	48 8d 3d 60 2f 00 00 	lea    0x2f60(%rip),%rdi        # 410b5e <_ZTS10LoggerImpl+0xb3>
                return -1;
  40dbfe:	83 cb ff             	or     $0xffffffff,%ebx
            return -1;
        }

        if (fd > STDERR_FILENO) {
            if(close(fd) < 0) {
                perror("close");
  40dc01:	e8 2a 65 ff ff       	callq  404130 <perror@plt>
  40dc06:	eb d8                	jmp    40dbe0 <_Z9daemonizev+0x80>
  40dc08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40dc0f:	00 

    /* creates a new session if the calling process is not a process group leader.
       https://linux.die.net/man/2/setsid
    */
    if (setsid() == -1)
        return -1;
  40dc10:	89 c3                	mov    %eax,%ebx
  40dc12:	eb cc                	jmp    40dbe0 <_Z9daemonizev+0x80>

    //将stdin、stdout、stderr重定向到/dev/null(或称空设备，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。)
    if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror("dup2 stdin");
  40dc14:	48 8d 3d 20 2f 00 00 	lea    0x2f20(%rip),%rdi        # 410b3b <_ZTS10LoggerImpl+0x90>
            return -1;
  40dc1b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
        return -1;

    //将stdin、stdout、stderr重定向到/dev/null(或称空设备，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。)
    if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror("dup2 stdin");
  40dc20:	e8 0b 65 ff ff       	callq  404130 <perror@plt>
  40dc25:	eb b9                	jmp    40dbe0 <_Z9daemonizev+0x80>
            return -1;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror("dup2 stdout");
  40dc27:	48 8d 3d 18 2f 00 00 	lea    0x2f18(%rip),%rdi        # 410b46 <_ZTS10LoggerImpl+0x9b>
            return -1;
  40dc2e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror("dup2 stdin");
            return -1;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror("dup2 stdout");
  40dc33:	e8 f8 64 ff ff       	callq  404130 <perror@plt>
  40dc38:	eb a6                	jmp    40dbe0 <_Z9daemonizev+0x80>
            return -1;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
            perror("dup2 stderr");
  40dc3a:	48 8d 3d 11 2f 00 00 	lea    0x2f11(%rip),%rdi        # 410b52 <_ZTS10LoggerImpl+0xa7>
            return -1;
  40dc41:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror("dup2 stdout");
            return -1;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
            perror("dup2 stderr");
  40dc46:	e8 e5 64 ff ff       	callq  404130 <perror@plt>
  40dc4b:	eb 93                	jmp    40dbe0 <_Z9daemonizev+0x80>
  40dc4d:	0f 1f 00             	nopl   (%rax)

000000000040dc50 <_Z13createPidFilev>:
        }
    }
    return (0);
}

void createPidFile(void) {
  40dc50:	53                   	push   %rbx
    /* Try to write the pid file in a best-effort way. */
    FILE *fp = fopen(CONFIG_DEFAULT_PID_FILE,"w");
  40dc51:	48 8d 35 0c 2f 00 00 	lea    0x2f0c(%rip),%rsi        # 410b64 <_ZTS10LoggerImpl+0xb9>
  40dc58:	48 8d 3d 07 2f 00 00 	lea    0x2f07(%rip),%rdi        # 410b66 <_ZTS10LoggerImpl+0xbb>
  40dc5f:	e8 fc 5f ff ff       	callq  403c60 <fopen@plt>
    if (fp) {
  40dc64:	48 85 c0             	test   %rax,%rax
    return (0);
}

void createPidFile(void) {
    /* Try to write the pid file in a best-effort way. */
    FILE *fp = fopen(CONFIG_DEFAULT_PID_FILE,"w");
  40dc67:	48 89 c3             	mov    %rax,%rbx
    if (fp) {
  40dc6a:	74 2c                	je     40dc98 <_Z13createPidFilev+0x48>
        fprintf(fp,"%d\n",(int)getpid());
  40dc6c:	e8 8f 60 ff ff       	callq  403d00 <getpid@plt>
  40dc71:	48 8d 15 f9 2e 00 00 	lea    0x2ef9(%rip),%rdx        # 410b71 <_ZTS10LoggerImpl+0xc6>
  40dc78:	48 89 df             	mov    %rbx,%rdi
  40dc7b:	89 c1                	mov    %eax,%ecx
  40dc7d:	be 01 00 00 00       	mov    $0x1,%esi
  40dc82:	31 c0                	xor    %eax,%eax
  40dc84:	e8 d7 5e ff ff       	callq  403b60 <__fprintf_chk@plt>
        fclose(fp);
  40dc89:	48 89 df             	mov    %rbx,%rdi
    }
}
  40dc8c:	5b                   	pop    %rbx
void createPidFile(void) {
    /* Try to write the pid file in a best-effort way. */
    FILE *fp = fopen(CONFIG_DEFAULT_PID_FILE,"w");
    if (fp) {
        fprintf(fp,"%d\n",(int)getpid());
        fclose(fp);
  40dc8d:	e9 7e 63 ff ff       	jmpq   404010 <fclose@plt>
  40dc92:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    }
}
  40dc98:	5b                   	pop    %rbx
  40dc99:	c3                   	retq   
  40dc9a:	90                   	nop
  40dc9b:	90                   	nop
  40dc9c:	90                   	nop
  40dc9d:	90                   	nop
  40dc9e:	90                   	nop
  40dc9f:	90                   	nop

000000000040dca0 <_ZN6rocket6ServerD1Ev>:
{
public:
    explicit Server(const uint32_t port, 
                    const int network_threads_num = 1,
                    const int work_threads_num = 1);
    ~Server() {}
  40dca0:	41 54                	push   %r12
  40dca2:	49 89 fc             	mov    %rdi,%r12
  40dca5:	55                   	push   %rbp
  40dca6:	48 8d bf c8 00 00 00 	lea    0xc8(%rdi),%rdi
  40dcad:	53                   	push   %rbx
  40dcae:	e8 4d da ff ff       	callq  40b700 <_ZN6rocket12EventWrapperD1Ev>
        initialized_ = true;
    }

    ~Mutex()
    {
        if (initialized_)
  40dcb3:	41 80 bc 24 c0 00 00 	cmpb   $0x0,0xc0(%r12)
  40dcba:	00 00 
  40dcbc:	75 62                	jne    40dd20 <_ZN6rocket6ServerD1Ev+0x80>

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() _GLIBCXX_NOEXCEPT
    {
      if (this->_M_impl._M_map)
  40dcbe:	49 8b 7c 24 48       	mov    0x48(%r12),%rdi
  40dcc3:	48 85 ff             	test   %rdi,%rdi
  40dcc6:	74 33                	je     40dcfb <_ZN6rocket6ServerD1Ev+0x5b>
	{
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
			   this->_M_impl._M_finish._M_node + 1);
  40dcc8:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
  40dccf:	00 
  40dcd0:	49 8b 5c 24 70       	mov    0x70(%r12),%rbx
  40dcd5:	48 8d 68 08          	lea    0x8(%rax),%rbp
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
  40dcd9:	48 39 dd             	cmp    %rbx,%rbp
  40dcdc:	76 18                	jbe    40dcf6 <_ZN6rocket6ServerD1Ev+0x56>
  40dcde:	66 90                	xchg   %ax,%ax
  40dce0:	48 8b 3b             	mov    (%rbx),%rdi
  40dce3:	48 83 c3 08          	add    $0x8,%rbx
  40dce7:	e8 c4 5e ff ff       	callq  403bb0 <_ZdlPv@plt>
  40dcec:	48 39 dd             	cmp    %rbx,%rbp
  40dcef:	77 ef                	ja     40dce0 <_ZN6rocket6ServerD1Ev+0x40>
  40dcf1:	49 8b 7c 24 48       	mov    0x48(%r12),%rdi
  40dcf6:	e8 b5 5e ff ff       	callq  403bb0 <_ZdlPv@plt>
      }
#endif

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  40dcfb:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
  40dd00:	48 85 ff             	test   %rdi,%rdi
  40dd03:	74 05                	je     40dd0a <_ZN6rocket6ServerD1Ev+0x6a>
  40dd05:	e8 a6 5e ff ff       	callq  403bb0 <_ZdlPv@plt>
      }
#endif

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  40dd0a:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
  40dd0f:	48 85 ff             	test   %rdi,%rdi
  40dd12:	74 4c                	je     40dd60 <_ZN6rocket6ServerD1Ev+0xc0>
  40dd14:	5b                   	pop    %rbx
  40dd15:	5d                   	pop    %rbp
  40dd16:	41 5c                	pop    %r12
  40dd18:	e9 93 5e ff ff       	jmpq   403bb0 <_ZdlPv@plt>
  40dd1d:	0f 1f 00             	nopl   (%rax)
        {
            initialized_ = false;
            int ret = pthread_mutex_destroy(&mutex_);
  40dd20:	49 8d bc 24 98 00 00 	lea    0x98(%r12),%rdi
  40dd27:	00 

    ~Mutex()
    {
        if (initialized_)
        {
            initialized_ = false;
  40dd28:	41 c6 84 24 c0 00 00 	movb   $0x0,0xc0(%r12)
  40dd2f:	00 00 
            int ret = pthread_mutex_destroy(&mutex_);
  40dd31:	e8 2a 64 ff ff       	callq  404160 <pthread_mutex_destroy@plt>
            //perror("pthread_mutex_destroy");
            assert(ret == 0);
  40dd36:	85 c0                	test   %eax,%eax
  40dd38:	74 84                	je     40dcbe <_ZN6rocket6ServerD1Ev+0x1e>
  40dd3a:	48 8d 0d df 2f 00 00 	lea    0x2fdf(%rip),%rcx        # 410d20 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__>
  40dd41:	48 8d 35 70 2d 00 00 	lea    0x2d70(%rip),%rsi        # 410ab8 <_ZTS10LoggerImpl+0xd>
  40dd48:	48 8d 3d 3c 2b 00 00 	lea    0x2b3c(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40dd4f:	ba 18 00 00 00       	mov    $0x18,%edx
  40dd54:	e8 87 5e ff ff       	callq  403be0 <__assert_fail@plt>
  40dd59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40dd60:	5b                   	pop    %rbx
  40dd61:	5d                   	pop    %rbp
  40dd62:	41 5c                	pop    %r12
  40dd64:	c3                   	retq   
  40dd65:	90                   	nop
  40dd66:	90                   	nop
  40dd67:	90                   	nop
  40dd68:	90                   	nop
  40dd69:	90                   	nop
  40dd6a:	90                   	nop
  40dd6b:	90                   	nop
  40dd6c:	90                   	nop
  40dd6d:	90                   	nop
  40dd6e:	90                   	nop
  40dd6f:	90                   	nop

000000000040dd70 <_ZN6rocket6ConfigD1Ev>:
#include "logger.h"

namespace rocket
{

class Config
  40dd70:	55                   	push   %rbp
  40dd71:	53                   	push   %rbx
  40dd72:	48 89 fd             	mov    %rdi,%rbp
  40dd75:	48 83 ec 18          	sub    $0x18,%rsp
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40dd79:	48 8b 47 30          	mov    0x30(%rdi),%rax

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40dd7d:	48 8b 1d dc 61 20 00 	mov    0x2061dc(%rip),%rbx        # 613f60 <_DYNAMIC+0x2d8>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40dd84:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40dd88:	48 39 df             	cmp    %rbx,%rdi
  40dd8b:	75 33                	jne    40ddc0 <_ZN6rocket6ConfigD1Ev+0x50>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40dd8d:	48 8b 45 28          	mov    0x28(%rbp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40dd91:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40dd95:	48 39 df             	cmp    %rbx,%rdi
  40dd98:	75 56                	jne    40ddf0 <_ZN6rocket6ConfigD1Ev+0x80>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40dd9a:	48 8b 45 20          	mov    0x20(%rbp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40dd9e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40dda2:	48 39 df             	cmp    %rbx,%rdi
  40dda5:	75 79                	jne    40de20 <_ZN6rocket6ConfigD1Ev+0xb0>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40dda7:	48 8b 45 00          	mov    0x0(%rbp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40ddab:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40ddaf:	48 39 df             	cmp    %rbx,%rdi
  40ddb2:	0f 85 a0 00 00 00    	jne    40de58 <_ZN6rocket6ConfigD1Ev+0xe8>
  40ddb8:	48 83 c4 18          	add    $0x18,%rsp
  40ddbc:	5b                   	pop    %rbx
  40ddbd:	5d                   	pop    %rbp
  40ddbe:	c3                   	retq   
  40ddbf:	90                   	nop
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40ddc0:	48 83 3d b0 61 20 00 	cmpq   $0x0,0x2061b0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40ddc7:	00 
  40ddc8:	0f 84 d2 00 00 00    	je     40dea0 <_ZN6rocket6ConfigD1Ev+0x130>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40ddce:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40ddd3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40ddd8:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40ddda:	85 c0                	test   %eax,%eax
  40dddc:	7f af                	jg     40dd8d <_ZN6rocket6ConfigD1Ev+0x1d>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40ddde:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40dde3:	e8 88 5f ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40dde8:	eb a3                	jmp    40dd8d <_ZN6rocket6ConfigD1Ev+0x1d>
  40ddea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40ddf0:	48 83 3d 80 61 20 00 	cmpq   $0x0,0x206180(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40ddf7:	00 
  40ddf8:	0f 84 8a 00 00 00    	je     40de88 <_ZN6rocket6ConfigD1Ev+0x118>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40ddfe:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40de03:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40de08:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40de0a:	85 c0                	test   %eax,%eax
  40de0c:	7f 8c                	jg     40dd9a <_ZN6rocket6ConfigD1Ev+0x2a>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40de0e:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40de13:	e8 58 5f ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40de18:	eb 80                	jmp    40dd9a <_ZN6rocket6ConfigD1Ev+0x2a>
  40de1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40de20:	48 83 3d 50 61 20 00 	cmpq   $0x0,0x206150(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40de27:	00 
  40de28:	0f 84 92 00 00 00    	je     40dec0 <_ZN6rocket6ConfigD1Ev+0x150>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40de2e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40de33:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40de38:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40de3a:	85 c0                	test   %eax,%eax
  40de3c:	0f 8f 65 ff ff ff    	jg     40dda7 <_ZN6rocket6ConfigD1Ev+0x37>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40de42:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40de47:	e8 24 5f ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40de4c:	e9 56 ff ff ff       	jmpq   40dda7 <_ZN6rocket6ConfigD1Ev+0x37>
  40de51:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40de58:	48 83 3d 18 61 20 00 	cmpq   $0x0,0x206118(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40de5f:	00 
  40de60:	74 4e                	je     40deb0 <_ZN6rocket6ConfigD1Ev+0x140>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40de62:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40de67:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40de6c:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40de6e:	85 c0                	test   %eax,%eax
  40de70:	0f 8f 42 ff ff ff    	jg     40ddb8 <_ZN6rocket6ConfigD1Ev+0x48>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40de76:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40de7b:	e8 f0 5e ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40de80:	e9 33 ff ff ff       	jmpq   40ddb8 <_ZN6rocket6ConfigD1Ev+0x48>
  40de85:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40de88:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40de8b:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40de8e:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40de91:	89 d0                	mov    %edx,%eax
  40de93:	e9 72 ff ff ff       	jmpq   40de0a <_ZN6rocket6ConfigD1Ev+0x9a>
  40de98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40de9f:	00 
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40dea0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40dea3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40dea6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40dea9:	89 d0                	mov    %edx,%eax
  40deab:	e9 2a ff ff ff       	jmpq   40ddda <_ZN6rocket6ConfigD1Ev+0x6a>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40deb0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40deb3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40deb6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40deb9:	89 d0                	mov    %edx,%eax
  40debb:	eb b1                	jmp    40de6e <_ZN6rocket6ConfigD1Ev+0xfe>
  40debd:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40dec0:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40dec3:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40dec6:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40dec9:	89 d0                	mov    %edx,%eax
  40decb:	e9 6a ff ff ff       	jmpq   40de3a <_ZN6rocket6ConfigD1Ev+0xca>

000000000040ded0 <_ZN6rocket6Server14WorkThreadFuncEv>:
        delete *it;
        *it = NULL;
    }
}

void Server::WorkThreadFunc() {
  40ded0:	55                   	push   %rbp
  40ded1:	48 89 e5             	mov    %rsp,%rbp
  40ded4:	41 57                	push   %r15
  40ded6:	41 56                	push   %r14
  40ded8:	41 55                	push   %r13
  40deda:	41 54                	push   %r12
  40dedc:	53                   	push   %rbx
  40dedd:	48 89 fb             	mov    %rdi,%rbx
  40dee0:	48 83 ec 78          	sub    $0x78,%rsp
    LOG_DEBUG("WorkThreadFunc begin");
  40dee4:	e8 47 dc ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40dee9:	4c 8b 08             	mov    (%rax),%r9
  40deec:	31 f6                	xor    %esi,%esi
  40deee:	48 89 c7             	mov    %rax,%rdi
  40def1:	4c 8d 05 40 2e 00 00 	lea    0x2e40(%rip),%r8        # 410d38 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x18>
  40def8:	31 c0                	xor    %eax,%eax
  40defa:	b9 4f 00 00 00       	mov    $0x4f,%ecx
  40deff:	48 8d 15 47 2e 00 00 	lea    0x2e47(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40df06:	41 ff 51 20          	callq  *0x20(%r9)
    while(!stop_) {
  40df0a:	0f b6 43 40          	movzbl 0x40(%rbx),%eax
  40df0e:	84 c0                	test   %al,%al
  40df10:	0f 85 ba 02 00 00    	jne    40e1d0 <_ZN6rocket6Server14WorkThreadFuncEv+0x300>
  40df16:	48 8d 83 c8 00 00 00 	lea    0xc8(%rbx),%rax
  40df1d:	4c 8d ab 98 00 00 00 	lea    0x98(%rbx),%r13
        blob.owner = c;
        blob.data = new char[read_buffer.size()];
        memcpy(blob.data, read_buffer.c_str(), read_buffer.size());

        // 检查数据包完整性
        int pktlen = rocket_dll.rocket_handle_input(&blob);
  40df24:	4c 8d 7d b0          	lea    -0x50(%rbp),%r15
  40df28:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        Commu* c  = connection_que_.pop_front();;
        int fd = c->get_fd();

        std::string read_buffer;
        bool end = false;
        BaseSocket::nbRead(fd, read_buffer, end);
  40df2c:	48 8d 45 9e          	lea    -0x62(%rbp),%rax
  40df30:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  40df37:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  40df3b:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  40df42:	48 8d 45 9f          	lea    -0x61(%rbp),%rax
  40df46:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  40df4d:	e9 ba 00 00 00       	jmpq   40e00c <_ZN6rocket6Server14WorkThreadFuncEv+0x13c>
  40df52:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        memcpy(blob.data, read_buffer.c_str(), read_buffer.size());

        // 检查数据包完整性
        int pktlen = rocket_dll.rocket_handle_input(&blob);
        if (pktlen > 0) {
            LOG_DEBUG("WorkThreadFunc rocket_handle_input, fd=%d read_buffer.size=%d", 
  40df58:	e8 d3 db ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40df5d:	4c 8b 10             	mov    (%rax),%r10
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40df60:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
                  fd, read_buffer.size());
  40df64:	48 83 ec 08          	sub    $0x8,%rsp
  40df68:	48 89 c7             	mov    %rax,%rdi
  40df6b:	45 89 e1             	mov    %r12d,%r9d
  40df6e:	4c 8d 05 db 2e 00 00 	lea    0x2edb(%rip),%r8        # 410e50 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x130>
  40df75:	b9 65 00 00 00       	mov    $0x65,%ecx
  40df7a:	31 f6                	xor    %esi,%esi
  40df7c:	31 c0                	xor    %eax,%eax
  40df7e:	ff 72 e8             	pushq  -0x18(%rdx)
  40df81:	48 8d 15 c5 2d 00 00 	lea    0x2dc5(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40df88:	41 ff 52 20          	callq  *0x20(%r10)
  40df8c:	59                   	pop    %rcx
  40df8d:	5e                   	pop    %rsi
            // 处理请求
            rocket_dll.rocket_handle_process(&blob);
  40df8e:	4c 89 ff             	mov    %r15,%rdi
  40df91:	41 ff 56 20          	callq  *0x20(%r14)
        } else {
            std::cout << "rocket_handle_input error" << std::endl;
        }

        delete[] blob.data;
  40df95:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  40df99:	48 85 ff             	test   %rdi,%rdi
  40df9c:	74 05                	je     40dfa3 <_ZN6rocket6Server14WorkThreadFuncEv+0xd3>
  40df9e:	e8 3d 60 ff ff       	callq  403fe0 <_ZdaPv@plt>
        delete c;
  40dfa3:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  40dfa7:	48 8b 07             	mov    (%rdi),%rax
  40dfaa:	ff 50 08             	callq  *0x8(%rax)
        c = NULL;
        BaseSocket::close(fd);
  40dfad:	44 89 e7             	mov    %r12d,%edi
  40dfb0:	e8 db 14 00 00       	callq  40f490 <_ZN6rocket10BaseSocket5closeEi>
        LOG_DEBUG("WorkThreadFunc end, fd=%d read_buffer.size=%d", 
  40dfb5:	e8 76 db ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40dfba:	4c 8b 10             	mov    (%rax),%r10
  40dfbd:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
                  fd, read_buffer.size());
  40dfc1:	48 83 ec 08          	sub    $0x8,%rsp
  40dfc5:	48 89 c7             	mov    %rax,%rdi
  40dfc8:	45 89 e1             	mov    %r12d,%r9d
  40dfcb:	4c 8d 05 be 2e 00 00 	lea    0x2ebe(%rip),%r8        # 410e90 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x170>
  40dfd2:	b9 71 00 00 00       	mov    $0x71,%ecx
  40dfd7:	31 f6                	xor    %esi,%esi
  40dfd9:	31 c0                	xor    %eax,%eax
  40dfdb:	ff 72 e8             	pushq  -0x18(%rdx)
  40dfde:	48 8d 15 68 2d 00 00 	lea    0x2d68(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40dfe5:	41 ff 52 20          	callq  *0x20(%r10)
  40dfe9:	58                   	pop    %rax
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40dfea:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  40dfee:	5a                   	pop    %rdx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40dfef:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40dff3:	48 3b 3d 66 5f 20 00 	cmp    0x205f66(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40dffa:	0f 85 90 01 00 00    	jne    40e190 <_ZN6rocket6Server14WorkThreadFuncEv+0x2c0>
    }
}

void Server::WorkThreadFunc() {
    LOG_DEBUG("WorkThreadFunc begin");
    while(!stop_) {
  40e000:	0f b6 43 40          	movzbl 0x40(%rbx),%eax
  40e004:	84 c0                	test   %al,%al
  40e006:	0f 85 c4 01 00 00    	jne    40e1d0 <_ZN6rocket6Server14WorkThreadFuncEv+0x300>
        LOG_DEBUG("WorkThreadFunc begin1");
  40e00c:	e8 1f db ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40e011:	4c 8b 08             	mov    (%rax),%r9
  40e014:	31 f6                	xor    %esi,%esi
  40e016:	4c 8d 05 3a 2d 00 00 	lea    0x2d3a(%rip),%r8        # 410d57 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x37>
  40e01d:	b9 51 00 00 00       	mov    $0x51,%ecx
  40e022:	48 8d 15 24 2d 00 00 	lea    0x2d24(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40e029:	48 89 c7             	mov    %rax,%rdi
  40e02c:	31 c0                	xor    %eax,%eax
  40e02e:	41 ff 51 20          	callq  *0x20(%r9)
        
        connection_que_ev_.WaitAlways();
  40e032:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  40e036:	e8 d5 d7 ff ff       	callq  40b810 <_ZN6rocket12EventWrapper10WaitAlwaysEv>
        }
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&mutex_);
  40e03b:	4c 89 ef             	mov    %r13,%rdi
  40e03e:	e8 dd 60 ff ff       	callq  404120 <pthread_mutex_lock@plt>
        assert(ret == 0);
  40e043:	85 c0                	test   %eax,%eax
  40e045:	0f 85 f2 01 00 00    	jne    40e23d <_ZN6rocket6Server14WorkThreadFuncEv+0x36d>
  40e04b:	48 8b 43 58          	mov    0x58(%rbx),%rax
    }

    Connection* pop_front() {
        Lock Lock(mutex_);
        Connection* c = NULL;
        if (!que_.empty())
  40e04f:	48 39 43 78          	cmp    %rax,0x78(%rbx)
  40e053:	0f 84 bf 01 00 00    	je     40e218 <_ZN6rocket6Server14WorkThreadFuncEv+0x348>
        {
            c = que_.front();
  40e059:	48 8b 08             	mov    (%rax),%rcx
  40e05c:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
       */
      void
      pop_front() _GLIBCXX_NOEXCEPT
      {
	if (this->_M_impl._M_start._M_cur
	    != this->_M_impl._M_start._M_last - 1)
  40e060:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
  40e064:	48 8d 51 f8          	lea    -0x8(%rcx),%rdx
       *  needed, it should be retrieved before pop_front() is called.
       */
      void
      pop_front() _GLIBCXX_NOEXCEPT
      {
	if (this->_M_impl._M_start._M_cur
  40e068:	48 39 d0             	cmp    %rdx,%rax
  40e06b:	0f 84 6f 01 00 00    	je     40e1e0 <_ZN6rocket6Server14WorkThreadFuncEv+0x310>
	    != this->_M_impl._M_start._M_last - 1)
	  {
	    this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
	    ++this->_M_impl._M_start._M_cur;
  40e071:	48 83 c0 08          	add    $0x8,%rax
  40e075:	48 89 43 58          	mov    %rax,0x58(%rbx)
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&mutex_);
  40e079:	4c 89 ef             	mov    %r13,%rdi
  40e07c:	e8 4f 61 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        //perror("pthread_mutex_unlock");
        assert(ret == 0);
  40e081:	85 c0                	test   %eax,%eax
  40e083:	0f 85 af 01 00 00    	jne    40e238 <_ZN6rocket6Server14WorkThreadFuncEv+0x368>
        Commu* c  = connection_que_.pop_front();;
        int fd = c->get_fd();
  40e089:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
  40e08d:	49 8b 06             	mov    (%r14),%rax
  40e090:	4c 89 f7             	mov    %r14,%rdi
  40e093:	ff 50 20             	callq  *0x20(%rax)
  40e096:	41 89 c4             	mov    %eax,%r12d

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }
  40e099:	48 8b 05 c0 5e 20 00 	mov    0x205ec0(%rip),%rax        # 613f60 <_DYNAMIC+0x2d8>

        std::string read_buffer;
        bool end = false;
        BaseSocket::nbRead(fd, read_buffer, end);
  40e0a0:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  40e0a7:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
  40e0ae:	44 89 e7             	mov    %r12d,%edi
        connection_que_ev_.WaitAlways();
        Commu* c  = connection_que_.pop_front();;
        int fd = c->get_fd();

        std::string read_buffer;
        bool end = false;
  40e0b1:	c6 45 9e 00          	movb   $0x0,-0x62(%rbp)
  40e0b5:	48 83 c0 18          	add    $0x18,%rax
  40e0b9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        BaseSocket::nbRead(fd, read_buffer, end);
  40e0bd:	e8 ee 1c 00 00       	callq  40fdb0 <_ZN6rocket10BaseSocket6nbReadEiRSsRb>
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
  40e0c2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  40e0c6:	48 8b 78 e8          	mov    -0x18(%rax),%rdi

        blob_type blob;
        blob.len = read_buffer.size();
        blob.owner = c;
  40e0ca:	4c 89 75 b8          	mov    %r14,-0x48(%rbp)
        std::string read_buffer;
        bool end = false;
        BaseSocket::nbRead(fd, read_buffer, end);

        blob_type blob;
        blob.len = read_buffer.size();
  40e0ce:	89 7d b0             	mov    %edi,-0x50(%rbp)
        blob.owner = c;
        blob.data = new char[read_buffer.size()];
  40e0d1:	e8 ba 5a ff ff       	callq  403b90 <_Znam@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40e0d6:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi

__extern_always_inline void *
__NTH (memcpy (void *__restrict __dest, __const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
  40e0da:	48 89 c7             	mov    %rax,%rdi
  40e0dd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  40e0e1:	48 8b 56 e8          	mov    -0x18(%rsi),%rdx
  40e0e5:	e8 36 61 ff ff       	callq  404220 <memcpy@plt>
        memcpy(blob.data, read_buffer.c_str(), read_buffer.size());

        // 检查数据包完整性
        int pktlen = rocket_dll.rocket_handle_input(&blob);
  40e0ea:	4c 8b 35 1f 5e 20 00 	mov    0x205e1f(%rip),%r14        # 613f10 <_DYNAMIC+0x288>
  40e0f1:	4c 89 ff             	mov    %r15,%rdi
  40e0f4:	41 ff 56 10          	callq  *0x10(%r14)
        if (pktlen > 0) {
  40e0f8:	85 c0                	test   %eax,%eax
  40e0fa:	0f 8f 58 fe ff ff    	jg     40df58 <_ZN6rocket6Server14WorkThreadFuncEv+0x88>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40e100:	48 8b 3d 19 5e 20 00 	mov    0x205e19(%rip),%rdi        # 613f20 <_DYNAMIC+0x298>
  40e107:	48 8d 35 5f 2c 00 00 	lea    0x2c5f(%rip),%rsi        # 410d6d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x4d>
  40e10e:	ba 19 00 00 00       	mov    $0x19,%edx
  40e113:	e8 88 5d ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40e118:	48 8b 05 01 5e 20 00 	mov    0x205e01(%rip),%rax        # 613f20 <_DYNAMIC+0x298>
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40e11f:	48 8b 0d fa 5d 20 00 	mov    0x205dfa(%rip),%rcx        # 613f20 <_DYNAMIC+0x298>
  40e126:	48 8b 00             	mov    (%rax),%rax
  40e129:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40e12d:	4c 8b b4 08 f0 00 00 	mov    0xf0(%rax,%rcx,1),%r14
  40e134:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40e135:	4d 85 f6             	test   %r14,%r14
  40e138:	0f 84 04 01 00 00    	je     40e242 <_ZN6rocket6Server14WorkThreadFuncEv+0x372>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40e13e:	41 80 7e 38 00       	cmpb   $0x0,0x38(%r14)
  40e143:	74 23                	je     40e168 <_ZN6rocket6Server14WorkThreadFuncEv+0x298>
  40e145:	41 0f be 76 43       	movsbl 0x43(%r14),%esi
  40e14a:	48 8b 3d cf 5d 20 00 	mov    0x205dcf(%rip),%rdi        # 613f20 <_DYNAMIC+0x298>
  40e151:	e8 8a 60 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40e156:	48 89 c7             	mov    %rax,%rdi
  40e159:	e8 d2 5d ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
  40e15e:	e9 32 fe ff ff       	jmpq   40df95 <_ZN6rocket6Server14WorkThreadFuncEv+0xc5>
  40e163:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40e168:	4c 89 f7             	mov    %r14,%rdi
  40e16b:	e8 80 5a ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40e170:	49 8b 06             	mov    (%r14),%rax
  40e173:	be 0a 00 00 00       	mov    $0xa,%esi
  40e178:	48 8b 40 30          	mov    0x30(%rax),%rax
  40e17c:	48 3b 05 0d 5e 20 00 	cmp    0x205e0d(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40e183:	74 c5                	je     40e14a <_ZN6rocket6Server14WorkThreadFuncEv+0x27a>
  40e185:	4c 89 f7             	mov    %r14,%rdi
  40e188:	ff d0                	callq  *%rax
  40e18a:	0f be f0             	movsbl %al,%esi
  40e18d:	eb bb                	jmp    40e14a <_ZN6rocket6Server14WorkThreadFuncEv+0x27a>
  40e18f:	90                   	nop
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40e190:	48 83 3d e0 5d 20 00 	cmpq   $0x0,0x205de0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40e197:	00 
  40e198:	0f 84 8a 00 00 00    	je     40e228 <_ZN6rocket6Server14WorkThreadFuncEv+0x358>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40e19e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40e1a3:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40e1a8:	89 d0                	mov    %edx,%eax
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40e1aa:	85 c0                	test   %eax,%eax
  40e1ac:	0f 8f 4e fe ff ff    	jg     40e000 <_ZN6rocket6Server14WorkThreadFuncEv+0x130>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40e1b2:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  40e1b9:	e8 b2 5b ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
    }
}

void Server::WorkThreadFunc() {
    LOG_DEBUG("WorkThreadFunc begin");
    while(!stop_) {
  40e1be:	0f b6 43 40          	movzbl 0x40(%rbx),%eax
  40e1c2:	84 c0                	test   %al,%al
  40e1c4:	0f 84 42 fe ff ff    	je     40e00c <_ZN6rocket6Server14WorkThreadFuncEv+0x13c>
  40e1ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        c = NULL;
        BaseSocket::close(fd);
        LOG_DEBUG("WorkThreadFunc end, fd=%d read_buffer.size=%d", 
                  fd, read_buffer.size());
    }
}
  40e1d0:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  40e1d4:	5b                   	pop    %rbx
  40e1d5:	41 5c                	pop    %r12
  40e1d7:	41 5d                	pop    %r13
  40e1d9:	41 5e                	pop    %r14
  40e1db:	41 5f                	pop    %r15
  40e1dd:	5d                   	pop    %rbp
  40e1de:	c3                   	retq   
  40e1df:	90                   	nop
  40e1e0:	48 8b 7b 60          	mov    0x60(%rbx),%rdi
  40e1e4:	e8 c7 59 ff ff       	callq  403bb0 <_ZdlPv@plt>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
  40e1e9:	48 8b 43 70          	mov    0x70(%rbx),%rax
  40e1ed:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40e1f1:	48 89 53 70          	mov    %rdx,0x70(%rbx)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40e1f5:	48 8b 40 08          	mov    0x8(%rax),%rax
	_M_last = _M_first + difference_type(_S_buffer_size());
  40e1f9:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40e200:	48 89 43 60          	mov    %rax,0x60(%rbx)
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
  40e204:	48 89 43 58          	mov    %rax,0x58(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40e208:	48 89 53 68          	mov    %rdx,0x68(%rbx)
  40e20c:	e9 68 fe ff ff       	jmpq   40e079 <_ZN6rocket6Server14WorkThreadFuncEv+0x1a9>
  40e211:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        que_.push_back(c);
    }

    Connection* pop_front() {
        Lock Lock(mutex_);
        Connection* c = NULL;
  40e218:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
  40e21f:	00 
  40e220:	e9 54 fe ff ff       	jmpq   40e079 <_ZN6rocket6Server14WorkThreadFuncEv+0x1a9>
  40e225:	0f 1f 00             	nopl   (%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40e228:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40e22b:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40e22e:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40e231:	89 d0                	mov    %edx,%eax
  40e233:	e9 72 ff ff ff       	jmpq   40e1aa <_ZN6rocket6Server14WorkThreadFuncEv+0x2da>
  40e238:	e8 93 61 ff ff       	callq  4043d0 <_ZN6rocket5Mutex6unlockEv.part.7>
  40e23d:	e8 6e 61 ff ff       	callq  4043b0 <_ZN6rocket5Mutex4lockEv.part.6>
	__throw_bad_cast();
  40e242:	e8 99 58 ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
  40e247:	48 89 c3             	mov    %rax,%rbx
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40e24a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  40e24e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40e252:	48 3b 3d 07 5d 20 00 	cmp    0x205d07(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40e259:	74 09                	je     40e264 <_ZN6rocket6Server14WorkThreadFuncEv+0x394>
  40e25b:	48 8d 75 9f          	lea    -0x61(%rbp),%rsi
  40e25f:	e8 24 61 ff ff       	callq  404388 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.1>
  40e264:	48 89 df             	mov    %rbx,%rdi
  40e267:	e8 34 5f ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40e26c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040e270 <_ZN6rocket6Server4initEv>:
    , stop_(false) {
    LOG_INFO("Server::server");
    init();
};

int Server::init() {
  40e270:	53                   	push   %rbx
  40e271:	48 89 fb             	mov    %rdi,%rbx
	listenfd_ = BaseSocket::socket();
  40e274:	bf 01 00 00 00       	mov    $0x1,%edi
    , stop_(false) {
    LOG_INFO("Server::server");
    init();
};

int Server::init() {
  40e279:	48 83 ec 10          	sub    $0x10,%rsp
	listenfd_ = BaseSocket::socket();
  40e27d:	e8 fe 11 00 00       	callq  40f480 <_ZN6rocket10BaseSocket6socketEi>
	if (-1 == listenfd_) {
  40e282:	83 f8 ff             	cmp    $0xffffffff,%eax
    LOG_INFO("Server::server");
    init();
};

int Server::init() {
	listenfd_ = BaseSocket::socket();
  40e285:	89 43 0c             	mov    %eax,0xc(%rbx)
	if (-1 == listenfd_) {
  40e288:	74 46                	je     40e2d0 <_ZN6rocket6Server4initEv+0x60>
		perror("socket()");
		return -1;
	}

    int ret = -1;
	ret = BaseSocket::setReuseAddr(listenfd_);
  40e28a:	89 c7                	mov    %eax,%edi
  40e28c:	e8 2f 12 00 00       	callq  40f4c0 <_ZN6rocket10BaseSocket12setReuseAddrEi>
    ret = BaseSocket::setNonBlocking(listenfd_);
  40e291:	8b 7b 0c             	mov    0xc(%rbx),%edi
  40e294:	e8 07 12 00 00       	callq  40f4a0 <_ZN6rocket10BaseSocket14setNonBlockingEi>

    ret = BaseSocket::bind(listenfd_, port_);
  40e299:	8b 73 08             	mov    0x8(%rbx),%esi
  40e29c:	8b 7b 0c             	mov    0xc(%rbx),%edi
  40e29f:	31 d2                	xor    %edx,%edx
  40e2a1:	e8 4a 12 00 00       	callq  40f4f0 <_ZN6rocket10BaseSocket4bindEiiPKc>
    ret = BaseSocket::listen(listenfd_, INT_MAX);
  40e2a6:	8b 7b 0c             	mov    0xc(%rbx),%edi
  40e2a9:	be ff ff ff 7f       	mov    $0x7fffffff,%esi
  40e2ae:	e8 bd 12 00 00       	callq  40f570 <_ZN6rocket10BaseSocket6listenEii>

    
    int* p = new int[10];
  40e2b3:	bf 28 00 00 00       	mov    $0x28,%edi
    int ret = -1;
	ret = BaseSocket::setReuseAddr(listenfd_);
    ret = BaseSocket::setNonBlocking(listenfd_);

    ret = BaseSocket::bind(listenfd_, port_);
    ret = BaseSocket::listen(listenfd_, INT_MAX);
  40e2b8:	0f b6 d8             	movzbl %al,%ebx

    
    int* p = new int[10];
  40e2bb:	e8 d0 58 ff ff       	callq  403b90 <_Znam@plt>

	return ret;
  40e2c0:	89 d8                	mov    %ebx,%eax
}
  40e2c2:	48 83 c4 10          	add    $0x10,%rsp
  40e2c6:	5b                   	pop    %rbx
  40e2c7:	c3                   	retq   
  40e2c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40e2cf:	00 
};

int Server::init() {
	listenfd_ = BaseSocket::socket();
	if (-1 == listenfd_) {
		perror("socket()");
  40e2d0:	48 8d 3d b0 2a 00 00 	lea    0x2ab0(%rip),%rdi        # 410d87 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x67>
  40e2d7:	89 44 24 0c          	mov    %eax,0xc(%rsp)
  40e2db:	e8 50 5e ff ff       	callq  404130 <perror@plt>
		return -1;
  40e2e0:	8b 44 24 0c          	mov    0xc(%rsp),%eax
  40e2e4:	eb dc                	jmp    40e2c2 <_ZN6rocket6Server4initEv+0x52>
  40e2e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40e2ed:	00 00 00 

000000000040e2f0 <_ZN6rocket6ServerC1Ejii>:
#include "load_so.h"
#include "unistd.h"

namespace rocket {

Server::Server(const uint32_t port, 
  40e2f0:	41 55                	push   %r13
  40e2f2:	41 54                	push   %r12
  40e2f4:	55                   	push   %rbp
  40e2f5:	53                   	push   %rbx
  40e2f6:	48 89 fb             	mov    %rdi,%rbx
  40e2f9:	48 83 ec 08          	sub    $0x8,%rsp
               const int work_threads_num/* = 1*/) 
    : port_(port)
    , listenfd_(0)
    , network_threads_num_(network_threads_num)
    , work_threads_num_(work_threads_num)
    , stop_(false) {
  40e2fd:	89 17                	mov    %edx,(%rdi)
  40e2ff:	89 4f 04             	mov    %ecx,0x4(%rdi)
  40e302:	89 77 08             	mov    %esi,0x8(%rdi)
  40e305:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
  40e30c:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  40e313:	00 
  40e314:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  40e31b:	00 
  40e31c:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
  40e323:	00 
  40e324:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
  40e32b:	00 
  40e32c:	48 c7 47 30 00 00 00 	movq   $0x0,0x30(%rdi)
  40e333:	00 
  40e334:	48 c7 47 38 00 00 00 	movq   $0x0,0x38(%rdi)
  40e33b:	00 
  40e33c:	c6 47 40 00          	movb   $0x0,0x40(%rdi)
	iterator _M_start;
	iterator _M_finish;

	_Deque_impl()
	: _Tp_alloc_type(), _M_map(0), _M_map_size(0),
	  _M_start(), _M_finish()
  40e340:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
  40e347:	00 
      _Deque_iterator(_Tp* __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() _GLIBCXX_NOEXCEPT
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }
  40e348:	48 c7 47 58 00 00 00 	movq   $0x0,0x58(%rdi)
  40e34f:	00 
  40e350:	48 c7 47 60 00 00 00 	movq   $0x0,0x60(%rdi)
  40e357:	00 
  40e358:	48 c7 47 68 00 00 00 	movq   $0x0,0x68(%rdi)
  40e35f:	00 
  40e360:	48 c7 47 70 00 00 00 	movq   $0x0,0x70(%rdi)
  40e367:	00 
  40e368:	48 c7 47 78 00 00 00 	movq   $0x0,0x78(%rdi)
  40e36f:	00 
  40e370:	48 c7 87 80 00 00 00 	movq   $0x0,0x80(%rdi)
  40e377:	00 00 00 00 
  40e37b:	48 c7 87 88 00 00 00 	movq   $0x0,0x88(%rdi)
  40e382:	00 00 00 00 
  40e386:	48 c7 87 90 00 00 00 	movq   $0x0,0x90(%rdi)
  40e38d:	00 00 00 00 
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
				  + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
  40e391:	48 c7 47 50 08 00 00 	movq   $0x8,0x50(%rdi)
  40e398:	00 
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40e399:	bf 40 00 00 00       	mov    $0x40,%edi
  40e39e:	e8 dd 5d ff ff       	callq  404180 <_Znwm@plt>
      // starts in the middle elements and grows outwards.  So nstart may be
      // the beginning of _M_map, but for small maps it may be as far in as
      // _M_map+3.

      _Tp** __nstart = (this->_M_impl._M_map
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
  40e3a3:	48 8b 53 50          	mov    0x50(%rbx),%rdx
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
				  + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
					   size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
  40e3a7:	48 89 43 48          	mov    %rax,0x48(%rbx)
  40e3ab:	bf 00 02 00 00       	mov    $0x200,%edi
      // starts in the middle elements and grows outwards.  So nstart may be
      // the beginning of _M_map, but for small maps it may be as far in as
      // _M_map+3.

      _Tp** __nstart = (this->_M_impl._M_map
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
  40e3b0:	48 8d 14 95 fc ff ff 	lea    -0x4(,%rdx,4),%rdx
  40e3b7:	ff 
  40e3b8:	48 83 e2 f8          	and    $0xfffffffffffffff8,%rdx
  40e3bc:	48 8d 2c 10          	lea    (%rax,%rdx,1),%rbp
  40e3c0:	e8 bb 5d ff ff       	callq  404180 <_Znwm@plt>
    {
      _Tp** __cur;
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
	    *__cur = this->_M_allocate_node();
  40e3c5:	48 89 45 00          	mov    %rax,0x0(%rbp)
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
  40e3c9:	48 89 6b 70          	mov    %rbp,0x70(%rbx)

class Mutex {
public:
    Mutex()
    {
        int ret = pthread_mutex_init(&mutex_, NULL);
  40e3cd:	31 f6                	xor    %esi,%esi
	_M_first = *__new_node;
  40e3cf:	48 8b 55 00          	mov    0x0(%rbp),%rdx
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
  40e3d3:	48 89 ab 90 00 00 00 	mov    %rbp,0x90(%rbx)
	_M_first = *__new_node;
	_M_last = _M_first + difference_type(_S_buffer_size());
  40e3da:	48 8d 82 00 02 00 00 	lea    0x200(%rdx),%rax
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40e3e1:	48 89 53 60          	mov    %rdx,0x60(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40e3e5:	48 89 43 68          	mov    %rax,0x68(%rbx)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40e3e9:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40e3ed:	48 8d ab 98 00 00 00 	lea    0x98(%rbx),%rbp
	  __throw_exception_again;
	}

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
  40e3f4:	48 89 53 58          	mov    %rdx,0x58(%rbx)
  40e3f8:	48 89 ef             	mov    %rbp,%rdi
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
	_M_last = _M_first + difference_type(_S_buffer_size());
  40e3fb:	48 8d 88 00 02 00 00 	lea    0x200(%rax),%rcx
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40e402:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
	}

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
  40e409:	48 89 43 78          	mov    %rax,0x78(%rbx)
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
	_M_last = _M_first + difference_type(_S_buffer_size());
  40e40d:	48 89 8b 88 00 00 00 	mov    %rcx,0x88(%rbx)
  40e414:	e8 f7 58 ff ff       	callq  403d10 <pthread_mutex_init@plt>
        assert(ret == 0);
  40e419:	85 c0                	test   %eax,%eax
  40e41b:	0f 85 04 01 00 00    	jne    40e525 <_ZN6rocket6ServerC1Ejii+0x235>
  40e421:	4c 8d a3 c8 00 00 00 	lea    0xc8(%rbx),%r12
        initialized_ = true;
  40e428:	c6 83 c0 00 00 00 01 	movb   $0x1,0xc0(%rbx)
  40e42f:	4c 89 e7             	mov    %r12,%rdi
  40e432:	e8 99 d2 ff ff       	callq  40b6d0 <_ZN6rocket12EventWrapperC1Ev>
    LOG_INFO("Server::server");
  40e437:	e8 f4 d6 ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40e43c:	4c 8b 08             	mov    (%rax),%r9
  40e43f:	48 89 c7             	mov    %rax,%rdi
  40e442:	4c 8d 05 47 29 00 00 	lea    0x2947(%rip),%r8        # 410d90 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x70>
  40e449:	b9 16 00 00 00       	mov    $0x16,%ecx
  40e44e:	48 8d 15 f8 28 00 00 	lea    0x28f8(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40e455:	be 01 00 00 00       	mov    $0x1,%esi
  40e45a:	31 c0                	xor    %eax,%eax
  40e45c:	41 ff 51 20          	callq  *0x20(%r9)
    init();
  40e460:	48 89 df             	mov    %rbx,%rdi
  40e463:	e8 08 fe ff ff       	callq  40e270 <_ZN6rocket6Server4initEv>
};
  40e468:	48 83 c4 08          	add    $0x8,%rsp
  40e46c:	5b                   	pop    %rbx
  40e46d:	5d                   	pop    %rbp
  40e46e:	41 5c                	pop    %r12
  40e470:	41 5d                	pop    %r13
  40e472:	c3                   	retq   
  40e473:	48 89 c5             	mov    %rax,%rbp
      }
#endif

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  40e476:	48 8b 7b 28          	mov    0x28(%rbx),%rdi

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
  40e47a:	48 85 ff             	test   %rdi,%rdi
  40e47d:	74 05                	je     40e484 <_ZN6rocket6ServerC1Ejii+0x194>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40e47f:	e8 2c 57 ff ff       	callq  403bb0 <_ZdlPv@plt>
      }
#endif

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  40e484:	48 8b 7b 10          	mov    0x10(%rbx),%rdi

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
  40e488:	48 85 ff             	test   %rdi,%rdi
  40e48b:	74 05                	je     40e492 <_ZN6rocket6ServerC1Ejii+0x1a2>
  40e48d:	e8 1e 57 ff ff       	callq  403bb0 <_ZdlPv@plt>
  40e492:	48 89 ef             	mov    %rbp,%rdi
  40e495:	e8 06 5d ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40e49a:	49 89 c5             	mov    %rax,%r13
               const int work_threads_num/* = 1*/) 
    : port_(port)
    , listenfd_(0)
    , network_threads_num_(network_threads_num)
    , work_threads_num_(work_threads_num)
    , stop_(false) {
  40e49d:	4c 89 e7             	mov    %r12,%rdi
  40e4a0:	4d 89 ec             	mov    %r13,%r12
  40e4a3:	e8 58 d2 ff ff       	callq  40b700 <_ZN6rocket12EventWrapperD1Ev>
    }

    ~Mutex()
    {
        if (initialized_)
  40e4a8:	80 bb c0 00 00 00 00 	cmpb   $0x0,0xc0(%rbx)
  40e4af:	75 42                	jne    40e4f3 <_ZN6rocket6ServerC1Ejii+0x203>

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() _GLIBCXX_NOEXCEPT
    {
      if (this->_M_impl._M_map)
  40e4b1:	48 8b 7b 48          	mov    0x48(%rbx),%rdi
  40e4b5:	48 85 ff             	test   %rdi,%rdi
  40e4b8:	74 2f                	je     40e4e9 <_ZN6rocket6ServerC1Ejii+0x1f9>
	{
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
			   this->_M_impl._M_finish._M_node + 1);
  40e4ba:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
  40e4c1:	48 8b 6b 70          	mov    0x70(%rbx),%rbp
  40e4c5:	4c 8d 68 08          	lea    0x8(%rax),%r13
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
  40e4c9:	49 39 ed             	cmp    %rbp,%r13
  40e4cc:	76 16                	jbe    40e4e4 <_ZN6rocket6ServerC1Ejii+0x1f4>
  40e4ce:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
  40e4d2:	48 83 c5 08          	add    $0x8,%rbp
  40e4d6:	e8 d5 56 ff ff       	callq  403bb0 <_ZdlPv@plt>
  40e4db:	49 39 ed             	cmp    %rbp,%r13
  40e4de:	77 ee                	ja     40e4ce <_ZN6rocket6ServerC1Ejii+0x1de>
  40e4e0:	48 8b 7b 48          	mov    0x48(%rbx),%rdi
  40e4e4:	e8 c7 56 ff ff       	callq  403bb0 <_ZdlPv@plt>
  40e4e9:	4c 89 e5             	mov    %r12,%rbp
  40e4ec:	eb 88                	jmp    40e476 <_ZN6rocket6ServerC1Ejii+0x186>
  40e4ee:	49 89 c4             	mov    %rax,%r12
  40e4f1:	eb b5                	jmp    40e4a8 <_ZN6rocket6ServerC1Ejii+0x1b8>
        {
            initialized_ = false;
  40e4f3:	c6 83 c0 00 00 00 00 	movb   $0x0,0xc0(%rbx)
            int ret = pthread_mutex_destroy(&mutex_);
  40e4fa:	48 89 ef             	mov    %rbp,%rdi
  40e4fd:	e8 5e 5c ff ff       	callq  404160 <pthread_mutex_destroy@plt>
            //perror("pthread_mutex_destroy");
            assert(ret == 0);
  40e502:	85 c0                	test   %eax,%eax
  40e504:	74 ab                	je     40e4b1 <_ZN6rocket6ServerC1Ejii+0x1c1>
  40e506:	48 8d 0d 13 2a 00 00 	lea    0x2a13(%rip),%rcx        # 410f20 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__>
  40e50d:	48 8d 35 a4 25 00 00 	lea    0x25a4(%rip),%rsi        # 410ab8 <_ZTS10LoggerImpl+0xd>
  40e514:	48 8d 3d 70 23 00 00 	lea    0x2370(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40e51b:	ba 18 00 00 00       	mov    $0x18,%edx
  40e520:	e8 bb 56 ff ff       	callq  403be0 <__assert_fail@plt>
class Mutex {
public:
    Mutex()
    {
        int ret = pthread_mutex_init(&mutex_, NULL);
        assert(ret == 0);
  40e525:	48 8d 0d 14 2a 00 00 	lea    0x2a14(%rip),%rcx        # 410f40 <_ZZN6rocket5MutexC4EvE19__PRETTY_FUNCTION__>
  40e52c:	48 8d 35 85 25 00 00 	lea    0x2585(%rip),%rsi        # 410ab8 <_ZTS10LoggerImpl+0xd>
  40e533:	48 8d 3d 51 23 00 00 	lea    0x2351(%rip),%rdi        # 41088b <_ZTSN6rocket12EpollWrapperE+0x2ab>
  40e53a:	ba 0d 00 00 00       	mov    $0xd,%edx
  40e53f:	e8 9c 56 ff ff       	callq  403be0 <__assert_fail@plt>
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
	    *__cur = this->_M_allocate_node();
	}
      __catch(...)
  40e544:	48 89 c7             	mov    %rax,%rdi
  40e547:	e8 b4 5b ff ff       	callq  404100 <__cxa_begin_catch@plt>
	{
	  _M_destroy_nodes(__nstart, __cur);
	  __throw_exception_again;
  40e54c:	e8 cf 56 ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40e551:	48 89 c5             	mov    %rax,%rbp
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
	    *__cur = this->_M_allocate_node();
	}
      __catch(...)
  40e554:	e8 27 5b ff ff       	callq  404080 <__cxa_end_catch@plt>
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      __try
	{ _M_create_nodes(__nstart, __nfinish); }
      __catch(...)
  40e559:	48 89 ef             	mov    %rbp,%rdi
  40e55c:	e8 9f 5b ff ff       	callq  404100 <__cxa_begin_catch@plt>
  40e561:	48 8b 7b 48          	mov    0x48(%rbx),%rdi
  40e565:	e8 46 56 ff ff       	callq  403bb0 <_ZdlPv@plt>
	{
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
	  this->_M_impl._M_map = 0;
  40e56a:	48 c7 43 48 00 00 00 	movq   $0x0,0x48(%rbx)
  40e571:	00 
	  this->_M_impl._M_map_size = 0;
  40e572:	48 c7 43 50 00 00 00 	movq   $0x0,0x50(%rbx)
  40e579:	00 
	  __throw_exception_again;
  40e57a:	e8 a1 56 ff ff       	callq  403c20 <__cxa_rethrow@plt>
  40e57f:	48 89 c5             	mov    %rax,%rbp
			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      __try
	{ _M_create_nodes(__nstart, __nfinish); }
      __catch(...)
  40e582:	e8 f9 5a ff ff       	callq  404080 <__cxa_end_catch@plt>
  40e587:	e9 ea fe ff ff       	jmpq   40e476 <_ZN6rocket6ServerC1Ejii+0x186>
  40e58c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040e590 <_ZN6rocket6Server4stopEv>:
        thread->start();
        LOG_INFO("work thread start i=%d, tid=%d", i, thread->thread_id());
    }
}

void Server::stop() {
  40e590:	41 54                	push   %r12
  40e592:	55                   	push   %rbp
  40e593:	49 89 fc             	mov    %rdi,%r12
  40e596:	53                   	push   %rbx
      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
      : _M_current(__i) { }
  40e597:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
    for (auto it = network_threads_.begin(); it != network_threads_.end(); ++it) {
  40e59b:	48 3b 5f 18          	cmp    0x18(%rdi),%rbx
  40e59f:	74 4f                	je     40e5f0 <_ZN6rocket6Server4stopEv+0x60>
  40e5a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        delete *it;
  40e5a8:	48 8b 2b             	mov    (%rbx),%rbp
  40e5ab:	48 85 ed             	test   %rbp,%rbp
  40e5ae:	74 2e                	je     40e5de <_ZN6rocket6Server4stopEv+0x4e>
#include "event_dispatcher.h"

namespace rocket {


class ThreadBase
  40e5b0:	48 8b 05 01 59 20 00 	mov    0x205901(%rip),%rax        # 613eb8 <_DYNAMIC+0x230>
  40e5b7:	48 83 c0 10          	add    $0x10,%rax
  40e5bb:	48 89 45 00          	mov    %rax,0x0(%rbp)

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40e5bf:	48 8b 45 18          	mov    0x18(%rbp),%rax
  40e5c3:	48 85 c0             	test   %rax,%rax
  40e5c6:	74 0e                	je     40e5d6 <_ZN6rocket6Server4stopEv+0x46>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40e5c8:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
  40e5cc:	ba 03 00 00 00       	mov    $0x3,%edx
  40e5d1:	48 89 fe             	mov    %rdi,%rsi
  40e5d4:	ff d0                	callq  *%rax
  40e5d6:	48 89 ef             	mov    %rbp,%rdi
  40e5d9:	e8 d2 55 ff ff       	callq  403bb0 <_ZdlPv@plt>
        *it = NULL;
  40e5de:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
      { return _M_current; }

      __normal_iterator&
      operator++() _GLIBCXX_NOEXCEPT
      {
	++_M_current;
  40e5e5:	48 83 c3 08          	add    $0x8,%rbx
        LOG_INFO("work thread start i=%d, tid=%d", i, thread->thread_id());
    }
}

void Server::stop() {
    for (auto it = network_threads_.begin(); it != network_threads_.end(); ++it) {
  40e5e9:	49 39 5c 24 18       	cmp    %rbx,0x18(%r12)
  40e5ee:	75 b8                	jne    40e5a8 <_ZN6rocket6Server4stopEv+0x18>
      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
      : _M_current(__i) { }
  40e5f0:	49 8b 5c 24 28       	mov    0x28(%r12),%rbx
        delete *it;
        *it = NULL;
    }

    for (auto it = work_threads_.begin(); it != work_threads_.end(); ++it) {
  40e5f5:	49 3b 5c 24 30       	cmp    0x30(%r12),%rbx
  40e5fa:	74 4c                	je     40e648 <_ZN6rocket6Server4stopEv+0xb8>
  40e5fc:	0f 1f 40 00          	nopl   0x0(%rax)
        delete *it;
  40e600:	48 8b 2b             	mov    (%rbx),%rbp
  40e603:	48 85 ed             	test   %rbp,%rbp
  40e606:	74 2e                	je     40e636 <_ZN6rocket6Server4stopEv+0xa6>
  40e608:	48 8b 05 a9 58 20 00 	mov    0x2058a9(%rip),%rax        # 613eb8 <_DYNAMIC+0x230>
  40e60f:	48 83 c0 10          	add    $0x10,%rax
  40e613:	48 89 45 00          	mov    %rax,0x0(%rbp)

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40e617:	48 8b 45 18          	mov    0x18(%rbp),%rax
  40e61b:	48 85 c0             	test   %rax,%rax
  40e61e:	74 0e                	je     40e62e <_ZN6rocket6Server4stopEv+0x9e>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40e620:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
  40e624:	ba 03 00 00 00       	mov    $0x3,%edx
  40e629:	48 89 fe             	mov    %rdi,%rsi
  40e62c:	ff d0                	callq  *%rax
  40e62e:	48 89 ef             	mov    %rbp,%rdi
  40e631:	e8 7a 55 ff ff       	callq  403bb0 <_ZdlPv@plt>
        *it = NULL;
  40e636:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
      { return _M_current; }

      __normal_iterator&
      operator++() _GLIBCXX_NOEXCEPT
      {
	++_M_current;
  40e63d:	48 83 c3 08          	add    $0x8,%rbx
    for (auto it = network_threads_.begin(); it != network_threads_.end(); ++it) {
        delete *it;
        *it = NULL;
    }

    for (auto it = work_threads_.begin(); it != work_threads_.end(); ++it) {
  40e641:	49 39 5c 24 30       	cmp    %rbx,0x30(%r12)
  40e646:	75 b8                	jne    40e600 <_ZN6rocket6Server4stopEv+0x70>
        delete *it;
        *it = NULL;
    }
}
  40e648:	5b                   	pop    %rbx
  40e649:	5d                   	pop    %rbp
  40e64a:	41 5c                	pop    %r12
  40e64c:	c3                   	retq   
  40e64d:	90                   	nop
  40e64e:	66 90                	xchg   %ax,%ax

000000000040e650 <_ZN6rocket6Server13WriteCallbackEi>:
    delete c;
    c = NULL;
    */
}

void Server::WriteCallback(int fd) {
  40e650:	f3 c3                	repz retq 
  40e652:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40e659:	1f 84 00 00 00 00 00 

000000000040e660 <_ZN6rocket6Server12ReadCallbackEi>:
        LOG_DEBUG("WorkThreadFunc end, fd=%d read_buffer.size=%d", 
                  fd, read_buffer.size());
    }
}

void Server::ReadCallback(int fd) {
  40e660:	41 55                	push   %r13
  40e662:	41 54                	push   %r12
  40e664:	55                   	push   %rbp
  40e665:	53                   	push   %rbx
  40e666:	89 f5                	mov    %esi,%ebp
  40e668:	48 89 fb             	mov    %rdi,%rbx
  40e66b:	48 83 ec 28          	sub    $0x28,%rsp
    LOG_DEBUG("ReadCallback begin, fd=%d", fd);
  40e66f:	e8 bc d4 ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40e674:	4c 8b 10             	mov    (%rax),%r10
    Connection* c = new Connection(fd);
  40e677:	4c 8d 6c 24 10       	lea    0x10(%rsp),%r13
                  fd, read_buffer.size());
    }
}

void Server::ReadCallback(int fd) {
    LOG_DEBUG("ReadCallback begin, fd=%d", fd);
  40e67c:	48 89 c7             	mov    %rax,%rdi
  40e67f:	41 89 e9             	mov    %ebp,%r9d
  40e682:	4c 8d 05 46 27 00 00 	lea    0x2746(%rip),%r8        # 410dcf <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0xaf>
  40e689:	b9 76 00 00 00       	mov    $0x76,%ecx
  40e68e:	48 8d 15 b8 26 00 00 	lea    0x26b8(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40e695:	31 f6                	xor    %esi,%esi
  40e697:	31 c0                	xor    %eax,%eax
  40e699:	41 ff 52 20          	callq  *0x20(%r10)
    Connection* c = new Connection(fd);
  40e69d:	48 8d 54 24 0e       	lea    0xe(%rsp),%rdx
  40e6a2:	48 8d 35 7b 1d 00 00 	lea    0x1d7b(%rip),%rsi        # 410424 <_ZStL19piecewise_construct+0x8>
  40e6a9:	4c 89 ef             	mov    %r13,%rdi
  40e6ac:	e8 6f 57 ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
  40e6b1:	bf 20 00 00 00       	mov    $0x20,%edi
  40e6b6:	e8 c5 5a ff ff       	callq  404180 <_Znwm@plt>
  40e6bb:	45 31 c0             	xor    %r8d,%r8d
  40e6be:	31 c9                	xor    %ecx,%ecx
  40e6c0:	4c 89 ea             	mov    %r13,%rdx
  40e6c3:	89 ee                	mov    %ebp,%esi
  40e6c5:	48 89 c7             	mov    %rax,%rdi
  40e6c8:	49 89 c4             	mov    %rax,%r12
  40e6cb:	e8 00 c8 ff ff       	callq  40aed0 <_ZN6rocket10ConnectionC1EiRKSsij>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40e6d0:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40e6d5:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40e6d9:	48 3b 3d 80 58 20 00 	cmp    0x205880(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40e6e0:	0f 85 aa 00 00 00    	jne    40e790 <_ZN6rocket6Server12ReadCallbackEi+0x130>
  40e6e6:	4c 89 64 24 10       	mov    %r12,0x10(%rsp)

class Lock {
public:
    Lock(Mutex& mutex) 
        : mutex_(&mutex) { 
        if (mutex_ != NULL) {
  40e6eb:	49 89 dc             	mov    %rbx,%r12
  40e6ee:	49 81 c4 98 00 00 00 	add    $0x98,%r12
  40e6f5:	74 10                	je     40e707 <_ZN6rocket6Server12ReadCallbackEi+0xa7>
        }
    }

    void lock()
    {
        int ret = pthread_mutex_lock(&mutex_);
  40e6f7:	4c 89 e7             	mov    %r12,%rdi
  40e6fa:	e8 21 5a ff ff       	callq  404120 <pthread_mutex_lock@plt>
        assert(ret == 0);
  40e6ff:	85 c0                	test   %eax,%eax
  40e701:	0f 85 f2 00 00 00    	jne    40e7f9 <_ZN6rocket6Server12ReadCallbackEi+0x199>
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish._M_cur
	    != this->_M_impl._M_finish._M_last - 1)
  40e707:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
       *  done in constant time.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish._M_cur
  40e70e:	48 8b 43 78          	mov    0x78(%rbx),%rax
	    != this->_M_impl._M_finish._M_last - 1)
  40e712:	48 83 e9 08          	sub    $0x8,%rcx
       *  done in constant time.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish._M_cur
  40e716:	48 39 c8             	cmp    %rcx,%rax
  40e719:	0f 84 a1 00 00 00    	je     40e7c0 <_ZN6rocket6Server12ReadCallbackEi+0x160>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40e71f:	48 85 c0             	test   %rax,%rax
  40e722:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40e727:	74 07                	je     40e730 <_ZN6rocket6Server12ReadCallbackEi+0xd0>
  40e729:	48 89 10             	mov    %rdx,(%rax)
  40e72c:	48 8b 43 78          	mov    0x78(%rbx),%rax
	    != this->_M_impl._M_finish._M_last - 1)
	  {
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
	    ++this->_M_impl._M_finish._M_cur;
  40e730:	48 83 c0 08          	add    $0x8,%rax
  40e734:	48 89 43 78          	mov    %rax,0x78(%rbx)
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&mutex_);
  40e738:	4c 89 e7             	mov    %r12,%rdi
  40e73b:	e8 90 5a ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        //perror("pthread_mutex_unlock");
        assert(ret == 0);
  40e740:	85 c0                	test   %eax,%eax
  40e742:	0f 85 ac 00 00 00    	jne    40e7f4 <_ZN6rocket6Server12ReadCallbackEi+0x194>
    connection_que_.push_back(c);
    connection_que_ev_.Set();
  40e748:	48 8d bb c8 00 00 00 	lea    0xc8(%rbx),%rdi
  40e74f:	e8 bc cf ff ff       	callq  40b710 <_ZN6rocket12EventWrapper3SetEv>
    LOG_DEBUG("ReadCallback end, fd=%d", fd);
  40e754:	e8 d7 d3 ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40e759:	4c 8b 10             	mov    (%rax),%r10
  40e75c:	41 89 e9             	mov    %ebp,%r9d
  40e75f:	48 89 c7             	mov    %rax,%rdi
  40e762:	4c 8d 05 80 26 00 00 	lea    0x2680(%rip),%r8        # 410de9 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0xc9>
  40e769:	b9 7a 00 00 00       	mov    $0x7a,%ecx
  40e76e:	48 8d 15 d8 25 00 00 	lea    0x25d8(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40e775:	31 f6                	xor    %esi,%esi
  40e777:	31 c0                	xor    %eax,%eax
  40e779:	41 ff 52 20          	callq  *0x20(%r10)

    delete[] blob.data;
    delete c;
    c = NULL;
    */
}
  40e77d:	48 83 c4 28          	add    $0x28,%rsp
  40e781:	5b                   	pop    %rbx
  40e782:	5d                   	pop    %rbp
  40e783:	41 5c                	pop    %r12
  40e785:	41 5d                	pop    %r13
  40e787:	c3                   	retq   
  40e788:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40e78f:	00 
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
  40e790:	48 83 3d e0 57 20 00 	cmpq   $0x0,0x2057e0(%rip)        # 613f78 <_DYNAMIC+0x2f0>
  40e797:	00 
  40e798:	74 3e                	je     40e7d8 <_ZN6rocket6Server12ReadCallbackEi+0x178>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
  40e79a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40e79f:	f0 0f c1 50 f8       	lock xadd %edx,-0x8(%rax)
  40e7a4:	89 d0                	mov    %edx,%eax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
  40e7a6:	85 c0                	test   %eax,%eax
  40e7a8:	0f 8f 38 ff ff ff    	jg     40e6e6 <_ZN6rocket6Server12ReadCallbackEi+0x86>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
  40e7ae:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40e7b3:	e8 b8 55 ff ff       	callq  403d70 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
  40e7b8:	e9 29 ff ff ff       	jmpq   40e6e6 <_ZN6rocket6Server12ReadCallbackEi+0x86>
  40e7bd:	0f 1f 00             	nopl   (%rax)
        que_.push_front(c);
    }

    void push_back(Connection* c) {
        Lock Lock(mutex_);
        que_.push_back(c);
  40e7c0:	48 8d 7b 48          	lea    0x48(%rbx),%rdi
	  }
	else
	  _M_push_back_aux(__x);
  40e7c4:	4c 89 ee             	mov    %r13,%rsi
  40e7c7:	e8 b4 09 00 00       	callq  40f180 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_>
  40e7cc:	e9 67 ff ff ff       	jmpq   40e738 <_ZN6rocket6Server12ReadCallbackEi+0xd8>
  40e7d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
  40e7d8:	8b 50 f8             	mov    -0x8(%rax),%edx
    *__mem += __val;
  40e7db:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  40e7de:	89 48 f8             	mov    %ecx,-0x8(%rax)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  40e7e1:	89 d0                	mov    %edx,%eax
  40e7e3:	eb c1                	jmp    40e7a6 <_ZN6rocket6Server12ReadCallbackEi+0x146>
        assert(ret == 0);
    }

    void unlock()
    {
        int ret = pthread_mutex_unlock(&mutex_);
  40e7e5:	4c 89 e7             	mov    %r12,%rdi
  40e7e8:	48 89 c3             	mov    %rax,%rbx
  40e7eb:	e8 e0 59 ff ff       	callq  4041d0 <pthread_mutex_unlock@plt>
        //perror("pthread_mutex_unlock");
        assert(ret == 0);
  40e7f0:	85 c0                	test   %eax,%eax
  40e7f2:	74 31                	je     40e825 <_ZN6rocket6Server12ReadCallbackEi+0x1c5>
  40e7f4:	e8 d7 5b ff ff       	callq  4043d0 <_ZN6rocket5Mutex6unlockEv.part.7>
  40e7f9:	e8 b2 5b ff ff       	callq  4043b0 <_ZN6rocket5Mutex4lockEv.part.6>
    }
}

void Server::ReadCallback(int fd) {
    LOG_DEBUG("ReadCallback begin, fd=%d", fd);
    Connection* c = new Connection(fd);
  40e7fe:	4c 89 e7             	mov    %r12,%rdi
  40e801:	48 89 c3             	mov    %rax,%rbx
  40e804:	e8 a7 53 ff ff       	callq  403bb0 <_ZdlPv@plt>
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
  40e809:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40e80e:	48 8d 78 e8          	lea    -0x18(%rax),%rdi

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
  40e812:	48 3b 3d 47 57 20 00 	cmp    0x205747(%rip),%rdi        # 613f60 <_DYNAMIC+0x2d8>
  40e819:	74 0a                	je     40e825 <_ZN6rocket6Server12ReadCallbackEi+0x1c5>
  40e81b:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  40e820:	e8 63 5b ff ff       	callq  404388 <_ZNSs4_Rep10_M_disposeERKSaIcE.part.1>
  40e825:	48 89 df             	mov    %rbx,%rdi
  40e828:	e8 73 59 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40e82d:	48 89 c3             	mov    %rax,%rbx
  40e830:	eb d7                	jmp    40e809 <_ZN6rocket6Server12ReadCallbackEi+0x1a9>
  40e832:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40e839:	1f 84 00 00 00 00 00 

000000000040e840 <_ZN6rocket6Server3runEv>:
    int* p = new int[10];

	return ret;
}

void Server::run() {
  40e840:	41 57                	push   %r15
  40e842:	41 56                	push   %r14
  40e844:	41 55                	push   %r13
  40e846:	41 54                	push   %r12
  40e848:	55                   	push   %rbp
  40e849:	53                   	push   %rbx
  40e84a:	48 89 fb             	mov    %rdi,%rbx
  40e84d:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  40e854:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40e85b:	00 00 
  40e85d:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
  40e862:	31 c0                	xor    %eax,%eax
    LOG_INFO("Server::run()");
  40e864:	e8 c7 d2 ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40e869:	4c 8b 08             	mov    (%rax),%r9
  40e86c:	48 8d 15 da 24 00 00 	lea    0x24da(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40e873:	be 01 00 00 00       	mov    $0x1,%esi
  40e878:	48 89 c7             	mov    %rax,%rdi
  40e87b:	4c 8d 05 7f 25 00 00 	lea    0x257f(%rip),%r8        # 410e01 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0xe1>
  40e882:	b9 2f 00 00 00       	mov    $0x2f,%ecx
  40e887:	31 c0                	xor    %eax,%eax
  40e889:	41 ff 51 20          	callq  *0x20(%r9)
    // start network thread
    EventDispatcher* event_dispatcher = new EventDispatcher(this, listenfd_);
  40e88d:	bf 38 00 00 00       	mov    $0x38,%edi
  40e892:	e8 e9 58 ff ff       	callq  404180 <_Znwm@plt>
  40e897:	8b 53 0c             	mov    0xc(%rbx),%edx
  40e89a:	48 89 de             	mov    %rbx,%rsi
  40e89d:	48 89 c7             	mov    %rax,%rdi
  40e8a0:	49 89 c5             	mov    %rax,%r13
  40e8a3:	e8 68 cd ff ff       	callq  40b610 <_ZN6rocket15EventDispatcherC1EPNS_6ServerEi>
    //LOG_INFO("Server::run() 1");
    ThreadBase* thread = new NetworkThread(event_dispatcher);
  40e8a8:	bf 38 00 00 00       	mov    $0x38,%edi
  40e8ad:	e8 ce 58 ff ff       	callq  404180 <_Znwm@plt>
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
  40e8b2:	bf 18 00 00 00       	mov    $0x18,%edi
  40e8b7:	48 89 c5             	mov    %rax,%rbp
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(0) { }
  40e8ba:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  40e8c1:	00 00 
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
  40e8c3:	e8 b8 58 ff ff       	callq  404180 <_Znwm@plt>
	{ }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
  40e8c8:	48 8b 15 c9 56 20 00 	mov    0x2056c9(%rip),%rdx        # 613f98 <_DYNAMIC+0x310>
  40e8cf:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  40e8d6:	00 
{
public:
	typedef std::function<void()> ThreadCallback;

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }
  40e8d7:	4c 8d 64 24 50       	lea    0x50(%rsp),%r12
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
  40e8dc:	4c 89 68 10          	mov    %r13,0x10(%rax)
  40e8e0:	4c 8b 35 d1 55 20 00 	mov    0x2055d1(%rip),%r14        # 613eb8 <_DYNAMIC+0x230>
  40e8e7:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
  40e8eb:	4c 89 e6             	mov    %r12,%rsi
  40e8ee:	48 89 10             	mov    %rdx,(%rax)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
  40e8f1:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
  40e8f6:	48 8b 05 1b 56 20 00 	mov    0x20561b(%rip),%rax        # 613f18 <_DYNAMIC+0x290>
  40e8fd:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
	    _M_manager = &_My_handler::_M_manager;
  40e902:	48 8b 05 2f 56 20 00 	mov    0x20562f(%rip),%rax        # 613f38 <_DYNAMIC+0x2b0>
  40e909:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  40e90e:	49 8d 46 10          	lea    0x10(%r14),%rax
  40e912:	48 89 45 00          	mov    %rax,0x0(%rbp)
  40e916:	e8 35 06 00 00       	callq  40ef50 <_ZNSt8functionIFvvEEC1ERKS1_>

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40e91b:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  40e920:	48 c7 45 28 00 00 00 	movq   $0x0,0x28(%rbp)
  40e927:	00 
  40e928:	48 85 c0             	test   %rax,%rax
  40e92b:	74 0d                	je     40e93a <_ZN6rocket6Server3runEv+0xfa>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40e92d:	ba 03 00 00 00       	mov    $0x3,%edx
  40e932:	4c 89 e6             	mov    %r12,%rsi
  40e935:	4c 89 e7             	mov    %r12,%rdi
  40e938:	ff d0                	callq  *%rax
{
public:
	NetworkThread(/*ThreadCallback cb,*/ 
			      EventDispatcher* ev_dispatcher) 
		: ThreadBase(std::bind(&EventDispatcher::loop, ev_dispatcher))
		, ev_dispatcher_(ev_dispatcher) {
  40e93a:	48 8b 05 b7 55 20 00 	mov    0x2055b7(%rip),%rax        # 613ef8 <_DYNAMIC+0x270>
  40e941:	4c 89 6d 30          	mov    %r13,0x30(%rbp)
  40e945:	48 83 c0 10          	add    $0x10,%rax
  40e949:	48 89 45 00          	mov    %rax,0x0(%rbp)
       *  available.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  40e94d:	48 8b 43 18          	mov    0x18(%rbx),%rax
  40e951:	48 3b 43 20          	cmp    0x20(%rbx),%rax
  40e955:	48 89 6c 24 20       	mov    %rbp,0x20(%rsp)
  40e95a:	0f 84 89 03 00 00    	je     40ece9 <_ZN6rocket6Server3runEv+0x4a9>
  40e960:	48 85 c0             	test   %rax,%rax
  40e963:	74 08                	je     40e96d <_ZN6rocket6Server3runEv+0x12d>
  40e965:	48 89 28             	mov    %rbp,(%rax)
  40e968:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
	                             __x);
	    ++this->_M_impl._M_finish;
  40e96d:	48 83 43 18 08       	addq   $0x8,0x18(%rbx)
	typedef std::function<void()> ThreadCallback;

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }

	bool start() {	
		int ret = pthread_create(&pthread_id_, NULL, TheThread, this);
  40e972:	48 8b 15 b7 55 20 00 	mov    0x2055b7(%rip),%rdx        # 613f30 <_DYNAMIC+0x2a8>
  40e979:	48 8d 7d 28          	lea    0x28(%rbp),%rdi
  40e97d:	48 89 e9             	mov    %rbp,%rcx
  40e980:	31 f6                	xor    %esi,%esi
  40e982:	e8 f9 53 ff ff       	callq  403d80 <pthread_create@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40e987:	48 8b 3d 92 55 20 00 	mov    0x205592(%rip),%rdi        # 613f20 <_DYNAMIC+0x298>
  40e98e:	48 8d 35 7a 24 00 00 	lea    0x247a(%rip),%rsi        # 410e0f <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0xef>
  40e995:	ba 16 00 00 00       	mov    $0x16,%edx
  40e99a:	41 89 c5             	mov    %eax,%r13d
		std::cout << "ThreadBase start, ret=" << ret 
				  << " tid=" << pthread_id_
  40e99d:	48 8b 6d 28          	mov    0x28(%rbp),%rbp
  40e9a1:	e8 fa 54 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }

	bool start() {	
		int ret = pthread_create(&pthread_id_, NULL, TheThread, this);
		std::cout << "ThreadBase start, ret=" << ret 
  40e9a6:	48 8b 3d 73 55 20 00 	mov    0x205573(%rip),%rdi        # 613f20 <_DYNAMIC+0x298>
  40e9ad:	44 89 ee             	mov    %r13d,%esi
  40e9b0:	e8 eb 50 ff ff       	callq  403aa0 <_ZNSolsEi@plt>
  40e9b5:	48 8d 35 6a 24 00 00 	lea    0x246a(%rip),%rsi        # 410e26 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x106>
  40e9bc:	49 89 c5             	mov    %rax,%r13
  40e9bf:	ba 05 00 00 00       	mov    $0x5,%edx
  40e9c4:	48 89 c7             	mov    %rax,%rdi
  40e9c7:	e8 d4 54 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }
  40e9cc:	48 89 ee             	mov    %rbp,%rsi
  40e9cf:	4c 89 ef             	mov    %r13,%rdi
  40e9d2:	e8 79 56 ff ff       	callq  404050 <_ZNSo9_M_insertImEERSoT_@plt>
  40e9d7:	49 89 c5             	mov    %rax,%r13
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40e9da:	48 8b 00             	mov    (%rax),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40e9dd:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40e9e1:	49 8b ac 05 f0 00 00 	mov    0xf0(%r13,%rax,1),%rbp
  40e9e8:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40e9e9:	48 85 ed             	test   %rbp,%rbp
  40e9ec:	0f 84 0f 03 00 00    	je     40ed01 <_ZN6rocket6Server3runEv+0x4c1>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40e9f2:	80 7d 38 00          	cmpb   $0x0,0x38(%rbp)
  40e9f6:	0f 84 be 02 00 00    	je     40ecba <_ZN6rocket6Server3runEv+0x47a>
  40e9fc:	0f be 75 43          	movsbl 0x43(%rbp),%esi
  40ea00:	4c 89 ef             	mov    %r13,%rdi
    thread->start();
    LOG_INFO("network thread start, tid=%d", thread->thread_id());


    // start work thread
    for (int i = 0; i < work_threads_num_; ++i) {
  40ea03:	31 ed                	xor    %ebp,%ebp
  40ea05:	e8 d6 57 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40ea0a:	48 89 c7             	mov    %rax,%rdi
  40ea0d:	e8 1e 55 ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
    EventDispatcher* event_dispatcher = new EventDispatcher(this, listenfd_);
    //LOG_INFO("Server::run() 1");
    ThreadBase* thread = new NetworkThread(event_dispatcher);
    network_threads_.push_back(thread);
    thread->start();
    LOG_INFO("network thread start, tid=%d", thread->thread_id());
  40ea12:	e8 19 d1 ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40ea17:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  40ea1c:	4c 8b 10             	mov    (%rax),%r10
  40ea1f:	b9 36 00 00 00       	mov    $0x36,%ecx
  40ea24:	48 89 c7             	mov    %rax,%rdi
  40ea27:	4c 8d 05 fe 23 00 00 	lea    0x23fe(%rip),%r8        # 410e2c <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x10c>
  40ea2e:	31 c0                	xor    %eax,%eax
  40ea30:	be 01 00 00 00       	mov    $0x1,%esi
  40ea35:	4c 8b 4a 28          	mov    0x28(%rdx),%r9
  40ea39:	48 8d 15 0d 23 00 00 	lea    0x230d(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40ea40:	41 ff 52 20          	callq  *0x20(%r10)


    // start work thread
    for (int i = 0; i < work_threads_num_; ++i) {
  40ea44:	8b 4b 04             	mov    0x4(%rbx),%ecx
  40ea47:	85 c9                	test   %ecx,%ecx
  40ea49:	0f 8e 49 02 00 00    	jle    40ec98 <_ZN6rocket6Server3runEv+0x458>
class ThreadBase
{
public:
	typedef std::function<void()> ThreadCallback;

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }
  40ea4f:	49 8d 46 10          	lea    0x10(%r14),%rax
// handle business data
class WorkThread : public ThreadBase
{
public:
	WorkThread(ThreadCallback cb) 
		: ThreadBase(cb)
  40ea53:	4c 8d 6c 24 30       	lea    0x30(%rsp),%r13
class ThreadBase
{
public:
	typedef std::function<void()> ThreadCallback;

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }
  40ea58:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	  }
	else
#if __cplusplus >= 201103L
	  _M_emplace_back_aux(__x);
  40ea5d:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
  40ea62:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
        ThreadBase* thread = new WorkThread(std::bind(&Server::WorkThreadFunc, this));
        work_threads_.push_back(thread);
  40ea67:	48 8d 43 28          	lea    0x28(%rbx),%rax
  40ea6b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40ea70:	eb 61                	jmp    40ead3 <_ZN6rocket6Server3runEv+0x293>
  40ea72:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40ea78:	41 0f be 76 43       	movsbl 0x43(%r14),%esi
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40ea7d:	4c 89 ff             	mov    %r15,%rdi
  40ea80:	e8 5b 57 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40ea85:	48 89 c7             	mov    %rax,%rdi
  40ea88:	e8 a3 54 ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
        thread->start();
        LOG_INFO("work thread start i=%d, tid=%d", i, thread->thread_id());
  40ea8d:	e8 9e d0 ff ff       	callq  40bb30 <_ZN6Logger9getLoggerEv>
  40ea92:	48 83 ec 08          	sub    $0x8,%rsp
  40ea96:	4c 8b 10             	mov    (%rax),%r10
  40ea99:	41 89 e9             	mov    %ebp,%r9d
  40ea9c:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  40eaa1:	48 89 c7             	mov    %rax,%rdi
  40eaa4:	4c 8d 05 15 24 00 00 	lea    0x2415(%rip),%r8        # 410ec0 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x1a0>
  40eaab:	31 c0                	xor    %eax,%eax
  40eaad:	b9 3e 00 00 00       	mov    $0x3e,%ecx
  40eab2:	be 01 00 00 00       	mov    $0x1,%esi
    thread->start();
    LOG_INFO("network thread start, tid=%d", thread->thread_id());


    // start work thread
    for (int i = 0; i < work_threads_num_; ++i) {
  40eab7:	83 c5 01             	add    $0x1,%ebp
        ThreadBase* thread = new WorkThread(std::bind(&Server::WorkThreadFunc, this));
        work_threads_.push_back(thread);
        thread->start();
        LOG_INFO("work thread start i=%d, tid=%d", i, thread->thread_id());
  40eaba:	ff 72 28             	pushq  0x28(%rdx)
  40eabd:	48 8d 15 89 22 00 00 	lea    0x2289(%rip),%rdx        # 410d4d <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x2d>
  40eac4:	41 ff 52 20          	callq  *0x20(%r10)
    thread->start();
    LOG_INFO("network thread start, tid=%d", thread->thread_id());


    // start work thread
    for (int i = 0; i < work_threads_num_; ++i) {
  40eac8:	39 6b 04             	cmp    %ebp,0x4(%rbx)
  40eacb:	58                   	pop    %rax
  40eacc:	5a                   	pop    %rdx
  40eacd:	0f 8e c5 01 00 00    	jle    40ec98 <_ZN6rocket6Server3runEv+0x458>
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
  40ead3:	bf 18 00 00 00       	mov    $0x18,%edi
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(0) { }
  40ead8:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  40eadf:	00 00 
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
  40eae1:	e8 9a 56 ff ff       	callq  404180 <_Znwm@plt>
	{ }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
  40eae6:	48 8b 15 b3 54 20 00 	mov    0x2054b3(%rip),%rdx        # 613fa0 <_DYNAMIC+0x318>
  40eaed:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  40eaf4:	00 
        ThreadBase* thread = new WorkThread(std::bind(&Server::WorkThreadFunc, this));
  40eaf5:	bf 30 00 00 00       	mov    $0x30,%edi
  40eafa:	48 89 58 10          	mov    %rbx,0x10(%rax)
  40eafe:	48 89 10             	mov    %rdx,(%rax)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
  40eb01:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
  40eb06:	48 8b 05 e3 53 20 00 	mov    0x2053e3(%rip),%rax        # 613ef0 <_DYNAMIC+0x268>
  40eb0d:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
	    _M_manager = &_My_handler::_M_manager;
  40eb12:	48 8b 05 c7 53 20 00 	mov    0x2053c7(%rip),%rax        # 613ee0 <_DYNAMIC+0x258>
  40eb19:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  40eb1e:	e8 5d 56 ff ff       	callq  404180 <_Znwm@plt>
// handle business data
class WorkThread : public ThreadBase
{
public:
	WorkThread(ThreadCallback cb) 
		: ThreadBase(cb)
  40eb23:	4c 89 ee             	mov    %r13,%rsi
  40eb26:	4c 89 e7             	mov    %r12,%rdi
  40eb29:	49 89 c6             	mov    %rax,%r14
  40eb2c:	e8 1f 04 00 00       	callq  40ef50 <_ZNSt8functionIFvvEEC1ERKS1_>
class ThreadBase
{
public:
	typedef std::function<void()> ThreadCallback;

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }
  40eb31:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40eb36:	49 8d 7e 08          	lea    0x8(%r14),%rdi
  40eb3a:	4c 89 e6             	mov    %r12,%rsi
  40eb3d:	49 89 06             	mov    %rax,(%r14)
  40eb40:	e8 0b 04 00 00       	callq  40ef50 <_ZNSt8functionIFvvEEC1ERKS1_>

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40eb45:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  40eb4a:	49 c7 46 28 00 00 00 	movq   $0x0,0x28(%r14)
  40eb51:	00 
  40eb52:	48 85 c0             	test   %rax,%rax
  40eb55:	74 0d                	je     40eb64 <_ZN6rocket6Server3runEv+0x324>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40eb57:	ba 03 00 00 00       	mov    $0x3,%edx
  40eb5c:	4c 89 e6             	mov    %r12,%rsi
  40eb5f:	4c 89 e7             	mov    %r12,%rdi
  40eb62:	ff d0                	callq  *%rax
// handle business data
class WorkThread : public ThreadBase
{
public:
	WorkThread(ThreadCallback cb) 
		: ThreadBase(cb)
  40eb64:	48 8b 05 65 53 20 00 	mov    0x205365(%rip),%rax        # 613ed0 <_DYNAMIC+0x248>
  40eb6b:	48 83 c0 10          	add    $0x10,%rax
  40eb6f:	49 89 06             	mov    %rax,(%r14)

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40eb72:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  40eb77:	4c 89 74 24 28       	mov    %r14,0x28(%rsp)
  40eb7c:	48 85 c0             	test   %rax,%rax
  40eb7f:	74 0d                	je     40eb8e <_ZN6rocket6Server3runEv+0x34e>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40eb81:	ba 03 00 00 00       	mov    $0x3,%edx
  40eb86:	4c 89 ee             	mov    %r13,%rsi
  40eb89:	4c 89 ef             	mov    %r13,%rdi
  40eb8c:	ff d0                	callq  *%rax
       *  available.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  40eb8e:	48 8b 43 30          	mov    0x30(%rbx),%rax
  40eb92:	48 3b 43 38          	cmp    0x38(%rbx),%rax
  40eb96:	0f 84 dc 00 00 00    	je     40ec78 <_ZN6rocket6Server3runEv+0x438>
  40eb9c:	48 85 c0             	test   %rax,%rax
  40eb9f:	4c 8b 74 24 28       	mov    0x28(%rsp),%r14
  40eba4:	74 0c                	je     40ebb2 <_ZN6rocket6Server3runEv+0x372>
  40eba6:	4c 89 30             	mov    %r14,(%rax)
  40eba9:	48 8b 43 30          	mov    0x30(%rbx),%rax
  40ebad:	4c 8b 74 24 28       	mov    0x28(%rsp),%r14
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
	                             __x);
	    ++this->_M_impl._M_finish;
  40ebb2:	48 83 c0 08          	add    $0x8,%rax
  40ebb6:	48 89 43 30          	mov    %rax,0x30(%rbx)
	typedef std::function<void()> ThreadCallback;

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }

	bool start() {	
		int ret = pthread_create(&pthread_id_, NULL, TheThread, this);
  40ebba:	48 8b 15 6f 53 20 00 	mov    0x20536f(%rip),%rdx        # 613f30 <_DYNAMIC+0x2a8>
  40ebc1:	49 8d 7e 28          	lea    0x28(%r14),%rdi
  40ebc5:	4c 89 f1             	mov    %r14,%rcx
  40ebc8:	31 f6                	xor    %esi,%esi
  40ebca:	e8 b1 51 ff ff       	callq  403d80 <pthread_create@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40ebcf:	48 8b 3d 4a 53 20 00 	mov    0x20534a(%rip),%rdi        # 613f20 <_DYNAMIC+0x298>
  40ebd6:	48 8d 35 32 22 00 00 	lea    0x2232(%rip),%rsi        # 410e0f <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0xef>
  40ebdd:	ba 16 00 00 00       	mov    $0x16,%edx
  40ebe2:	41 89 c7             	mov    %eax,%r15d
		std::cout << "ThreadBase start, ret=" << ret 
				  << " tid=" << pthread_id_
  40ebe5:	4d 8b 76 28          	mov    0x28(%r14),%r14
  40ebe9:	e8 b2 52 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>

	ThreadBase(ThreadCallback cb) : cb_(cb), pthread_id_(0) { }

	bool start() {	
		int ret = pthread_create(&pthread_id_, NULL, TheThread, this);
		std::cout << "ThreadBase start, ret=" << ret 
  40ebee:	48 8b 3d 2b 53 20 00 	mov    0x20532b(%rip),%rdi        # 613f20 <_DYNAMIC+0x298>
  40ebf5:	44 89 fe             	mov    %r15d,%esi
  40ebf8:	e8 a3 4e ff ff       	callq  403aa0 <_ZNSolsEi@plt>
  40ebfd:	48 8d 35 22 22 00 00 	lea    0x2222(%rip),%rsi        # 410e26 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x106>
  40ec04:	49 89 c7             	mov    %rax,%r15
  40ec07:	ba 05 00 00 00       	mov    $0x5,%edx
  40ec0c:	48 89 c7             	mov    %rax,%rdi
  40ec0f:	e8 8c 52 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }
  40ec14:	4c 89 f6             	mov    %r14,%rsi
  40ec17:	4c 89 ff             	mov    %r15,%rdi
  40ec1a:	e8 31 54 ff ff       	callq  404050 <_ZNSo9_M_insertImEERSoT_@plt>
  40ec1f:	49 89 c7             	mov    %rax,%r15
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40ec22:	48 8b 00             	mov    (%rax),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40ec25:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40ec29:	4d 8b b4 07 f0 00 00 	mov    0xf0(%r15,%rax,1),%r14
  40ec30:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40ec31:	4d 85 f6             	test   %r14,%r14
  40ec34:	0f 84 c7 00 00 00    	je     40ed01 <_ZN6rocket6Server3runEv+0x4c1>
  40ec3a:	41 80 7e 38 00       	cmpb   $0x0,0x38(%r14)
  40ec3f:	0f 85 33 fe ff ff    	jne    40ea78 <_ZN6rocket6Server3runEv+0x238>
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40ec45:	4c 89 f7             	mov    %r14,%rdi
  40ec48:	e8 a3 4f ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40ec4d:	49 8b 06             	mov    (%r14),%rax
  40ec50:	be 0a 00 00 00       	mov    $0xa,%esi
  40ec55:	48 8b 40 30          	mov    0x30(%rax),%rax
  40ec59:	48 3b 05 30 53 20 00 	cmp    0x205330(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40ec60:	0f 84 17 fe ff ff    	je     40ea7d <_ZN6rocket6Server3runEv+0x23d>
  40ec66:	4c 89 f7             	mov    %r14,%rdi
  40ec69:	ff d0                	callq  *%rax
  40ec6b:	0f be f0             	movsbl %al,%esi
  40ec6e:	e9 0a fe ff ff       	jmpq   40ea7d <_ZN6rocket6Server3runEv+0x23d>
  40ec73:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	  }
	else
#if __cplusplus >= 201103L
	  _M_emplace_back_aux(__x);
  40ec78:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40ec7d:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40ec82:	e8 d9 06 00 00       	callq  40f360 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_>
  40ec87:	4c 8b 74 24 28       	mov    0x28(%rsp),%r14
  40ec8c:	e9 29 ff ff ff       	jmpq   40ebba <_ZN6rocket6Server3runEv+0x37a>
  40ec91:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        work_threads_.push_back(thread);
        thread->start();
        LOG_INFO("work thread start i=%d, tid=%d", i, thread->thread_id());
    }
}
  40ec98:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
  40ec9d:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40eca4:	00 00 
  40eca6:	75 71                	jne    40ed19 <_ZN6rocket6Server3runEv+0x4d9>
  40eca8:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  40ecaf:	5b                   	pop    %rbx
  40ecb0:	5d                   	pop    %rbp
  40ecb1:	41 5c                	pop    %r12
  40ecb3:	41 5d                	pop    %r13
  40ecb5:	41 5e                	pop    %r14
  40ecb7:	41 5f                	pop    %r15
  40ecb9:	c3                   	retq   
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40ecba:	48 89 ef             	mov    %rbp,%rdi
  40ecbd:	e8 2e 4f ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40ecc2:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40ecc6:	be 0a 00 00 00       	mov    $0xa,%esi
  40eccb:	48 8b 40 30          	mov    0x30(%rax),%rax
  40eccf:	48 3b 05 ba 52 20 00 	cmp    0x2052ba(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40ecd6:	0f 84 24 fd ff ff    	je     40ea00 <_ZN6rocket6Server3runEv+0x1c0>
  40ecdc:	48 89 ef             	mov    %rbp,%rdi
  40ecdf:	ff d0                	callq  *%rax
  40ece1:	0f be f0             	movsbl %al,%esi
  40ece4:	e9 17 fd ff ff       	jmpq   40ea00 <_ZN6rocket6Server3runEv+0x1c0>
  40ece9:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
    LOG_INFO("Server::run()");
    // start network thread
    EventDispatcher* event_dispatcher = new EventDispatcher(this, listenfd_);
    //LOG_INFO("Server::run() 1");
    ThreadBase* thread = new NetworkThread(event_dispatcher);
    network_threads_.push_back(thread);
  40ecee:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
  40ecf2:	e8 69 06 00 00       	callq  40f360 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_>
  40ecf7:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
  40ecfc:	e9 71 fc ff ff       	jmpq   40e972 <_ZN6rocket6Server3runEv+0x132>
	__throw_bad_cast();
  40ed01:	e8 da 4d ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
}

void Server::run() {
    LOG_INFO("Server::run()");
    // start network thread
    EventDispatcher* event_dispatcher = new EventDispatcher(this, listenfd_);
  40ed06:	4c 89 ef             	mov    %r13,%rdi
  40ed09:	48 89 c3             	mov    %rax,%rbx
  40ed0c:	e8 9f 4e ff ff       	callq  403bb0 <_ZdlPv@plt>
  40ed11:	48 89 df             	mov    %rbx,%rdi
  40ed14:	e8 87 54 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
        ThreadBase* thread = new WorkThread(std::bind(&Server::WorkThreadFunc, this));
        work_threads_.push_back(thread);
        thread->start();
        LOG_INFO("work thread start i=%d, tid=%d", i, thread->thread_id());
    }
}
  40ed19:	e8 32 52 ff ff       	callq  403f50 <__stack_chk_fail@plt>
  40ed1e:	48 89 c3             	mov    %rax,%rbx

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40ed21:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  40ed26:	48 85 c0             	test   %rax,%rax
  40ed29:	74 0d                	je     40ed38 <_ZN6rocket6Server3runEv+0x4f8>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40ed2b:	ba 03 00 00 00       	mov    $0x3,%edx
  40ed30:	4c 89 e6             	mov    %r12,%rsi
  40ed33:	4c 89 e7             	mov    %r12,%rdi
  40ed36:	ff d0                	callq  *%rax
    LOG_INFO("network thread start, tid=%d", thread->thread_id());


    // start work thread
    for (int i = 0; i < work_threads_num_; ++i) {
        ThreadBase* thread = new WorkThread(std::bind(&Server::WorkThreadFunc, this));
  40ed38:	4c 89 f7             	mov    %r14,%rdi
  40ed3b:	e8 70 4e ff ff       	callq  403bb0 <_ZdlPv@plt>

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40ed40:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  40ed45:	48 85 c0             	test   %rax,%rax
  40ed48:	74 c7                	je     40ed11 <_ZN6rocket6Server3runEv+0x4d1>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40ed4a:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  40ed4f:	ba 03 00 00 00       	mov    $0x3,%edx
  40ed54:	48 89 fe             	mov    %rdi,%rsi
  40ed57:	ff d0                	callq  *%rax
  40ed59:	eb b6                	jmp    40ed11 <_ZN6rocket6Server3runEv+0x4d1>
  40ed5b:	48 89 c3             	mov    %rax,%rbx
  40ed5e:	eb d8                	jmp    40ed38 <_ZN6rocket6Server3runEv+0x4f8>
  40ed60:	48 89 c3             	mov    %rax,%rbx

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40ed63:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  40ed68:	48 85 c0             	test   %rax,%rax
  40ed6b:	74 0d                	je     40ed7a <_ZN6rocket6Server3runEv+0x53a>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40ed6d:	ba 03 00 00 00       	mov    $0x3,%edx
  40ed72:	4c 89 e6             	mov    %r12,%rsi
  40ed75:	4c 89 e7             	mov    %r12,%rdi
  40ed78:	ff d0                	callq  *%rax
void Server::run() {
    LOG_INFO("Server::run()");
    // start network thread
    EventDispatcher* event_dispatcher = new EventDispatcher(this, listenfd_);
    //LOG_INFO("Server::run() 1");
    ThreadBase* thread = new NetworkThread(event_dispatcher);
  40ed7a:	48 89 ef             	mov    %rbp,%rdi
  40ed7d:	e8 2e 4e ff ff       	callq  403bb0 <_ZdlPv@plt>
  40ed82:	48 89 df             	mov    %rbx,%rdi
  40ed85:	e8 16 54 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40ed8a:	48 89 c3             	mov    %rax,%rbx

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40ed8d:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
  40ed92:	48 85 c0             	test   %rax,%rax
  40ed95:	74 e3                	je     40ed7a <_ZN6rocket6Server3runEv+0x53a>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40ed97:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  40ed9c:	ba 03 00 00 00       	mov    $0x3,%edx
  40eda1:	48 89 fe             	mov    %rdi,%rsi
  40eda4:	ff d0                	callq  *%rax
  40eda6:	eb d2                	jmp    40ed7a <_ZN6rocket6Server3runEv+0x53a>
  40eda8:	48 89 c3             	mov    %rax,%rbx
  40edab:	eb 93                	jmp    40ed40 <_ZN6rocket6Server3runEv+0x500>

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40edad:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
  40edb2:	48 89 c3             	mov    %rax,%rbx
  40edb5:	48 85 c9             	test   %rcx,%rcx
  40edb8:	0f 84 53 ff ff ff    	je     40ed11 <_ZN6rocket6Server3runEv+0x4d1>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40edbe:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  40edc3:	ba 03 00 00 00       	mov    $0x3,%edx
  40edc8:	48 89 fe             	mov    %rdi,%rsi
  40edcb:	ff d1                	callq  *%rcx
  40edcd:	e9 3f ff ff ff       	jmpq   40ed11 <_ZN6rocket6Server3runEv+0x4d1>
  40edd2:	90                   	nop
  40edd3:	90                   	nop
  40edd4:	90                   	nop
  40edd5:	90                   	nop
  40edd6:	90                   	nop
  40edd7:	90                   	nop
  40edd8:	90                   	nop
  40edd9:	90                   	nop
  40edda:	90                   	nop
  40eddb:	90                   	nop
  40eddc:	90                   	nop
  40eddd:	90                   	nop
  40edde:	90                   	nop
  40eddf:	90                   	nop

000000000040ede0 <_ZN6rocket10ThreadBase9TheThreadEPv>:

protected:
	ThreadCallback cb_;

private:
	static void *TheThread(void *param) {
  40ede0:	48 83 ec 08          	sub    $0x8,%rsp
		//pthread_detach(pthread_self());
		//pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
		//pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);
	
		((ThreadBase*)param)->run();
  40ede4:	48 8b 07             	mov    (%rdi),%rax
  40ede7:	ff 10                	callq  *(%rax)

		return NULL;
	}
  40ede9:	31 c0                	xor    %eax,%eax
  40edeb:	48 83 c4 08          	add    $0x8,%rsp
  40edef:	c3                   	retq   

000000000040edf0 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
  40edf0:	83 fa 01             	cmp    $0x1,%edx
  40edf3:	74 73                	je     40ee68 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x78>
  40edf5:	7e 59                	jle    40ee50 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x60>
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
  40edf7:	55                   	push   %rbp
  40edf8:	53                   	push   %rbx
  40edf9:	48 89 fb             	mov    %rdi,%rbx
  40edfc:	48 83 ec 08          	sub    $0x8,%rsp
		   _Manager_operation __op)
	{
	  switch (__op)
  40ee00:	83 fa 02             	cmp    $0x2,%edx
  40ee03:	74 1b                	je     40ee20 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x30>
  40ee05:	83 fa 03             	cmp    $0x3,%edx
  40ee08:	75 08                	jne    40ee12 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x22>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
  40ee0a:	48 8b 3f             	mov    (%rdi),%rdi
  40ee0d:	e8 9e 4d ff ff       	callq  403bb0 <_ZdlPv@plt>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40ee12:	48 83 c4 08          	add    $0x8,%rsp
  40ee16:	31 c0                	xor    %eax,%eax
  40ee18:	5b                   	pop    %rbx
  40ee19:	5d                   	pop    %rbp
  40ee1a:	c3                   	retq   
  40ee1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
  40ee20:	48 8b 2e             	mov    (%rsi),%rbp
  40ee23:	bf 18 00 00 00       	mov    $0x18,%edi
  40ee28:	e8 53 53 ff ff       	callq  404180 <_Znwm@plt>
  40ee2d:	48 8b 55 00          	mov    0x0(%rbp),%rdx
  40ee31:	48 89 10             	mov    %rdx,(%rax)
  40ee34:	48 8b 55 08          	mov    0x8(%rbp),%rdx
  40ee38:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40ee3c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  40ee40:	48 89 50 10          	mov    %rdx,0x10(%rax)
  40ee44:	48 89 03             	mov    %rax,(%rbx)
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40ee47:	48 83 c4 08          	add    $0x8,%rsp
  40ee4b:	31 c0                	xor    %eax,%eax
  40ee4d:	5b                   	pop    %rbx
  40ee4e:	5d                   	pop    %rbp
  40ee4f:	c3                   	retq   
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
  40ee50:	85 d2                	test   %edx,%edx
  40ee52:	75 0a                	jne    40ee5e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x6e>
	    {
#ifdef __GXX_RTTI
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
  40ee54:	48 8b 05 3d 50 20 00 	mov    0x20503d(%rip),%rax        # 613e98 <_DYNAMIC+0x210>
  40ee5b:	48 89 07             	mov    %rax,(%rdi)
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40ee5e:	31 c0                	xor    %eax,%eax
  40ee60:	c3                   	retq   
  40ee61:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
  40ee68:	48 8b 06             	mov    (%rsi),%rax
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
  40ee6b:	48 89 07             	mov    %rax,(%rdi)
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40ee6e:	31 c0                	xor    %eax,%eax
  40ee70:	c3                   	retq   
  40ee71:	90                   	nop
  40ee72:	90                   	nop
  40ee73:	90                   	nop
  40ee74:	90                   	nop
  40ee75:	90                   	nop
  40ee76:	90                   	nop
  40ee77:	90                   	nop
  40ee78:	90                   	nop
  40ee79:	90                   	nop
  40ee7a:	90                   	nop
  40ee7b:	90                   	nop
  40ee7c:	90                   	nop
  40ee7d:	90                   	nop
  40ee7e:	90                   	nop
  40ee7f:	90                   	nop

000000000040ee80 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
  40ee80:	83 fa 01             	cmp    $0x1,%edx
  40ee83:	74 73                	je     40eef8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x78>
  40ee85:	7e 59                	jle    40eee0 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x60>
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
  40ee87:	55                   	push   %rbp
  40ee88:	53                   	push   %rbx
  40ee89:	48 89 fb             	mov    %rdi,%rbx
  40ee8c:	48 83 ec 08          	sub    $0x8,%rsp
		   _Manager_operation __op)
	{
	  switch (__op)
  40ee90:	83 fa 02             	cmp    $0x2,%edx
  40ee93:	74 1b                	je     40eeb0 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x30>
  40ee95:	83 fa 03             	cmp    $0x3,%edx
  40ee98:	75 08                	jne    40eea2 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x22>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
  40ee9a:	48 8b 3f             	mov    (%rdi),%rdi
  40ee9d:	e8 0e 4d ff ff       	callq  403bb0 <_ZdlPv@plt>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40eea2:	48 83 c4 08          	add    $0x8,%rsp
  40eea6:	31 c0                	xor    %eax,%eax
  40eea8:	5b                   	pop    %rbx
  40eea9:	5d                   	pop    %rbp
  40eeaa:	c3                   	retq   
  40eeab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
  40eeb0:	48 8b 2e             	mov    (%rsi),%rbp
  40eeb3:	bf 18 00 00 00       	mov    $0x18,%edi
  40eeb8:	e8 c3 52 ff ff       	callq  404180 <_Znwm@plt>
  40eebd:	48 8b 55 00          	mov    0x0(%rbp),%rdx
  40eec1:	48 89 10             	mov    %rdx,(%rax)
  40eec4:	48 8b 55 08          	mov    0x8(%rbp),%rdx
  40eec8:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40eecc:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  40eed0:	48 89 50 10          	mov    %rdx,0x10(%rax)
  40eed4:	48 89 03             	mov    %rax,(%rbx)
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40eed7:	48 83 c4 08          	add    $0x8,%rsp
  40eedb:	31 c0                	xor    %eax,%eax
  40eedd:	5b                   	pop    %rbx
  40eede:	5d                   	pop    %rbp
  40eedf:	c3                   	retq   
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
  40eee0:	85 d2                	test   %edx,%edx
  40eee2:	75 0a                	jne    40eeee <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x6e>
	    {
#ifdef __GXX_RTTI
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
  40eee4:	48 8b 05 5d 50 20 00 	mov    0x20505d(%rip),%rax        # 613f48 <_DYNAMIC+0x2c0>
  40eeeb:	48 89 07             	mov    %rax,(%rdi)
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40eeee:	31 c0                	xor    %eax,%eax
  40eef0:	c3                   	retq   
  40eef1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
  40eef8:	48 8b 06             	mov    (%rsi),%rax
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
  40eefb:	48 89 07             	mov    %rax,(%rdi)
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
  40eefe:	31 c0                	xor    %eax,%eax
  40ef00:	c3                   	retq   
  40ef01:	90                   	nop
  40ef02:	90                   	nop
  40ef03:	90                   	nop
  40ef04:	90                   	nop
  40ef05:	90                   	nop
  40ef06:	90                   	nop
  40ef07:	90                   	nop
  40ef08:	90                   	nop
  40ef09:	90                   	nop
  40ef0a:	90                   	nop
  40ef0b:	90                   	nop
  40ef0c:	90                   	nop
  40ef0d:	90                   	nop
  40ef0e:	90                   	nop
  40ef0f:	90                   	nop

000000000040ef10 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE9_M_invokeERKSt9_Any_data>:
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
  40ef10:	48 8b 17             	mov    (%rdi),%rdx

      // Handle pointers
      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
	_Res
	operator()(_Class* __object, _Args&&... __args) const
	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
  40ef13:	48 8b 02             	mov    (%rdx),%rax
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (get<_Indexes>(_M_bound_args), __args)...);
  40ef16:	48 8b 7a 10          	mov    0x10(%rdx),%rdi
  40ef1a:	48 03 7a 08          	add    0x8(%rdx),%rdi

      // Handle pointers
      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
	_Res
	operator()(_Class* __object, _Args&&... __args) const
	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
  40ef1e:	a8 01                	test   $0x1,%al
  40ef20:	74 08                	je     40ef2a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS4_EEE9_M_invokeERKSt9_Any_data+0x1a>
  40ef22:	48 8b 17             	mov    (%rdi),%rdx
  40ef25:	48 8b 44 02 ff       	mov    -0x1(%rdx,%rax,1),%rax
  40ef2a:	ff e0                	jmpq   *%rax
  40ef2c:	90                   	nop
  40ef2d:	90                   	nop
  40ef2e:	90                   	nop
  40ef2f:	90                   	nop

000000000040ef30 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE9_M_invokeERKSt9_Any_data>:
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
  40ef30:	48 8b 17             	mov    (%rdi),%rdx

      // Handle pointers
      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
	_Res
	operator()(_Class* __object, _Args&&... __args) const
	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
  40ef33:	48 8b 02             	mov    (%rdx),%rax
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (get<_Indexes>(_M_bound_args), __args)...);
  40ef36:	48 8b 7a 10          	mov    0x10(%rdx),%rdi
  40ef3a:	48 03 7a 08          	add    0x8(%rdx),%rdi

      // Handle pointers
      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
	_Res
	operator()(_Class* __object, _Args&&... __args) const
	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
  40ef3e:	a8 01                	test   $0x1,%al
  40ef40:	74 08                	je     40ef4a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt7_Mem_fnIMN6rocket15EventDispatcherEFivEEPS4_EEE9_M_invokeERKSt9_Any_data+0x1a>
  40ef42:	48 8b 17             	mov    (%rdi),%rdx
  40ef45:	48 8b 44 02 ff       	mov    -0x1(%rdx,%rax,1),%rax
  40ef4a:	ff e0                	jmpq   *%rax
  40ef4c:	90                   	nop
  40ef4d:	90                   	nop
  40ef4e:	90                   	nop
  40ef4f:	90                   	nop

000000000040ef50 <_ZNSt8functionIFvvEEC1ERKS1_>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(0) { }
  40ef50:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  40ef57:	00 
  40ef58:	48 8b 46 10          	mov    0x10(%rsi),%rax
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
  40ef5c:	48 85 c0             	test   %rax,%rax
  40ef5f:	74 29                	je     40ef8a <_ZNSt8functionIFvvEEC1ERKS1_+0x3a>
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
  40ef61:	55                   	push   %rbp
  40ef62:	53                   	push   %rbx
  40ef63:	48 89 f5             	mov    %rsi,%rbp
  40ef66:	48 89 fb             	mov    %rdi,%rbx
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
  40ef69:	ba 02 00 00 00       	mov    $0x2,%edx
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
  40ef6e:	48 83 ec 08          	sub    $0x8,%rsp
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
  40ef72:	ff d0                	callq  *%rax
	  _M_invoker = __x._M_invoker;
  40ef74:	48 8b 45 18          	mov    0x18(%rbp),%rax
  40ef78:	48 89 43 18          	mov    %rax,0x18(%rbx)
	  _M_manager = __x._M_manager;
  40ef7c:	48 8b 45 10          	mov    0x10(%rbp),%rax
  40ef80:	48 89 43 10          	mov    %rax,0x10(%rbx)
	}
    }
  40ef84:	48 83 c4 08          	add    $0x8,%rsp
  40ef88:	5b                   	pop    %rbx
  40ef89:	5d                   	pop    %rbp
  40ef8a:	f3 c3                	repz retq 
  40ef8c:	48 89 c5             	mov    %rax,%rbp

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
  40ef8f:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
  40ef93:	48 85 c9             	test   %rcx,%rcx
  40ef96:	74 0d                	je     40efa5 <_ZNSt8functionIFvvEEC1ERKS1_+0x55>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
  40ef98:	ba 03 00 00 00       	mov    $0x3,%edx
  40ef9d:	48 89 de             	mov    %rbx,%rsi
  40efa0:	48 89 df             	mov    %rbx,%rdi
  40efa3:	ff d1                	callq  *%rcx
  40efa5:	48 89 ef             	mov    %rbp,%rdi
  40efa8:	e8 f3 51 ff ff       	callq  4041a0 <_Unwind_Resume@plt>
  40efad:	90                   	nop
  40efae:	90                   	nop
  40efaf:	90                   	nop

000000000040efb0 <_ZNKSt8functionIFvvEEclEv>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
  40efb0:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
  40efb5:	74 06                	je     40efbd <_ZNKSt8functionIFvvEEclEv+0xd>
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
  40efb7:	48 8b 47 18          	mov    0x18(%rdi),%rax
  40efbb:	ff e0                	jmpq   *%rax
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
  40efbd:	50                   	push   %rax
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
  40efbe:	e8 7d 4f ff ff       	callq  403f40 <_ZSt25__throw_bad_function_callv@plt>
  40efc3:	90                   	nop
  40efc4:	90                   	nop
  40efc5:	90                   	nop
  40efc6:	90                   	nop
  40efc7:	90                   	nop
  40efc8:	90                   	nop
  40efc9:	90                   	nop
  40efca:	90                   	nop
  40efcb:	90                   	nop
  40efcc:	90                   	nop
  40efcd:	90                   	nop
  40efce:	90                   	nop
  40efcf:	90                   	nop

000000000040efd0 <_ZN6rocket13NetworkThread3runEv>:
	bool start() {
		_thread.start();
	}
	*/

	virtual void run() {
  40efd0:	41 54                	push   %r12
  40efd2:	55                   	push   %rbp
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40efd3:	48 8d 35 c5 1d 00 00 	lea    0x1dc5(%rip),%rsi        # 410d9f <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x7f>
  40efda:	53                   	push   %rbx
  40efdb:	48 8b 1d 3e 4f 20 00 	mov    0x204f3e(%rip),%rbx        # 613f20 <_DYNAMIC+0x298>
  40efe2:	49 89 fc             	mov    %rdi,%r12
  40efe5:	ba 11 00 00 00       	mov    $0x11,%edx
  40efea:	48 89 df             	mov    %rbx,%rdi
  40efed:	e8 ae 4e ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40eff2:	48 8b 03             	mov    (%rbx),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40eff5:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40eff9:	48 8b ac 18 f0 00 00 	mov    0xf0(%rax,%rbx,1),%rbp
  40f000:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40f001:	48 85 ed             	test   %rbp,%rbp
  40f004:	74 52                	je     40f058 <_ZN6rocket13NetworkThread3runEv+0x88>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40f006:	80 7d 38 00          	cmpb   $0x0,0x38(%rbp)
  40f00a:	74 24                	je     40f030 <_ZN6rocket13NetworkThread3runEv+0x60>
  40f00c:	0f be 75 43          	movsbl 0x43(%rbp),%esi
  40f010:	48 89 df             	mov    %rbx,%rdi
  40f013:	e8 c8 51 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40f018:	48 89 c7             	mov    %rax,%rdi
  40f01b:	e8 10 4f ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
		std::cout << "NetworkThread run" << std::endl;
		cb_();
	}
  40f020:	5b                   	pop    %rbx
	}
	*/

	virtual void run() {
		std::cout << "NetworkThread run" << std::endl;
		cb_();
  40f021:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
	}
  40f026:	5d                   	pop    %rbp
  40f027:	41 5c                	pop    %r12
	}
	*/

	virtual void run() {
		std::cout << "NetworkThread run" << std::endl;
		cb_();
  40f029:	e9 82 ff ff ff       	jmpq   40efb0 <_ZNKSt8functionIFvvEEclEv>
  40f02e:	66 90                	xchg   %ax,%ax
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40f030:	48 89 ef             	mov    %rbp,%rdi
  40f033:	e8 b8 4b ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40f038:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40f03c:	be 0a 00 00 00       	mov    $0xa,%esi
  40f041:	48 8b 40 30          	mov    0x30(%rax),%rax
  40f045:	48 3b 05 44 4f 20 00 	cmp    0x204f44(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40f04c:	74 c2                	je     40f010 <_ZN6rocket13NetworkThread3runEv+0x40>
  40f04e:	48 89 ef             	mov    %rbp,%rdi
  40f051:	ff d0                	callq  *%rax
  40f053:	0f be f0             	movsbl %al,%esi
  40f056:	eb b8                	jmp    40f010 <_ZN6rocket13NetworkThread3runEv+0x40>
	__throw_bad_cast();
  40f058:	e8 83 4a ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
  40f05d:	90                   	nop
  40f05e:	90                   	nop
  40f05f:	90                   	nop

000000000040f060 <_ZN6rocket10ThreadBase3runEv>:
		((ThreadBase*)param)->run();

		return NULL;
	}

	virtual void run() {
  40f060:	41 54                	push   %r12
  40f062:	55                   	push   %rbp
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40f063:	48 8d 35 47 1d 00 00 	lea    0x1d47(%rip),%rsi        # 410db1 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0x91>
  40f06a:	53                   	push   %rbx
  40f06b:	48 8b 1d ae 4e 20 00 	mov    0x204eae(%rip),%rbx        # 613f20 <_DYNAMIC+0x298>
  40f072:	49 89 fc             	mov    %rdi,%r12
  40f075:	ba 0e 00 00 00       	mov    $0xe,%edx
  40f07a:	48 89 df             	mov    %rbx,%rdi
  40f07d:	e8 1e 4e ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40f082:	48 8b 03             	mov    (%rbx),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40f085:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40f089:	48 8b ac 18 f0 00 00 	mov    0xf0(%rax,%rbx,1),%rbp
  40f090:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40f091:	48 85 ed             	test   %rbp,%rbp
  40f094:	74 52                	je     40f0e8 <_ZN6rocket10ThreadBase3runEv+0x88>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40f096:	80 7d 38 00          	cmpb   $0x0,0x38(%rbp)
  40f09a:	74 24                	je     40f0c0 <_ZN6rocket10ThreadBase3runEv+0x60>
  40f09c:	0f be 75 43          	movsbl 0x43(%rbp),%esi
  40f0a0:	48 89 df             	mov    %rbx,%rdi
  40f0a3:	e8 38 51 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40f0a8:	48 89 c7             	mov    %rax,%rdi
  40f0ab:	e8 80 4e ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
		std::cout << "ThreadBase run" << std::endl;
		cb_();
	}
  40f0b0:	5b                   	pop    %rbx
		return NULL;
	}

	virtual void run() {
		std::cout << "ThreadBase run" << std::endl;
		cb_();
  40f0b1:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
	}
  40f0b6:	5d                   	pop    %rbp
  40f0b7:	41 5c                	pop    %r12
		return NULL;
	}

	virtual void run() {
		std::cout << "ThreadBase run" << std::endl;
		cb_();
  40f0b9:	e9 f2 fe ff ff       	jmpq   40efb0 <_ZNKSt8functionIFvvEEclEv>
  40f0be:	66 90                	xchg   %ax,%ax
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40f0c0:	48 89 ef             	mov    %rbp,%rdi
  40f0c3:	e8 28 4b ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40f0c8:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40f0cc:	be 0a 00 00 00       	mov    $0xa,%esi
  40f0d1:	48 8b 40 30          	mov    0x30(%rax),%rax
  40f0d5:	48 3b 05 b4 4e 20 00 	cmp    0x204eb4(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40f0dc:	74 c2                	je     40f0a0 <_ZN6rocket10ThreadBase3runEv+0x40>
  40f0de:	48 89 ef             	mov    %rbp,%rdi
  40f0e1:	ff d0                	callq  *%rax
  40f0e3:	0f be f0             	movsbl %al,%esi
  40f0e6:	eb b8                	jmp    40f0a0 <_ZN6rocket10ThreadBase3runEv+0x40>
	__throw_bad_cast();
  40f0e8:	e8 f3 49 ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
  40f0ed:	90                   	nop
  40f0ee:	90                   	nop
  40f0ef:	90                   	nop

000000000040f0f0 <_ZN6rocket10WorkThread3runEv>:
	WorkThread(ThreadCallback cb) 
		: ThreadBase(cb)
	{};
	~WorkThread() {};

	virtual void run() {
  40f0f0:	41 54                	push   %r12
  40f0f2:	55                   	push   %rbp
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40f0f3:	48 8d 35 c6 1c 00 00 	lea    0x1cc6(%rip),%rsi        # 410dc0 <_ZZN6rocket5MutexD4EvE19__PRETTY_FUNCTION__+0xa0>
  40f0fa:	53                   	push   %rbx
  40f0fb:	48 8b 1d 1e 4e 20 00 	mov    0x204e1e(%rip),%rbx        # 613f20 <_DYNAMIC+0x298>
  40f102:	49 89 fc             	mov    %rdi,%r12
  40f105:	ba 0e 00 00 00       	mov    $0xe,%edx
  40f10a:	48 89 df             	mov    %rbx,%rdi
  40f10d:	e8 8e 4d ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40f112:	48 8b 03             	mov    (%rbx),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40f115:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40f119:	48 8b ac 18 f0 00 00 	mov    0xf0(%rax,%rbx,1),%rbp
  40f120:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40f121:	48 85 ed             	test   %rbp,%rbp
  40f124:	74 52                	je     40f178 <_ZN6rocket10WorkThread3runEv+0x88>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40f126:	80 7d 38 00          	cmpb   $0x0,0x38(%rbp)
  40f12a:	74 24                	je     40f150 <_ZN6rocket10WorkThread3runEv+0x60>
  40f12c:	0f be 75 43          	movsbl 0x43(%rbp),%esi
  40f130:	48 89 df             	mov    %rbx,%rdi
  40f133:	e8 a8 50 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40f138:	48 89 c7             	mov    %rax,%rdi
  40f13b:	e8 f0 4d ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
		std::cout << "WorkThread run" << std::endl;
		cb_();
	}
  40f140:	5b                   	pop    %rbx
	{};
	~WorkThread() {};

	virtual void run() {
		std::cout << "WorkThread run" << std::endl;
		cb_();
  40f141:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
	}
  40f146:	5d                   	pop    %rbp
  40f147:	41 5c                	pop    %r12
	{};
	~WorkThread() {};

	virtual void run() {
		std::cout << "WorkThread run" << std::endl;
		cb_();
  40f149:	e9 62 fe ff ff       	jmpq   40efb0 <_ZNKSt8functionIFvvEEclEv>
  40f14e:	66 90                	xchg   %ax,%ax
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40f150:	48 89 ef             	mov    %rbp,%rdi
  40f153:	e8 98 4a ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40f158:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40f15c:	be 0a 00 00 00       	mov    $0xa,%esi
  40f161:	48 8b 40 30          	mov    0x30(%rax),%rax
  40f165:	48 3b 05 24 4e 20 00 	cmp    0x204e24(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40f16c:	74 c2                	je     40f130 <_ZN6rocket10WorkThread3runEv+0x40>
  40f16e:	48 89 ef             	mov    %rbp,%rdi
  40f171:	ff d0                	callq  *%rax
  40f173:	0f be f0             	movsbl %al,%esi
  40f176:	eb b8                	jmp    40f130 <_ZN6rocket10WorkThread3runEv+0x40>
	__throw_bad_cast();
  40f178:	e8 63 49 ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
  40f17d:	90                   	nop
  40f17e:	90                   	nop
  40f17f:	90                   	nop

000000000040f180 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_>:
  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.
  template<typename _Tp, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
  40f180:	41 57                	push   %r15
  40f182:	41 56                	push   %r14
  40f184:	41 55                	push   %r13
  40f186:	41 54                	push   %r12
  40f188:	49 89 f4             	mov    %rsi,%r12
  40f18b:	55                   	push   %rbp
  40f18c:	53                   	push   %rbx
  40f18d:	48 89 fb             	mov    %rdi,%rbx
  40f190:	48 83 ec 08          	sub    $0x8,%rsp
       *  (And consequently, %deque iterators.)
       */
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
  40f194:	48 8b 6f 48          	mov    0x48(%rdi),%rbp
  40f198:	48 8b 0f             	mov    (%rdi),%rcx
  40f19b:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  40f19f:	48 89 e8             	mov    %rbp,%rax
  40f1a2:	48 29 c8             	sub    %rcx,%rax
  40f1a5:	48 89 d6             	mov    %rdx,%rsi
  40f1a8:	48 c1 f8 03          	sar    $0x3,%rax
  40f1ac:	48 29 c6             	sub    %rax,%rsi
  40f1af:	48 83 fe 01          	cmp    $0x1,%rsi
  40f1b3:	76 53                	jbe    40f208 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x88>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40f1b5:	bf 00 02 00 00       	mov    $0x200,%edi
  40f1ba:	e8 c1 4f ff ff       	callq  404180 <_Znwm@plt>
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)
#endif
      {
	_M_reserve_map_at_back();
	*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
  40f1bf:	48 89 45 08          	mov    %rax,0x8(%rbp)
	__try
	  {
#if __cplusplus >= 201103L
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
  40f1c3:	48 8b 43 30          	mov    0x30(%rbx),%rax

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40f1c7:	49 8b 14 24          	mov    (%r12),%rdx
  40f1cb:	48 85 c0             	test   %rax,%rax
  40f1ce:	74 03                	je     40f1d3 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x53>
  40f1d0:	48 89 10             	mov    %rdx,(%rax)
				    std::forward<_Args>(__args)...);
#else
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
#endif
	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
  40f1d3:	48 8b 43 48          	mov    0x48(%rbx),%rax
  40f1d7:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40f1db:	48 89 53 48          	mov    %rdx,0x48(%rbx)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40f1df:	48 8b 40 08          	mov    0x8(%rax),%rax
	_M_last = _M_first + difference_type(_S_buffer_size());
  40f1e3:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40f1ea:	48 89 43 38          	mov    %rax,0x38(%rbx)
						+ 1);
	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
  40f1ee:	48 89 43 30          	mov    %rax,0x30(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40f1f2:	48 89 53 40          	mov    %rdx,0x40(%rbx)
	__catch(...)
	  {
	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
	    __throw_exception_again;
	  }
      }
  40f1f6:	48 83 c4 08          	add    $0x8,%rsp
  40f1fa:	5b                   	pop    %rbx
  40f1fb:	5d                   	pop    %rbp
  40f1fc:	41 5c                	pop    %r12
  40f1fe:	41 5d                	pop    %r13
  40f200:	41 5e                	pop    %r14
  40f202:	41 5f                	pop    %r15
  40f204:	c3                   	retq   
  40f205:	0f 1f 00             	nopl   (%rax)
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
  40f208:	48 8b 77 28          	mov    0x28(%rdi),%rsi
  40f20c:	48 89 e8             	mov    %rbp,%rax
  40f20f:	48 29 f0             	sub    %rsi,%rax
  40f212:	48 c1 f8 03          	sar    $0x3,%rax
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
  40f216:	4c 8d 70 02          	lea    0x2(%rax),%r14
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
  40f21a:	4c 8d 68 01          	lea    0x1(%rax),%r13
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
  40f21e:	4b 8d 04 36          	lea    (%r14,%r14,1),%rax
  40f222:	48 39 c2             	cmp    %rax,%rdx
  40f225:	0f 87 a5 00 00 00    	ja     40f2d0 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x150>
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
  40f22b:	48 85 d2             	test   %rdx,%rdx
  40f22e:	0f 84 cc 00 00 00    	je     40f300 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x180>
	}
      else
	{
	  size_type __new_map_size = this->_M_impl._M_map_size
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;
  40f234:	48 8d 6c 12 02       	lea    0x2(%rdx,%rdx,1),%rbp
      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
  40f239:	48 b8 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rax
  40f240:	ff ff 1f 
  40f243:	48 39 c5             	cmp    %rax,%rbp
  40f246:	0f 87 02 01 00 00    	ja     40f34e <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x1ce>
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40f24c:	48 8d 3c ed 00 00 00 	lea    0x0(,%rbp,8),%rdi
  40f253:	00 
  40f254:	e8 27 4f ff ff       	callq  404180 <_Znwm@plt>

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
  40f259:	48 89 ea             	mov    %rbp,%rdx
  40f25c:	49 89 c7             	mov    %rax,%r15
	  std::copy(this->_M_impl._M_start._M_node,
		    this->_M_impl._M_finish._M_node + 1,
		    __new_nstart);
  40f25f:	48 8b 73 28          	mov    0x28(%rbx),%rsi
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
  40f263:	4c 29 f2             	sub    %r14,%rdx
  40f266:	48 d1 ea             	shr    %rdx
	  size_type __new_map_size = this->_M_impl._M_map_size
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
  40f269:	4c 8d 34 d0          	lea    (%rax,%rdx,8),%r14
	                 + (__add_at_front ? __nodes_to_add : 0);
	  std::copy(this->_M_impl._M_start._M_node,
		    this->_M_impl._M_finish._M_node + 1,
		    __new_nstart);
  40f26d:	48 8b 43 48          	mov    0x48(%rbx),%rax
  40f271:	48 8d 50 08          	lea    0x8(%rax),%rdx
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40f275:	48 29 f2             	sub    %rsi,%rdx
  40f278:	48 89 d0             	mov    %rdx,%rax
  40f27b:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40f27f:	48 85 c0             	test   %rax,%rax
  40f282:	0f 85 88 00 00 00    	jne    40f310 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x190>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40f288:	48 8b 3b             	mov    (%rbx),%rdi
  40f28b:	e8 20 49 ff ff       	callq  403bb0 <_ZdlPv@plt>
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

	  this->_M_impl._M_map = __new_map;
  40f290:	4c 89 3b             	mov    %r15,(%rbx)
	  this->_M_impl._M_map_size = __new_map_size;
  40f293:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
  40f297:	49 c1 e5 03          	shl    $0x3,%r13
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
  40f29b:	4c 89 73 28          	mov    %r14,0x28(%rbx)
	_M_first = *__new_node;
  40f29f:	49 8b 06             	mov    (%r14),%rax
	}

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
  40f2a2:	4b 8d 6c 2e f8       	lea    -0x8(%r14,%r13,1),%rbp
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
  40f2a7:	48 89 6b 48          	mov    %rbp,0x48(%rbx)
	_M_first = *__new_node;
  40f2ab:	48 89 43 18          	mov    %rax,0x18(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40f2af:	48 05 00 02 00 00    	add    $0x200,%rax
  40f2b5:	48 89 43 20          	mov    %rax,0x20(%rbx)
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
  40f2b9:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40f2bd:	48 89 43 38          	mov    %rax,0x38(%rbx)
	_M_last = _M_first + difference_type(_S_buffer_size());
  40f2c1:	48 05 00 02 00 00    	add    $0x200,%rax
  40f2c7:	48 89 43 40          	mov    %rax,0x40(%rbx)
  40f2cb:	e9 e5 fe ff ff       	jmpq   40f1b5 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x35>
      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
	{
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
					 - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
  40f2d0:	4c 29 f2             	sub    %r14,%rdx
  40f2d3:	48 d1 ea             	shr    %rdx
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
	{
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
  40f2d6:	4c 8d 34 d1          	lea    (%rcx,%rdx,8),%r14
					 - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
	  if (__new_nstart < this->_M_impl._M_start._M_node)
  40f2da:	4c 39 f6             	cmp    %r14,%rsi
  40f2dd:	76 41                	jbe    40f320 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x1a0>
	    std::copy(this->_M_impl._M_start._M_node,
		      this->_M_impl._M_finish._M_node + 1,
		      __new_nstart);
  40f2df:	48 8d 55 08          	lea    0x8(%rbp),%rdx
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40f2e3:	48 29 f2             	sub    %rsi,%rdx
  40f2e6:	48 89 d0             	mov    %rdx,%rax
  40f2e9:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40f2ed:	48 85 c0             	test   %rax,%rax
  40f2f0:	74 a5                	je     40f297 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x117>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
  40f2f2:	4c 89 f7             	mov    %r14,%rdi
  40f2f5:	49 c1 e5 03          	shl    $0x3,%r13
  40f2f9:	e8 c2 4b ff ff       	callq  403ec0 <memmove@plt>
  40f2fe:	eb 9b                	jmp    40f29b <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x11b>
	}
      else
	{
	  size_type __new_map_size = this->_M_impl._M_map_size
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;
  40f300:	bd 03 00 00 00       	mov    $0x3,%ebp
  40f305:	e9 42 ff ff ff       	jmpq   40f24c <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0xcc>
  40f30a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40f310:	4c 89 f7             	mov    %r14,%rdi
  40f313:	e8 a8 4b ff ff       	callq  403ec0 <memmove@plt>
  40f318:	e9 6b ff ff ff       	jmpq   40f288 <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x108>
  40f31d:	0f 1f 00             	nopl   (%rax)
		      this->_M_impl._M_finish._M_node + 1,
		      __new_nstart);
	  else
	    std::copy_backward(this->_M_impl._M_start._M_node,
			       this->_M_impl._M_finish._M_node + 1,
			       __new_nstart + __old_num_nodes);
  40f320:	48 8d 55 08          	lea    0x8(%rbp),%rdx
  40f324:	49 c1 e5 03          	shl    $0x3,%r13
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40f328:	48 29 f2             	sub    %rsi,%rdx
  40f32b:	48 89 d0             	mov    %rdx,%rax
  40f32e:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40f332:	48 85 c0             	test   %rax,%rax
  40f335:	0f 84 60 ff ff ff    	je     40f29b <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x11b>
  40f33b:	4c 89 ef             	mov    %r13,%rdi
  40f33e:	48 29 d7             	sub    %rdx,%rdi
	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
  40f341:	4c 01 f7             	add    %r14,%rdi
  40f344:	e8 77 4b ff ff       	callq  403ec0 <memmove@plt>
  40f349:	e9 4d ff ff ff       	jmpq   40f29b <_ZNSt5dequeIPN6rocket10ConnectionESaIS2_EE16_M_push_back_auxIIRKS2_EEEvDpOT_+0x11b>
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();
  40f34e:	e8 3d 4d ff ff       	callq  404090 <_ZSt17__throw_bad_allocv@plt>
  40f353:	90                   	nop
  40f354:	90                   	nop
  40f355:	90                   	nop
  40f356:	90                   	nop
  40f357:	90                   	nop
  40f358:	90                   	nop
  40f359:	90                   	nop
  40f35a:	90                   	nop
  40f35b:	90                   	nop
  40f35c:	90                   	nop
  40f35d:	90                   	nop
  40f35e:	90                   	nop
  40f35f:	90                   	nop

000000000040f360 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
  40f360:	41 55                	push   %r13
  40f362:	41 54                	push   %r12
  40f364:	55                   	push   %rbp
  40f365:	53                   	push   %rbx
  40f366:	48 89 fd             	mov    %rdi,%rbp
  40f369:	48 83 ec 18          	sub    $0x18,%rsp
  40f36d:	48 8b 17             	mov    (%rdi),%rdx

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
  40f370:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
  40f374:	48 29 d3             	sub    %rdx,%rbx
  40f377:	48 89 d8             	mov    %rbx,%rax
  40f37a:	48 c1 f8 03          	sar    $0x3,%rax
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
  40f37e:	48 85 c0             	test   %rax,%rax
  40f381:	74 7d                	je     40f400 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0xa0>
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
  40f383:	48 8d 0c 00          	lea    (%rax,%rax,1),%rcx
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  40f387:	49 c7 c5 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r13
  40f38e:	48 39 c8             	cmp    %rcx,%rax
  40f391:	77 73                	ja     40f406 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0xa6>
  40f393:	48 bf ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rdi
  40f39a:	ff ff 1f 
  40f39d:	48 39 f9             	cmp    %rdi,%rcx
  40f3a0:	77 64                	ja     40f406 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0xa6>
  40f3a2:	48 c1 e0 04          	shl    $0x4,%rax

      pointer
      _M_allocate(size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : 0;
  40f3a6:	45 31 e4             	xor    %r12d,%r12d
  40f3a9:	48 85 c9             	test   %rcx,%rcx
  40f3ac:	49 89 c5             	mov    %rax,%r13
  40f3af:	75 55                	jne    40f406 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0xa6>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40f3b1:	4c 89 e0             	mov    %r12,%rax
  40f3b4:	48 8b 0e             	mov    (%rsi),%rcx
  40f3b7:	48 01 d8             	add    %rbx,%rax
  40f3ba:	74 75                	je     40f431 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0xd1>
  40f3bc:	48 89 08             	mov    %rcx,(%rax)
  40f3bf:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
  40f3c3:	48 8b 5d 08          	mov    0x8(%rbp),%rbx
  40f3c7:	48 29 fb             	sub    %rdi,%rbx
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40f3ca:	48 89 d8             	mov    %rbx,%rax
  40f3cd:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40f3d1:	48 85 c0             	test   %rax,%rax
  40f3d4:	75 6a                	jne    40f440 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0xe0>

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
  40f3d6:	48 85 ff             	test   %rdi,%rdi
	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
  40f3d9:	49 8d 5c 1c 08       	lea    0x8(%r12,%rbx,1),%rbx
  40f3de:	74 05                	je     40f3e5 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0x85>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40f3e0:	e8 cb 47 ff ff       	callq  403bb0 <_ZdlPv@plt>
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
  40f3e5:	4c 89 65 00          	mov    %r12,0x0(%rbp)
	this->_M_impl._M_finish = __new_finish;
	this->_M_impl._M_end_of_storage = __new_start + __len;
  40f3e9:	4d 01 ec             	add    %r13,%r12
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
	this->_M_impl._M_finish = __new_finish;
  40f3ec:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
	this->_M_impl._M_end_of_storage = __new_start + __len;
  40f3f0:	4c 89 65 10          	mov    %r12,0x10(%rbp)
      }
  40f3f4:	48 83 c4 18          	add    $0x18,%rsp
  40f3f8:	5b                   	pop    %rbx
  40f3f9:	5d                   	pop    %rbp
  40f3fa:	41 5c                	pop    %r12
  40f3fc:	41 5d                	pop    %r13
  40f3fe:	c3                   	retq   
  40f3ff:	90                   	nop
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
  40f400:	41 bd 08 00 00 00    	mov    $0x8,%r13d
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  40f406:	4c 89 ef             	mov    %r13,%rdi
  40f409:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  40f40e:	e8 6d 4d ff ff       	callq  404180 <_Znwm@plt>
  40f413:	48 8b 55 00          	mov    0x0(%rbp),%rdx
  40f417:	48 8b 5d 08          	mov    0x8(%rbp),%rbx
  40f41b:	49 89 c4             	mov    %rax,%r12
  40f41e:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  40f423:	4c 89 e0             	mov    %r12,%rax
  40f426:	48 29 d3             	sub    %rdx,%rbx
  40f429:	48 01 d8             	add    %rbx,%rax
  40f42c:	48 8b 0e             	mov    (%rsi),%rcx
  40f42f:	75 8b                	jne    40f3bc <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0x5c>
					   is_move_assignable<_Tp>,
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
  40f431:	48 89 d8             	mov    %rbx,%rax
  40f434:	48 89 d7             	mov    %rdx,%rdi
  40f437:	48 c1 f8 03          	sar    $0x3,%rax
	  if (_Num)
  40f43b:	48 85 c0             	test   %rax,%rax
  40f43e:	74 96                	je     40f3d6 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0x76>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
  40f440:	48 89 fe             	mov    %rdi,%rsi
  40f443:	48 89 da             	mov    %rbx,%rdx
  40f446:	4c 89 e7             	mov    %r12,%rdi
  40f449:	e8 72 4a ff ff       	callq  403ec0 <memmove@plt>
  40f44e:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
  40f452:	eb 82                	jmp    40f3d6 <_ZNSt6vectorIPN6rocket10ThreadBaseESaIS2_EE19_M_emplace_back_auxIIRKS2_EEEvDpOT_+0x76>
  40f454:	90                   	nop
  40f455:	90                   	nop
  40f456:	90                   	nop
  40f457:	90                   	nop
  40f458:	90                   	nop
  40f459:	90                   	nop
  40f45a:	90                   	nop
  40f45b:	90                   	nop
  40f45c:	90                   	nop
  40f45d:	90                   	nop
  40f45e:	90                   	nop
  40f45f:	90                   	nop

000000000040f460 <_ZN6rocket10BaseSocket8initSockEv>:

 
namespace rocket {

void BaseSocket::initSock()
{
  40f460:	f3 c3                	repz retq 
  40f462:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40f469:	1f 84 00 00 00 00 00 

000000000040f470 <_ZN6rocket10BaseSocket10uninitSockEv>:
  }
#endif // WIN32
}

void BaseSocket::uninitSock()
{
  40f470:	f3 c3                	repz retq 
  40f472:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40f479:	1f 84 00 00 00 00 00 

000000000040f480 <_ZN6rocket10BaseSocket6socketEi>:
  return (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
}

int
BaseSocket::socket(int type /*= SOCK_STREAM*/)
{
  40f480:	89 fe                	mov    %edi,%esi
  return (int) ::socket(AF_INET, type, 0);
  40f482:	31 d2                	xor    %edx,%edx
  40f484:	bf 02 00 00 00       	mov    $0x2,%edi
  40f489:	e9 52 4a ff ff       	jmpq   403ee0 <socket@plt>
  40f48e:	66 90                	xchg   %ax,%ax

000000000040f490 <_ZN6rocket10BaseSocket5closeEi>:
{
//  XmlRpcUtil::log(4, "UtilitySocket::close: fd %d.", fd);
#if defined(WIN32)
  closesocket(fd);
#else
  ::close(fd);
  40f490:	e9 6b 46 ff ff       	jmpq   403b00 <close@plt>
  40f495:	90                   	nop
  40f496:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40f49d:	00 00 00 

000000000040f4a0 <_ZN6rocket10BaseSocket14setNonBlockingEi>:
#endif // WIN32
}

bool
BaseSocket::setNonBlocking(int fd)
{
  40f4a0:	48 83 ec 08          	sub    $0x8,%rsp
#if defined(WIN32)
  unsigned long flag = 1;
  return (ioctlsocket((SOCKET)fd, FIONBIO, &flag) == 0);
#else
  return (fcntl(fd, F_SETFL, O_NONBLOCK) == 0);
  40f4a4:	31 c0                	xor    %eax,%eax
  40f4a6:	ba 00 08 00 00       	mov    $0x800,%edx
  40f4ab:	be 04 00 00 00       	mov    $0x4,%esi
  40f4b0:	e8 7b 4d ff ff       	callq  404230 <fcntl@plt>
  40f4b5:	85 c0                	test   %eax,%eax
  40f4b7:	0f 94 c0             	sete   %al
#endif // WIN32
}
  40f4ba:	48 83 c4 08          	add    $0x8,%rsp
  40f4be:	c3                   	retq   
  40f4bf:	90                   	nop

000000000040f4c0 <_ZN6rocket10BaseSocket12setReuseAddrEi>:


bool
BaseSocket::setReuseAddr(int fd)
{
  40f4c0:	48 83 ec 18          	sub    $0x18,%rsp
  // Allow this port to be re-bound immediately so server re-starts are not delayed
  int sflag = 1;
  return (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char *)&sflag, sizeof(sflag)) == 0);
  40f4c4:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  40f4ca:	ba 02 00 00 00       	mov    $0x2,%edx
  40f4cf:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  40f4d4:	be 01 00 00 00       	mov    $0x1,%esi

bool
BaseSocket::setReuseAddr(int fd)
{
  // Allow this port to be re-bound immediately so server re-starts are not delayed
  int sflag = 1;
  40f4d9:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%rsp)
  40f4e0:	00 
  return (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char *)&sflag, sizeof(sflag)) == 0);
  40f4e1:	e8 0a 48 ff ff       	callq  403cf0 <setsockopt@plt>
  40f4e6:	85 c0                	test   %eax,%eax
  40f4e8:	0f 94 c0             	sete   %al
}
  40f4eb:	48 83 c4 18          	add    $0x18,%rsp
  40f4ef:	c3                   	retq   

000000000040f4f0 <_ZN6rocket10BaseSocket4bindEiiPKc>:


// Bind to a specified port
bool 
BaseSocket::bind(int fd, int port, const char* pIp /*= NULL*/)
{
  40f4f0:	55                   	push   %rbp
  40f4f1:	53                   	push   %rbx
  40f4f2:	89 fd                	mov    %edi,%ebp
  if ( pIp == NULL )
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
  else
	  saddr.sin_addr.s_addr = inet_addr(pIp);

  saddr.sin_port = htons((u_short) port);
  40f4f4:	89 f3                	mov    %esi,%ebx


// Bind to a specified port
bool 
BaseSocket::bind(int fd, int port, const char* pIp /*= NULL*/)
{
  40f4f6:	48 83 ec 28          	sub    $0x28,%rsp
  40f4fa:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40f501:	00 00 
  40f503:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40f508:	31 c0                	xor    %eax,%eax
  struct sockaddr_in saddr;
  memset(&saddr, 0, sizeof(saddr));
  saddr.sin_family = AF_INET;
  40f50a:	b8 02 00 00 00       	mov    $0x2,%eax
  if ( pIp == NULL )
  40f50f:	48 85 d2             	test   %rdx,%rdx
      && (!__builtin_constant_p (__ch) || __ch != 0))
    {
      __warn_memset_zero_len ();
      return __dest;
    }
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
  40f512:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40f519:	00 
  40f51a:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  40f521:	00 00 
bool 
BaseSocket::bind(int fd, int port, const char* pIp /*= NULL*/)
{
  struct sockaddr_in saddr;
  memset(&saddr, 0, sizeof(saddr));
  saddr.sin_family = AF_INET;
  40f523:	66 89 04 24          	mov    %ax,(%rsp)
  if ( pIp == NULL )
  40f527:	74 0c                	je     40f535 <_ZN6rocket10BaseSocket4bindEiiPKc+0x45>
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
  else
	  saddr.sin_addr.s_addr = inet_addr(pIp);
  40f529:	48 89 d7             	mov    %rdx,%rdi
  40f52c:	e8 8f 4d ff ff       	callq  4042c0 <inet_addr@plt>
  40f531:	89 44 24 04          	mov    %eax,0x4(%rsp)

  saddr.sin_port = htons((u_short) port);
  40f535:	89 de                	mov    %ebx,%esi
  return (::bind(fd, (struct sockaddr *)&saddr, sizeof(saddr)) == 0);
  40f537:	ba 10 00 00 00       	mov    $0x10,%edx
  40f53c:	89 ef                	mov    %ebp,%edi
  if ( pIp == NULL )
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
  else
	  saddr.sin_addr.s_addr = inet_addr(pIp);

  saddr.sin_port = htons((u_short) port);
  40f53e:	66 c1 ce 08          	ror    $0x8,%si
  40f542:	66 89 74 24 02       	mov    %si,0x2(%rsp)
  return (::bind(fd, (struct sockaddr *)&saddr, sizeof(saddr)) == 0);
  40f547:	48 89 e6             	mov    %rsp,%rsi
  40f54a:	e8 c1 4b ff ff       	callq  404110 <bind@plt>
  40f54f:	85 c0                	test   %eax,%eax
  40f551:	0f 94 c0             	sete   %al
}
  40f554:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  40f559:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  40f560:	00 00 
  40f562:	75 07                	jne    40f56b <_ZN6rocket10BaseSocket4bindEiiPKc+0x7b>
  40f564:	48 83 c4 28          	add    $0x28,%rsp
  40f568:	5b                   	pop    %rbx
  40f569:	5d                   	pop    %rbp
  40f56a:	c3                   	retq   
  40f56b:	e8 e0 49 ff ff       	callq  403f50 <__stack_chk_fail@plt>

000000000040f570 <_ZN6rocket10BaseSocket6listenEii>:


// Set socket in listen mode
bool 
BaseSocket::listen(int fd, int backlog)
{
  40f570:	48 83 ec 08          	sub    $0x8,%rsp
  return (::listen(fd, backlog) == 0);
  40f574:	e8 27 48 ff ff       	callq  403da0 <listen@plt>
  40f579:	85 c0                	test   %eax,%eax
  40f57b:	0f 94 c0             	sete   %al
}
  40f57e:	48 83 c4 08          	add    $0x8,%rsp
  40f582:	c3                   	retq   
  40f583:	90                   	nop
  40f584:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40f58b:	00 00 00 00 00 

000000000040f590 <_ZN6rocket10BaseSocket6acceptEiRSsRi>:


int
BaseSocket::accept(int fd, std::string& ip, int& port)
{
  40f590:	41 55                	push   %r13
  40f592:	41 54                	push   %r12
  40f594:	49 89 f5             	mov    %rsi,%r13
  40f597:	55                   	push   %rbp
  40f598:	53                   	push   %rbx
  40f599:	49 89 d4             	mov    %rdx,%r12
  40f59c:	48 83 ec 38          	sub    $0x38,%rsp
#else
  socklen_t
#endif
    addrlen = sizeof(addr);

  int nRet = (int) ::accept(fd, (struct sockaddr*)&addr, &addrlen);
  40f5a0:	48 8d 54 24 0c       	lea    0xc(%rsp),%rdx
  40f5a5:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
#if defined(WIN32)
  int
#else
  socklen_t
#endif
    addrlen = sizeof(addr);
  40f5aa:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%rsp)
  40f5b1:	00 
}


int
BaseSocket::accept(int fd, std::string& ip, int& port)
{
  40f5b2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40f5b9:	00 00 
  40f5bb:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40f5c0:	31 c0                	xor    %eax,%eax
#else
  socklen_t
#endif
    addrlen = sizeof(addr);

  int nRet = (int) ::accept(fd, (struct sockaddr*)&addr, &addrlen);
  40f5c2:	e8 f9 4b ff ff       	callq  4041c0 <accept@plt>

  ip = inet_ntoa(addr.sin_addr);
  40f5c7:	8b 7c 24 14          	mov    0x14(%rsp),%edi
#else
  socklen_t
#endif
    addrlen = sizeof(addr);

  int nRet = (int) ::accept(fd, (struct sockaddr*)&addr, &addrlen);
  40f5cb:	89 c5                	mov    %eax,%ebp

  ip = inet_ntoa(addr.sin_addr);
  40f5cd:	e8 1e 49 ff ff       	callq  403ef0 <inet_ntoa@plt>
  40f5d2:	48 89 c3             	mov    %rax,%rbx
  40f5d5:	48 89 c7             	mov    %rax,%rdi
  40f5d8:	e8 83 47 ff ff       	callq  403d60 <strlen@plt>
       */
      basic_string&
      assign(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->assign(__s, traits_type::length(__s));
  40f5dd:	48 89 de             	mov    %rbx,%rsi
  40f5e0:	48 89 c2             	mov    %rax,%rdx
  40f5e3:	4c 89 ef             	mov    %r13,%rdi
  40f5e6:	e8 95 49 ff ff       	callq  403f80 <_ZNSs6assignEPKcm@plt>
  port = ntohs(addr.sin_port);
  40f5eb:	0f b7 4c 24 12       	movzwl 0x12(%rsp),%ecx
  40f5f0:	66 c1 c9 08          	ror    $0x8,%cx
  return nRet;
}
  40f5f4:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
  40f5f9:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
  40f600:	00 00 
    addrlen = sizeof(addr);

  int nRet = (int) ::accept(fd, (struct sockaddr*)&addr, &addrlen);

  ip = inet_ntoa(addr.sin_addr);
  port = ntohs(addr.sin_port);
  40f602:	0f b7 c9             	movzwl %cx,%ecx
  40f605:	41 89 0c 24          	mov    %ecx,(%r12)
  return nRet;
}
  40f609:	75 0d                	jne    40f618 <_ZN6rocket10BaseSocket6acceptEiRSsRi+0x88>
  40f60b:	48 83 c4 38          	add    $0x38,%rsp
  40f60f:	89 e8                	mov    %ebp,%eax
  40f611:	5b                   	pop    %rbx
  40f612:	5d                   	pop    %rbp
  40f613:	41 5c                	pop    %r12
  40f615:	41 5d                	pop    %r13
  40f617:	c3                   	retq   
  40f618:	e8 33 49 ff ff       	callq  403f50 <__stack_chk_fail@plt>
  40f61d:	90                   	nop
  40f61e:	66 90                	xchg   %ax,%ax

000000000040f620 <_ZN6rocket10BaseSocket8getErrorEv>:
///////////////////////////////////////////////////////////////////////////////////////////////////

// Returns last errno
int 
BaseSocket::getError()
{
  40f620:	48 83 ec 08          	sub    $0x8,%rsp
#if defined(WIN32)
  return WSAGetLastError();
#else
  return errno;
  40f624:	e8 e7 48 ff ff       	callq  403f10 <__errno_location@plt>
  40f629:	8b 00                	mov    (%rax),%eax
#endif
}
  40f62b:	48 83 c4 08          	add    $0x8,%rsp
  40f62f:	c3                   	retq   

000000000040f630 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi>:
  return true;
}

bool 
BaseSocket::nbWrite(int fd, const char* s, int len, int *bytesSoFar)
{
  40f630:	41 57                	push   %r15
  40f632:	41 56                	push   %r14
  40f634:	49 89 ce             	mov    %rcx,%r14
  40f637:	41 55                	push   %r13
  40f639:	41 54                	push   %r12
  40f63b:	55                   	push   %rbp
  40f63c:	53                   	push   %rbx
  40f63d:	48 89 f3             	mov    %rsi,%rbx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40f640:	48 8d 35 6b 1c 00 00 	lea    0x1c6b(%rip),%rsi        # 4112b2 <_ZTSSt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS2_EE+0x32>
  40f647:	89 d5                	mov    %edx,%ebp
  40f649:	ba 06 00 00 00       	mov    $0x6,%edx
  40f64e:	48 83 ec 18          	sub    $0x18,%rsp
  40f652:	4c 8b 2d c7 48 20 00 	mov    0x2048c7(%rip),%r13        # 613f20 <_DYNAMIC+0x298>
  40f659:	89 7c 24 04          	mov    %edi,0x4(%rsp)
  40f65d:	4c 89 ef             	mov    %r13,%rdi
  40f660:	e8 3b 48 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
	std::cout << "write=" << len << std::endl;
  40f665:	89 ee                	mov    %ebp,%esi
  40f667:	4c 89 ef             	mov    %r13,%rdi
  40f66a:	e8 31 44 ff ff       	callq  403aa0 <_ZNSolsEi@plt>
  40f66f:	48 89 c2             	mov    %rax,%rdx
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40f672:	48 8b 00             	mov    (%rax),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40f675:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40f679:	4c 8b a4 02 f0 00 00 	mov    0xf0(%rdx,%rax,1),%r12
  40f680:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40f681:	4d 85 e4             	test   %r12,%r12
  40f684:	0f 84 94 01 00 00    	je     40f81e <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x1ee>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40f68a:	41 80 7c 24 38 00    	cmpb   $0x0,0x38(%r12)
  40f690:	0f 84 4a 01 00 00    	je     40f7e0 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x1b0>
  40f696:	41 0f be 74 24 43    	movsbl 0x43(%r12),%esi
  40f69c:	48 89 d7             	mov    %rdx,%rdi
  40f69f:	e8 3c 4b ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40f6a4:	48 89 c7             	mov    %rax,%rdi
  40f6a7:	e8 84 48 ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
	int nToWrite = len - *bytesSoFar;
  40f6ac:	4d 63 26             	movslq (%r14),%r12
	char *sp = const_cast<char*>(s) + *bytesSoFar;
	bool wouldBlock = false;
  40f6af:	31 d2                	xor    %edx,%edx

bool 
BaseSocket::nbWrite(int fd, const char* s, int len, int *bytesSoFar)
{
	std::cout << "write=" << len << std::endl;
	int nToWrite = len - *bytesSoFar;
  40f6b1:	44 29 e5             	sub    %r12d,%ebp
	char *sp = const_cast<char*>(s) + *bytesSoFar;
  40f6b4:	49 01 dc             	add    %rbx,%r12
	bool wouldBlock = false;

	while ( nToWrite > 0 && ! wouldBlock ) {
  40f6b7:	eb 30                	jmp    40f6e9 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0xb9>
  40f6b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40f6c0:	0f be 72 43          	movsbl 0x43(%rdx),%esi
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40f6c4:	4c 89 ff             	mov    %r15,%rdi
  40f6c7:	e8 14 4b ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40f6cc:	48 89 c7             	mov    %rax,%rdi
  40f6cf:	e8 5c 48 ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
		int n = write(fd, sp, nToWrite);
		perror("nbWrite write");
		std::cout << "write=" << n << std::endl;
#endif

		if (n > 0) {
  40f6d4:	85 db                	test   %ebx,%ebx
  40f6d6:	0f 8e b4 00 00 00    	jle    40f790 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x160>
		  sp += n;
		  *bytesSoFar += n;
  40f6dc:	41 01 1e             	add    %ebx,(%r14)
		perror("nbWrite write");
		std::cout << "write=" << n << std::endl;
#endif

		if (n > 0) {
		  sp += n;
  40f6df:	48 63 c3             	movslq %ebx,%rax
		  *bytesSoFar += n;
		  nToWrite -= n;
  40f6e2:	29 dd                	sub    %ebx,%ebp
		perror("nbWrite write");
		std::cout << "write=" << n << std::endl;
#endif

		if (n > 0) {
		  sp += n;
  40f6e4:	49 01 c4             	add    %rax,%r12
  40f6e7:	31 d2                	xor    %edx,%edx
	std::cout << "write=" << len << std::endl;
	int nToWrite = len - *bytesSoFar;
	char *sp = const_cast<char*>(s) + *bytesSoFar;
	bool wouldBlock = false;

	while ( nToWrite > 0 && ! wouldBlock ) {
  40f6e9:	85 ed                	test   %ebp,%ebp
  40f6eb:	0f 9f c0             	setg   %al
  40f6ee:	38 c2                	cmp    %al,%dl
  40f6f0:	0f 83 e2 00 00 00    	jae    40f7d8 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x1a8>
#if defined(WIN32)
		int n = send(fd, sp, nToWrite, 0);
#else
		int n = write(fd, sp, nToWrite);
  40f6f6:	8b 7c 24 04          	mov    0x4(%rsp),%edi
  40f6fa:	48 63 d5             	movslq %ebp,%rdx
  40f6fd:	4c 89 e6             	mov    %r12,%rsi
  40f700:	e8 6b 4a ff ff       	callq  404170 <write@plt>
		perror("nbWrite write");
  40f705:	48 8d 3d ad 1b 00 00 	lea    0x1bad(%rip),%rdi        # 4112b9 <_ZTSSt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS2_EE+0x39>

	while ( nToWrite > 0 && ! wouldBlock ) {
#if defined(WIN32)
		int n = send(fd, sp, nToWrite, 0);
#else
		int n = write(fd, sp, nToWrite);
  40f70c:	48 89 c3             	mov    %rax,%rbx
		perror("nbWrite write");
  40f70f:	e8 1c 4a ff ff       	callq  404130 <perror@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40f714:	48 8d 35 97 1b 00 00 	lea    0x1b97(%rip),%rsi        # 4112b2 <_ZTSSt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS2_EE+0x32>
  40f71b:	ba 06 00 00 00       	mov    $0x6,%edx
  40f720:	4c 89 ef             	mov    %r13,%rdi
  40f723:	e8 78 47 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
		std::cout << "write=" << n << std::endl;
  40f728:	89 de                	mov    %ebx,%esi
  40f72a:	4c 89 ef             	mov    %r13,%rdi
  40f72d:	e8 6e 43 ff ff       	callq  403aa0 <_ZNSolsEi@plt>
  40f732:	49 89 c7             	mov    %rax,%r15
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40f735:	48 8b 00             	mov    (%rax),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40f738:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40f73c:	49 8b 94 07 f0 00 00 	mov    0xf0(%r15,%rax,1),%rdx
  40f743:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40f744:	48 85 d2             	test   %rdx,%rdx
  40f747:	0f 84 d1 00 00 00    	je     40f81e <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x1ee>
  40f74d:	80 7a 38 00          	cmpb   $0x0,0x38(%rdx)
  40f751:	0f 85 69 ff ff ff    	jne    40f6c0 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x90>
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40f757:	48 89 d7             	mov    %rdx,%rdi
  40f75a:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  40f75f:	e8 8c 44 ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40f764:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40f769:	be 0a 00 00 00       	mov    $0xa,%esi
  40f76e:	48 8b 02             	mov    (%rdx),%rax
  40f771:	48 8b 40 30          	mov    0x30(%rax),%rax
  40f775:	48 3b 05 14 48 20 00 	cmp    0x204814(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40f77c:	0f 84 42 ff ff ff    	je     40f6c4 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x94>
  40f782:	48 89 d7             	mov    %rdx,%rdi
  40f785:	ff d0                	callq  *%rax
  40f787:	0f be f0             	movsbl %al,%esi
  40f78a:	e9 35 ff ff ff       	jmpq   40f6c4 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x94>
  40f78f:	90                   	nop

// These errors are not considered fatal for an IO operation; the operation will be re-tried.
static inline bool
nonFatalError()
{
  int err = BaseSocket::getError();
  40f790:	e8 8b fe ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
  return (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
  40f795:	83 f8 73             	cmp    $0x73,%eax
  40f798:	0f 94 c1             	sete   %cl
  40f79b:	83 f8 0b             	cmp    $0xb,%eax
  40f79e:	0f 94 c2             	sete   %dl
  40f7a1:	08 ca                	or     %cl,%dl
  40f7a3:	75 1b                	jne    40f7c0 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x190>
  40f7a5:	83 f8 04             	cmp    $0x4,%eax
  40f7a8:	74 16                	je     40f7c0 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x190>
		} else {
		  return false;   // Error
		}
	}
	return true;
}
  40f7aa:	48 83 c4 18          	add    $0x18,%rsp
  40f7ae:	89 d0                	mov    %edx,%eax
  40f7b0:	5b                   	pop    %rbx
  40f7b1:	5d                   	pop    %rbp
  40f7b2:	41 5c                	pop    %r12
  40f7b4:	41 5d                	pop    %r13
  40f7b6:	41 5e                	pop    %r14
  40f7b8:	41 5f                	pop    %r15
  40f7ba:	c3                   	retq   
  40f7bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	std::cout << "write=" << len << std::endl;
	int nToWrite = len - *bytesSoFar;
	char *sp = const_cast<char*>(s) + *bytesSoFar;
	bool wouldBlock = false;

	while ( nToWrite > 0 && ! wouldBlock ) {
  40f7c0:	85 ed                	test   %ebp,%ebp
		if (n > 0) {
		  sp += n;
		  *bytesSoFar += n;
		  nToWrite -= n;
		} else if (nonFatalError()) {
		  wouldBlock = true;
  40f7c2:	ba 01 00 00 00       	mov    $0x1,%edx
	std::cout << "write=" << len << std::endl;
	int nToWrite = len - *bytesSoFar;
	char *sp = const_cast<char*>(s) + *bytesSoFar;
	bool wouldBlock = false;

	while ( nToWrite > 0 && ! wouldBlock ) {
  40f7c7:	0f 9f c0             	setg   %al
  40f7ca:	38 c2                	cmp    %al,%dl
  40f7cc:	0f 82 24 ff ff ff    	jb     40f6f6 <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0xc6>
  40f7d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		  wouldBlock = true;
		} else {
		  return false;   // Error
		}
	}
	return true;
  40f7d8:	ba 01 00 00 00       	mov    $0x1,%edx
  40f7dd:	eb cb                	jmp    40f7aa <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x17a>
  40f7df:	90                   	nop
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40f7e0:	4c 89 e7             	mov    %r12,%rdi
  40f7e3:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  40f7e8:	e8 03 44 ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40f7ed:	49 8b 04 24          	mov    (%r12),%rax
  40f7f1:	be 0a 00 00 00       	mov    $0xa,%esi
  40f7f6:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40f7fb:	48 8b 40 30          	mov    0x30(%rax),%rax
  40f7ff:	48 3b 05 8a 47 20 00 	cmp    0x20478a(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40f806:	0f 84 90 fe ff ff    	je     40f69c <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x6c>
  40f80c:	4c 89 e7             	mov    %r12,%rdi
  40f80f:	ff d0                	callq  *%rax
  40f811:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40f816:	0f be f0             	movsbl %al,%esi
  40f819:	e9 7e fe ff ff       	jmpq   40f69c <_ZN6rocket10BaseSocket7nbWriteEiPKciPi+0x6c>
	__throw_bad_cast();
  40f81e:	e8 bd 42 ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
  40f823:	90                   	nop
  40f824:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40f82b:	00 00 00 00 00 

000000000040f830 <_ZN6rocket10BaseSocket6nbReadEiPcRjj>:
}

int 
BaseSocket::nbRead(int s, char* pData, unsigned &nLen, unsigned nTimeout/* = 0*/)
{
	if (s == (int)INVALID_SOCKET)
  40f830:	83 ff ff             	cmp    $0xffffffff,%edi
  40f833:	0f 84 14 02 00 00    	je     40fa4d <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x21d>
		return SOCKET_ERROR_DISCONNECTED;
	
	if ((!pData) || (nLen == 0))
  40f839:	48 85 f6             	test   %rsi,%rsi
		return SOCKET_ERROR_PARAM;
  40f83c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
BaseSocket::nbRead(int s, char* pData, unsigned &nLen, unsigned nTimeout/* = 0*/)
{
	if (s == (int)INVALID_SOCKET)
		return SOCKET_ERROR_DISCONNECTED;
	
	if ((!pData) || (nLen == 0))
  40f841:	0f 84 0c 02 00 00    	je     40fa53 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x223>
  40f847:	44 8b 02             	mov    (%rdx),%r8d
  40f84a:	45 85 c0             	test   %r8d,%r8d
  40f84d:	0f 84 bf 01 00 00    	je     40fa12 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1e2>
	return true;
}

int 
BaseSocket::nbRead(int s, char* pData, unsigned &nLen, unsigned nTimeout/* = 0*/)
{
  40f853:	41 57                	push   %r15
  40f855:	41 56                	push   %r14
  40f857:	49 89 f7             	mov    %rsi,%r15
  40f85a:	41 55                	push   %r13
  40f85c:	41 54                	push   %r12
  40f85e:	41 89 fc             	mov    %edi,%r12d
  40f861:	55                   	push   %rbp
  40f862:	53                   	push   %rbx
	
	int iRecv = 0;
	unsigned nRecved = 0;
	int iRet = 0;
	
	time_t begin = time(NULL);
  40f863:	31 ff                	xor    %edi,%edi
  40f865:	89 cd                	mov    %ecx,%ebp
  40f867:	49 89 d5             	mov    %rdx,%r13
	
	if ((!pData) || (nLen == 0))
		return SOCKET_ERROR_PARAM;
	
	int iRecv = 0;
	unsigned nRecved = 0;
  40f86a:	31 db                	xor    %ebx,%ebx
	return true;
}

int 
BaseSocket::nbRead(int s, char* pData, unsigned &nLen, unsigned nTimeout/* = 0*/)
{
  40f86c:	48 81 ec e8 00 00 00 	sub    $0xe8,%rsp
	
	int iRecv = 0;
	unsigned nRecved = 0;
	int iRet = 0;
	
	time_t begin = time(NULL);
  40f873:	e8 28 4a ff ff       	callq  4042a0 <time@plt>
  40f878:	49 89 c6             	mov    %rax,%r14
  40f87b:	44 89 e0             	mov    %r12d,%eax
  40f87e:	41 8b 55 00          	mov    0x0(%r13),%edx
  40f882:	c1 f8 1f             	sar    $0x1f,%eax
  40f885:	c1 e8 1a             	shr    $0x1a,%eax
  40f888:	41 8d 0c 04          	lea    (%r12,%rax,1),%ecx
  40f88c:	83 e1 3f             	and    $0x3f,%ecx
  40f88f:	29 c1                	sub    %eax,%ecx
  40f891:	b8 01 00 00 00       	mov    $0x1,%eax
  40f896:	48 d3 e0             	shl    %cl,%rax
  40f899:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40f89e:	49 63 c4             	movslq %r12d,%rax
  40f8a1:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40f8a6:	41 8d 44 24 01       	lea    0x1(%r12),%eax
  40f8ab:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
  40f8af:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
  40f8b4:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  40f8b9:	48 8d 44 24 50       	lea    0x50(%rsp),%rax
  40f8be:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40f8c3:	eb 23                	jmp    40f8e8 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0xb8>
  40f8c5:	0f 1f 00             	nopl   (%rax)
			iRet = SOCKET_ERROR_DISCONNECTED;
			goto Ext;
		}
		else if (iRecv > 0)
		{
			nRecved += iRecv;
  40f8c8:	01 c3                	add    %eax,%ebx

					curTime = time(NULL);
				} 		
			}
		}
		curTime = time(NULL);
  40f8ca:	31 ff                	xor    %edi,%edi
  40f8cc:	e8 cf 49 ff ff       	callq  4042a0 <time@plt>
	} while ((nRecved < nLen) && ((unsigned)(curTime - begin) < nTimeout));
  40f8d1:	41 8b 55 00          	mov    0x0(%r13),%edx
	timeout.tv_sec = 0;
	timeout.tv_usec = nTimeout * 1000;
	
	int iRes = 0;
	time_t curTime = 0;
	do
  40f8d5:	39 d3                	cmp    %edx,%ebx
  40f8d7:	0f 83 13 01 00 00    	jae    40f9f0 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1c0>
					curTime = time(NULL);
				} 		
			}
		}
		curTime = time(NULL);
	} while ((nRecved < nLen) && ((unsigned)(curTime - begin) < nTimeout));
  40f8dd:	44 29 f0             	sub    %r14d,%eax
  40f8e0:	39 c5                	cmp    %eax,%ebp
  40f8e2:	0f 86 48 01 00 00    	jbe    40fa30 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x200>
	do
	{
#if defined(WIN32)
		iRecv = recv(s, pData + nRecved, nLen - nRecved, 0);
#else
		iRecv = read(s, pData + nRecved, nLen - nRecved);
  40f8e8:	89 de                	mov    %ebx,%esi
  40f8ea:	29 da                	sub    %ebx,%edx
	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));

      if (__nbytes > __bos0 (__buf))
	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
    }
  return __read_alias (__fd, __buf, __nbytes);
  40f8ec:	44 89 e7             	mov    %r12d,%edi
  40f8ef:	4c 01 fe             	add    %r15,%rsi
  40f8f2:	e8 49 43 ff ff       	callq  403c40 <read@plt>
#endif
		
		if (iRecv == 0 )
  40f8f7:	83 f8 00             	cmp    $0x0,%eax
  40f8fa:	0f 84 f8 00 00 00    	je     40f9f8 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1c8>
		{
			iRet = SOCKET_ERROR_DISCONNECTED;
			goto Ext;
		}
		else if (iRecv > 0)
  40f900:	7f c6                	jg     40f8c8 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x98>
		{
			nRecved += iRecv;
		}
		else if (iRecv == SOCKET_ERROR)
  40f902:	83 f8 ff             	cmp    $0xffffffff,%eax
  40f905:	75 c3                	jne    40f8ca <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x9a>
		{
			int ret = getError();
  40f907:	e8 14 fd ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
			if (ret != EWOULDBLOCK )
  40f90c:	83 f8 0b             	cmp    $0xb,%eax
  40f90f:	0f 85 e3 00 00 00    	jne    40f9f8 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1c8>
				iRet = SOCKET_ERROR_DISCONNECTED;
				goto Ext;
			}
			else
			{
				time_t curTime = time(NULL);
  40f915:	31 ff                	xor    %edi,%edi
  40f917:	e8 84 49 ff ff       	callq  4042a0 <time@plt>
				while ((unsigned)(curTime - begin) < nTimeout)
  40f91c:	44 29 f0             	sub    %r14d,%eax
  40f91f:	44 89 74 24 18       	mov    %r14d,0x18(%rsp)
  40f924:	39 e8                	cmp    %ebp,%eax
  40f926:	73 a2                	jae    40f8ca <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x9a>
				{
					FD_ZERO(fds);
  40f928:	89 5c 24 40          	mov    %ebx,0x40(%rsp)
  40f92c:	4c 89 74 24 38       	mov    %r14,0x38(%rsp)
  40f931:	44 89 64 24 44       	mov    %r12d,0x44(%rsp)
  40f936:	4c 89 7c 24 48       	mov    %r15,0x48(%rsp)
  40f93b:	4c 89 6c 24 30       	mov    %r13,0x30(%rsp)
  40f940:	44 8b 74 24 1c       	mov    0x1c(%rsp),%r14d
  40f945:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
  40f94a:	4c 8b 64 24 08       	mov    0x8(%rsp),%r12
  40f94f:	4c 8b 7c 24 28       	mov    0x28(%rsp),%r15
  40f954:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  40f959:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40f960:	b9 10 00 00 00       	mov    $0x10,%ecx
  40f965:	48 89 df             	mov    %rbx,%rdi
  40f968:	31 c0                	xor    %eax,%eax
  40f96a:	fc                   	cld    
  40f96b:	f3 48 ab             	rep stos %rax,%es:(%rdi)
					FD_SET(s, fds);
  40f96e:	4c 89 ef             	mov    %r13,%rdi
  40f971:	e8 1a 49 ff ff       	callq  404290 <__fdelt_chk@plt>
					
					timeval timeout;
					timeout.tv_sec = SOCKET_TIMEOUT_SELECT;
					timeout.tv_usec = 0;
					iRes = select(s+1, fds, NULL, NULL, &timeout);
  40f976:	31 c9                	xor    %ecx,%ecx
  40f978:	31 d2                	xor    %edx,%edx
  40f97a:	4d 89 f8             	mov    %r15,%r8
  40f97d:	48 89 de             	mov    %rbx,%rsi
  40f980:	44 89 f7             	mov    %r14d,%edi
			{
				time_t curTime = time(NULL);
				while ((unsigned)(curTime - begin) < nTimeout)
				{
					FD_ZERO(fds);
					FD_SET(s, fds);
  40f983:	4c 09 64 c4 60       	or     %r12,0x60(%rsp,%rax,8)
					
					timeval timeout;
					timeout.tv_sec = SOCKET_TIMEOUT_SELECT;
  40f988:	48 c7 44 24 50 05 00 	movq   $0x5,0x50(%rsp)
  40f98f:	00 00 
					timeout.tv_usec = 0;
  40f991:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  40f998:	00 00 
					iRes = select(s+1, fds, NULL, NULL, &timeout);
  40f99a:	e8 21 42 ff ff       	callq  403bc0 <select@plt>
					if (iRes == 1)
  40f99f:	83 f8 01             	cmp    $0x1,%eax
  40f9a2:	74 74                	je     40fa18 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1e8>
					{
						if (FD_ISSET(s, fds))
							break;
					}
					else if (iRes == SOCKET_ERROR)
  40f9a4:	83 f8 ff             	cmp    $0xffffffff,%eax
  40f9a7:	0f 84 93 00 00 00    	je     40fa40 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x210>
					{
						iRet = SOCKET_ERROR_DISCONNECTED;
						goto Ext;
					}

					curTime = time(NULL);
  40f9ad:	31 ff                	xor    %edi,%edi
  40f9af:	e8 ec 48 ff ff       	callq  4042a0 <time@plt>
				goto Ext;
			}
			else
			{
				time_t curTime = time(NULL);
				while ((unsigned)(curTime - begin) < nTimeout)
  40f9b4:	2b 44 24 18          	sub    0x18(%rsp),%eax
  40f9b8:	39 c5                	cmp    %eax,%ebp
  40f9ba:	77 a4                	ja     40f960 <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x130>
  40f9bc:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13

					curTime = time(NULL);
				} 		
			}
		}
		curTime = time(NULL);
  40f9c1:	31 ff                	xor    %edi,%edi
  40f9c3:	8b 5c 24 40          	mov    0x40(%rsp),%ebx
  40f9c7:	4c 8b 74 24 38       	mov    0x38(%rsp),%r14
  40f9cc:	44 8b 64 24 44       	mov    0x44(%rsp),%r12d
  40f9d1:	4c 8b 7c 24 48       	mov    0x48(%rsp),%r15
  40f9d6:	e8 c5 48 ff ff       	callq  4042a0 <time@plt>
	} while ((nRecved < nLen) && ((unsigned)(curTime - begin) < nTimeout));
  40f9db:	41 8b 55 00          	mov    0x0(%r13),%edx
	timeout.tv_sec = 0;
	timeout.tv_usec = nTimeout * 1000;
	
	int iRes = 0;
	time_t curTime = 0;
	do
  40f9df:	39 d3                	cmp    %edx,%ebx
  40f9e1:	0f 82 f6 fe ff ff    	jb     40f8dd <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0xad>
  40f9e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40f9ee:	00 00 
	{
		iRet = SOCKET_ERROR_TIMEOUT;
		goto Ext;
	}

	iRet = SOCKET_ERROR_OK;
  40f9f0:	31 c0                	xor    %eax,%eax
  40f9f2:	eb 09                	jmp    40f9fd <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1cd>
  40f9f4:	0f 1f 40 00          	nopl   0x0(%rax)
		else if (iRecv == SOCKET_ERROR)
		{
			int ret = getError();
			if (ret != EWOULDBLOCK )
			{
				iRet = SOCKET_ERROR_DISCONNECTED;
  40f9f8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		goto Ext;
	}

	iRet = SOCKET_ERROR_OK;
Ext:	
	nLen = nRecved;
  40f9fd:	41 89 5d 00          	mov    %ebx,0x0(%r13)
	return iRet;
}
  40fa01:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
  40fa08:	5b                   	pop    %rbx
  40fa09:	5d                   	pop    %rbp
  40fa0a:	41 5c                	pop    %r12
  40fa0c:	41 5d                	pop    %r13
  40fa0e:	41 5e                	pop    %r14
  40fa10:	41 5f                	pop    %r15
  40fa12:	f3 c3                	repz retq 
  40fa14:	0f 1f 40 00          	nopl   0x0(%rax)
					timeout.tv_sec = SOCKET_TIMEOUT_SELECT;
					timeout.tv_usec = 0;
					iRes = select(s+1, fds, NULL, NULL, &timeout);
					if (iRes == 1)
					{
						if (FD_ISSET(s, fds))
  40fa18:	4c 89 ef             	mov    %r13,%rdi
  40fa1b:	e8 70 48 ff ff       	callq  404290 <__fdelt_chk@plt>
  40fa20:	4c 85 64 c4 60       	test   %r12,0x60(%rsp,%rax,8)
  40fa25:	74 86                	je     40f9ad <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x17d>
  40fa27:	eb 93                	jmp    40f9bc <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x18c>
  40fa29:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		curTime = time(NULL);
	} while ((nRecved < nLen) && ((unsigned)(curTime - begin) < nTimeout));
	
	if (nRecved < nLen)
	{
		iRet = SOCKET_ERROR_TIMEOUT;
  40fa30:	39 d3                	cmp    %edx,%ebx
  40fa32:	19 c0                	sbb    %eax,%eax
  40fa34:	83 e0 fe             	and    $0xfffffffe,%eax
  40fa37:	eb c4                	jmp    40f9fd <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1cd>
  40fa39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40fa40:	8b 5c 24 40          	mov    0x40(%rsp),%ebx
  40fa44:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13
						if (FD_ISSET(s, fds))
							break;
					}
					else if (iRes == SOCKET_ERROR)
					{
						iRet = SOCKET_ERROR_DISCONNECTED;
  40fa49:	b0 fd                	mov    $0xfd,%al
  40fa4b:	eb b0                	jmp    40f9fd <_ZN6rocket10BaseSocket6nbReadEiPcRjj+0x1cd>

int 
BaseSocket::nbRead(int s, char* pData, unsigned &nLen, unsigned nTimeout/* = 0*/)
{
	if (s == (int)INVALID_SOCKET)
		return SOCKET_ERROR_DISCONNECTED;
  40fa4d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  40fa52:	c3                   	retq   
  40fa53:	f3 c3                	repz retq 
  40fa55:	90                   	nop
  40fa56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40fa5d:	00 00 00 

000000000040fa60 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj>:
///////////////////////////////////////////////////////////////////////////////////////////////////

int 
BaseSocket::nbWrite(int s, const char* pData, unsigned &nLen, unsigned nTimeout /*= 0*/)
{
	if (s == (int)INVALID_SOCKET)
  40fa60:	83 ff ff             	cmp    $0xffffffff,%edi
  40fa63:	0f 84 c0 01 00 00    	je     40fc29 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x1c9>
		return SOCKET_ERROR_DISCONNECTED;

	if ((!pData) || (nLen == 0))
  40fa69:	48 85 f6             	test   %rsi,%rsi
		return SOCKET_ERROR_PARAM;
  40fa6c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
BaseSocket::nbWrite(int s, const char* pData, unsigned &nLen, unsigned nTimeout /*= 0*/)
{
	if (s == (int)INVALID_SOCKET)
		return SOCKET_ERROR_DISCONNECTED;

	if ((!pData) || (nLen == 0))
  40fa71:	0f 84 b8 01 00 00    	je     40fc2f <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x1cf>
  40fa77:	44 8b 02             	mov    (%rdx),%r8d
  40fa7a:	45 85 c0             	test   %r8d,%r8d
  40fa7d:	0f 84 9c 00 00 00    	je     40fb1f <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xbf>

///////////////////////////////////////////////////////////////////////////////////////////////////

int 
BaseSocket::nbWrite(int s, const char* pData, unsigned &nLen, unsigned nTimeout /*= 0*/)
{
  40fa83:	41 57                	push   %r15
  40fa85:	41 56                	push   %r14
  40fa87:	49 89 f7             	mov    %rsi,%r15
  40fa8a:	41 55                	push   %r13
  40fa8c:	41 54                	push   %r12
  40fa8e:	41 89 fd             	mov    %edi,%r13d
  40fa91:	55                   	push   %rbp
  40fa92:	53                   	push   %rbx
		return SOCKET_ERROR_PARAM;

	int iSend = 0;
	unsigned nSend = 0;

	time_t begin = time(NULL);
  40fa93:	31 ff                	xor    %edi,%edi
  40fa95:	48 89 d5             	mov    %rdx,%rbp

	if ((!pData) || (nLen == 0))
		return SOCKET_ERROR_PARAM;

	int iSend = 0;
	unsigned nSend = 0;
  40fa98:	31 db                	xor    %ebx,%ebx

///////////////////////////////////////////////////////////////////////////////////////////////////

int 
BaseSocket::nbWrite(int s, const char* pData, unsigned &nLen, unsigned nTimeout /*= 0*/)
{
  40fa9a:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  40faa1:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
  40faa5:	4c 8d 64 24 50       	lea    0x50(%rsp),%r12
		return SOCKET_ERROR_PARAM;

	int iSend = 0;
	unsigned nSend = 0;

	time_t begin = time(NULL);
  40faaa:	e8 f1 47 ff ff       	callq  4042a0 <time@plt>
  40faaf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40fab4:	44 89 e8             	mov    %r13d,%eax
  40fab7:	c1 f8 1f             	sar    $0x1f,%eax
  40faba:	c1 e8 1a             	shr    $0x1a,%eax
  40fabd:	41 8d 4c 05 00       	lea    0x0(%r13,%rax,1),%ecx
  40fac2:	83 e1 3f             	and    $0x3f,%ecx
  40fac5:	29 c1                	sub    %eax,%ecx
  40fac7:	b8 01 00 00 00       	mov    $0x1,%eax
  40facc:	48 d3 e0             	shl    %cl,%rax
  40facf:	49 89 c6             	mov    %rax,%r14
  40fad2:	49 63 c5             	movslq %r13d,%rax
  40fad5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40fada:	41 8d 45 01          	lea    0x1(%r13),%eax
  40fade:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
  40fae2:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  40fae7:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	do
	{
#if defined(WIN32)
		iSend = send(s, pData + nSend, nLen - nSend, 0);
#else
		iSend = write(s, pData + nSend, nLen - nSend);
  40faec:	8b 55 00             	mov    0x0(%rbp),%edx
  40faef:	89 de                	mov    %ebx,%esi
  40faf1:	44 89 ef             	mov    %r13d,%edi
  40faf4:	4c 01 fe             	add    %r15,%rsi
  40faf7:	29 da                	sub    %ebx,%edx
  40faf9:	e8 72 46 ff ff       	callq  404170 <write@plt>
#endif
		
		if (iSend > 0)
  40fafe:	85 c0                	test   %eax,%eax
  40fb00:	7e 46                	jle    40fb48 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xe8>
		{
			nSend += iSend;
  40fb02:	01 c3                	add    %eax,%ebx
						return SOCKET_ERROR_DISCONNECTED;
					}
				} while ((unsigned)(time(NULL) - begin) < nTimeout);
			}
		}
	} while ((nSend < nLen) && ((unsigned)(time(NULL) - begin) < nTimeout));
  40fb04:	3b 5d 00             	cmp    0x0(%rbp),%ebx
  40fb07:	72 1f                	jb     40fb28 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xc8>

	if (nSend < nLen)
		return SOCKET_ERROR_TIMEOUT;

	nLen = nSend;
  40fb09:	89 5d 00             	mov    %ebx,0x0(%rbp)

	return SOCKET_ERROR_OK;
  40fb0c:	31 c0                	xor    %eax,%eax
}
  40fb0e:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
  40fb15:	5b                   	pop    %rbx
  40fb16:	5d                   	pop    %rbp
  40fb17:	41 5c                	pop    %r12
  40fb19:	41 5d                	pop    %r13
  40fb1b:	41 5e                	pop    %r14
  40fb1d:	41 5f                	pop    %r15
  40fb1f:	f3 c3                	repz retq 
  40fb21:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
						return SOCKET_ERROR_DISCONNECTED;
					}
				} while ((unsigned)(time(NULL) - begin) < nTimeout);
			}
		}
	} while ((nSend < nLen) && ((unsigned)(time(NULL) - begin) < nTimeout));
  40fb28:	31 ff                	xor    %edi,%edi
  40fb2a:	e8 71 47 ff ff       	callq  4042a0 <time@plt>
  40fb2f:	2b 44 24 08          	sub    0x8(%rsp),%eax
  40fb33:	3b 44 24 18          	cmp    0x18(%rsp),%eax
  40fb37:	72 b3                	jb     40faec <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x8c>

	if (nSend < nLen)
  40fb39:	3b 5d 00             	cmp    0x0(%rbp),%ebx
		return SOCKET_ERROR_TIMEOUT;
  40fb3c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
				} while ((unsigned)(time(NULL) - begin) < nTimeout);
			}
		}
	} while ((nSend < nLen) && ((unsigned)(time(NULL) - begin) < nTimeout));

	if (nSend < nLen)
  40fb41:	73 c6                	jae    40fb09 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xa9>
  40fb43:	eb c9                	jmp    40fb0e <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xae>
  40fb45:	0f 1f 00             	nopl   (%rax)
		
		if (iSend > 0)
		{
			nSend += iSend;
		}
		else if (iSend == SOCKET_ERROR)
  40fb48:	83 f8 ff             	cmp    $0xffffffff,%eax
  40fb4b:	75 b7                	jne    40fb04 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xa4>
		{
			int ret = getError();
  40fb4d:	e8 ce fa ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
			if (ret != EWOULDBLOCK)
  40fb52:	83 f8 0b             	cmp    $0xb,%eax
  40fb55:	0f 85 c4 00 00 00    	jne    40fc1f <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x1bf>
			}
			else
			{
				do
				{
					FD_ZERO(fds);
  40fb5b:	89 5c 24 28          	mov    %ebx,0x28(%rsp)
  40fb5f:	44 89 6c 24 2c       	mov    %r13d,0x2c(%rsp)
  40fb64:	4c 89 7c 24 30       	mov    %r15,0x30(%rsp)
  40fb69:	48 89 6c 24 38       	mov    %rbp,0x38(%rsp)
  40fb6e:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
  40fb73:	4c 8b 6c 24 20       	mov    0x20(%rsp),%r13
  40fb78:	8b 6c 24 1c          	mov    0x1c(%rsp),%ebp
  40fb7c:	44 8b 7c 24 18       	mov    0x18(%rsp),%r15d
  40fb81:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40fb88:	b9 10 00 00 00       	mov    $0x10,%ecx
  40fb8d:	4c 89 e7             	mov    %r12,%rdi
  40fb90:	31 c0                	xor    %eax,%eax
  40fb92:	fc                   	cld    
  40fb93:	f3 48 ab             	rep stos %rax,%es:(%rdi)
					FD_SET(s, fds);
  40fb96:	48 89 df             	mov    %rbx,%rdi
  40fb99:	e8 f2 46 ff ff       	callq  404290 <__fdelt_chk@plt>

					timeval timeout;
					timeout.tv_sec = SOCKET_TIMEOUT_SELECT;
					timeout.tv_usec = 0;

					iRes = select(s+1, NULL, fds, NULL, &timeout);
  40fb9e:	31 c9                	xor    %ecx,%ecx
  40fba0:	31 f6                	xor    %esi,%esi
  40fba2:	4d 89 e8             	mov    %r13,%r8
  40fba5:	4c 89 e2             	mov    %r12,%rdx
  40fba8:	89 ef                	mov    %ebp,%edi
			else
			{
				do
				{
					FD_ZERO(fds);
					FD_SET(s, fds);
  40fbaa:	4c 09 74 c4 50       	or     %r14,0x50(%rsp,%rax,8)

					timeval timeout;
					timeout.tv_sec = SOCKET_TIMEOUT_SELECT;
  40fbaf:	48 c7 44 24 40 05 00 	movq   $0x5,0x40(%rsp)
  40fbb6:	00 00 
					timeout.tv_usec = 0;
  40fbb8:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  40fbbf:	00 00 

					iRes = select(s+1, NULL, fds, NULL, &timeout);
  40fbc1:	e8 fa 3f ff ff       	callq  403bc0 <select@plt>
					if (iRes == 1)
  40fbc6:	83 f8 01             	cmp    $0x1,%eax
  40fbc9:	74 35                	je     40fc00 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x1a0>
					{
						if (FD_ISSET(s, fds))
							break;
					}
					else if (iRes == SOCKET_ERROR)
  40fbcb:	83 f8 ff             	cmp    $0xffffffff,%eax
  40fbce:	74 48                	je     40fc18 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x1b8>
					{
						return SOCKET_ERROR_DISCONNECTED;
					}
				} while ((unsigned)(time(NULL) - begin) < nTimeout);
  40fbd0:	31 ff                	xor    %edi,%edi
  40fbd2:	e8 c9 46 ff ff       	callq  4042a0 <time@plt>
  40fbd7:	2b 44 24 08          	sub    0x8(%rsp),%eax
			{
				return SOCKET_TIMEOUT_SELECT;
			}
			else
			{
				do
  40fbdb:	41 39 c7             	cmp    %eax,%r15d
  40fbde:	77 a8                	ja     40fb88 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x128>
  40fbe0:	8b 5c 24 28          	mov    0x28(%rsp),%ebx
  40fbe4:	44 8b 6c 24 2c       	mov    0x2c(%rsp),%r13d
  40fbe9:	4c 8b 7c 24 30       	mov    0x30(%rsp),%r15
  40fbee:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
  40fbf3:	e9 0c ff ff ff       	jmpq   40fb04 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xa4>
  40fbf8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40fbff:	00 
					timeout.tv_usec = 0;

					iRes = select(s+1, NULL, fds, NULL, &timeout);
					if (iRes == 1)
					{
						if (FD_ISSET(s, fds))
  40fc00:	48 89 df             	mov    %rbx,%rdi
  40fc03:	e8 88 46 ff ff       	callq  404290 <__fdelt_chk@plt>
  40fc08:	4c 85 74 c4 50       	test   %r14,0x50(%rsp,%rax,8)
  40fc0d:	74 c1                	je     40fbd0 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x170>
  40fc0f:	eb cf                	jmp    40fbe0 <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0x180>
  40fc11:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
							break;
					}
					else if (iRes == SOCKET_ERROR)
					{
						return SOCKET_ERROR_DISCONNECTED;
  40fc18:	b0 fd                	mov    $0xfd,%al
  40fc1a:	e9 ef fe ff ff       	jmpq   40fb0e <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xae>
		else if (iSend == SOCKET_ERROR)
		{
			int ret = getError();
			if (ret != EWOULDBLOCK)
			{
				return SOCKET_TIMEOUT_SELECT;
  40fc1f:	b8 05 00 00 00       	mov    $0x5,%eax
  40fc24:	e9 e5 fe ff ff       	jmpq   40fb0e <_ZN6rocket10BaseSocket7nbWriteEiPKcRjj+0xae>

int 
BaseSocket::nbWrite(int s, const char* pData, unsigned &nLen, unsigned nTimeout /*= 0*/)
{
	if (s == (int)INVALID_SOCKET)
		return SOCKET_ERROR_DISCONNECTED;
  40fc29:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return SOCKET_ERROR_TIMEOUT;

	nLen = nSend;

	return SOCKET_ERROR_OK;
}
  40fc2e:	c3                   	retq   
  40fc2f:	f3 c3                	repz retq 
  40fc31:	90                   	nop
  40fc32:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40fc39:	1f 84 00 00 00 00 00 

000000000040fc40 <_ZN6rocket10BaseSocket11connectByIPEiiPKc>:
  return result == 0 || nonFatalError();
}

bool 
BaseSocket::connectByIP(int socket, int port, const char* pIP)
{
  40fc40:	41 54                	push   %r12
  40fc42:	55                   	push   %rbp
  40fc43:	53                   	push   %rbx
  40fc44:	48 83 ec 20          	sub    $0x20,%rsp
  40fc48:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40fc4f:	00 00 
  40fc51:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40fc56:	31 c0                	xor    %eax,%eax
	if ( NULL == pIP )
  40fc58:	48 85 d2             	test   %rdx,%rdx
  40fc5b:	74 6b                	je     40fcc8 <_ZN6rocket10BaseSocket11connectByIPEiiPKc+0x88>
  40fc5d:	89 fd                	mov    %edi,%ebp
		return false;

	struct sockaddr_in saddr;
	memset(&saddr, 0, sizeof(saddr));
	saddr.sin_family = AF_INET;
  40fc5f:	b8 02 00 00 00       	mov    $0x2,%eax
	saddr.sin_addr.s_addr = inet_addr(pIP);
  40fc64:	48 89 d7             	mov    %rdx,%rdi
  40fc67:	89 f3                	mov    %esi,%ebx
  40fc69:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40fc70:	00 
  40fc71:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  40fc78:	00 00 
	if ( NULL == pIP )
		return false;

	struct sockaddr_in saddr;
	memset(&saddr, 0, sizeof(saddr));
	saddr.sin_family = AF_INET;
  40fc7a:	66 89 04 24          	mov    %ax,(%rsp)
	saddr.sin_addr.s_addr = inet_addr(pIP);
  40fc7e:	e8 3d 46 ff ff       	callq  4042c0 <inet_addr@plt>
	saddr.sin_port = htons((u_short) port);

	// For asynch operation, this will return EWOULDBLOCK (windows) or
	// EINPROGRESS (linux) and we just need to wait for the socket to be writable...
	int result = ::connect(socket, (struct sockaddr *)&saddr, sizeof(saddr));
  40fc83:	ba 10 00 00 00       	mov    $0x10,%edx
  40fc88:	48 89 e6             	mov    %rsp,%rsi
  40fc8b:	89 ef                	mov    %ebp,%edi
		return false;

	struct sockaddr_in saddr;
	memset(&saddr, 0, sizeof(saddr));
	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = inet_addr(pIP);
  40fc8d:	89 44 24 04          	mov    %eax,0x4(%rsp)
	saddr.sin_port = htons((u_short) port);
  40fc91:	89 d8                	mov    %ebx,%eax
  40fc93:	66 c1 c8 08          	ror    $0x8,%ax
  40fc97:	66 89 44 24 02       	mov    %ax,0x2(%rsp)

	// For asynch operation, this will return EWOULDBLOCK (windows) or
	// EINPROGRESS (linux) and we just need to wait for the socket to be writable...
	int result = ::connect(socket, (struct sockaddr *)&saddr, sizeof(saddr));
  40fc9c:	e8 cf 41 ff ff       	callq  403e70 <connect@plt>
	return result == 0 || nonFatalError();
  40fca1:	85 c0                	test   %eax,%eax
  40fca3:	ba 01 00 00 00       	mov    $0x1,%edx
  40fca8:	75 26                	jne    40fcd0 <_ZN6rocket10BaseSocket11connectByIPEiiPKc+0x90>
}
  40fcaa:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  40fcaf:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  40fcb6:	00 00 
  40fcb8:	89 d0                	mov    %edx,%eax
  40fcba:	75 35                	jne    40fcf1 <_ZN6rocket10BaseSocket11connectByIPEiiPKc+0xb1>
  40fcbc:	48 83 c4 20          	add    $0x20,%rsp
  40fcc0:	5b                   	pop    %rbx
  40fcc1:	5d                   	pop    %rbp
  40fcc2:	41 5c                	pop    %r12
  40fcc4:	c3                   	retq   
  40fcc5:	0f 1f 00             	nopl   (%rax)

bool 
BaseSocket::connectByIP(int socket, int port, const char* pIP)
{
	if ( NULL == pIP )
		return false;
  40fcc8:	31 d2                	xor    %edx,%edx
  40fcca:	eb de                	jmp    40fcaa <_ZN6rocket10BaseSocket11connectByIPEiiPKc+0x6a>
  40fccc:	0f 1f 40 00          	nopl   0x0(%rax)

// These errors are not considered fatal for an IO operation; the operation will be re-tried.
static inline bool
nonFatalError()
{
  int err = BaseSocket::getError();
  40fcd0:	e8 4b f9 ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
  return (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
  40fcd5:	83 f8 73             	cmp    $0x73,%eax
  40fcd8:	0f 94 c1             	sete   %cl
  40fcdb:	83 f8 0b             	cmp    $0xb,%eax
  40fcde:	0f 94 c2             	sete   %dl
  40fce1:	08 ca                	or     %cl,%dl
  40fce3:	75 c5                	jne    40fcaa <_ZN6rocket10BaseSocket11connectByIPEiiPKc+0x6a>
  40fce5:	83 f8 04             	cmp    $0x4,%eax
  40fce8:	75 de                	jne    40fcc8 <_ZN6rocket10BaseSocket11connectByIPEiiPKc+0x88>
	saddr.sin_port = htons((u_short) port);

	// For asynch operation, this will return EWOULDBLOCK (windows) or
	// EINPROGRESS (linux) and we just need to wait for the socket to be writable...
	int result = ::connect(socket, (struct sockaddr *)&saddr, sizeof(saddr));
	return result == 0 || nonFatalError();
  40fcea:	ba 01 00 00 00       	mov    $0x1,%edx
  40fcef:	eb b9                	jmp    40fcaa <_ZN6rocket10BaseSocket11connectByIPEiiPKc+0x6a>
}
  40fcf1:	e8 5a 42 ff ff       	callq  403f50 <__stack_chk_fail@plt>
  40fcf6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40fcfd:	00 00 00 

000000000040fd00 <_ZN6rocket10BaseSocket7nbWriteEiRSsPi>:


// Write text to the specified socket. Returns false on error.
bool 
BaseSocket::nbWrite(int fd, std::string& s, int *bytesSoFar)
{
  40fd00:	41 55                	push   %r13
  40fd02:	41 54                	push   %r12
  40fd04:	41 89 fd             	mov    %edi,%r13d
  40fd07:	55                   	push   %rbp
  40fd08:	53                   	push   %rbx
  40fd09:	49 89 d4             	mov    %rdx,%r12
  40fd0c:	48 83 ec 08          	sub    $0x8,%rsp
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }
  40fd10:	48 8b 2e             	mov    (%rsi),%rbp
  int nToWrite = int(s.length()) - *bytesSoFar;
  40fd13:	48 63 02             	movslq (%rdx),%rax
  char *sp = const_cast<char*>(s.c_str()) + *bytesSoFar;
  bool wouldBlock = false;
  40fd16:	31 d2                	xor    %edx,%edx

// Write text to the specified socket. Returns false on error.
bool 
BaseSocket::nbWrite(int fd, std::string& s, int *bytesSoFar)
{
  int nToWrite = int(s.length()) - *bytesSoFar;
  40fd18:	8b 5d e8             	mov    -0x18(%rbp),%ebx
  char *sp = const_cast<char*>(s.c_str()) + *bytesSoFar;
  40fd1b:	48 01 c5             	add    %rax,%rbp

// Write text to the specified socket. Returns false on error.
bool 
BaseSocket::nbWrite(int fd, std::string& s, int *bytesSoFar)
{
  int nToWrite = int(s.length()) - *bytesSoFar;
  40fd1e:	29 c3                	sub    %eax,%ebx
  char *sp = const_cast<char*>(s.c_str()) + *bytesSoFar;
  bool wouldBlock = false;

  while ( nToWrite > 0 && ! wouldBlock ) {
  40fd20:	eb 14                	jmp    40fd36 <_ZN6rocket10BaseSocket7nbWriteEiRSsPi+0x36>
  40fd22:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    int n = write(fd, sp, nToWrite);
#endif
	
    if (n > 0) {
      sp += n;
      *bytesSoFar += n;
  40fd28:	41 01 04 24          	add    %eax,(%r12)
#else
    int n = write(fd, sp, nToWrite);
#endif
	
    if (n > 0) {
      sp += n;
  40fd2c:	48 63 d0             	movslq %eax,%rdx
      *bytesSoFar += n;
      nToWrite -= n;
  40fd2f:	29 c3                	sub    %eax,%ebx
#else
    int n = write(fd, sp, nToWrite);
#endif
	
    if (n > 0) {
      sp += n;
  40fd31:	48 01 d5             	add    %rdx,%rbp
  40fd34:	31 d2                	xor    %edx,%edx
{
  int nToWrite = int(s.length()) - *bytesSoFar;
  char *sp = const_cast<char*>(s.c_str()) + *bytesSoFar;
  bool wouldBlock = false;

  while ( nToWrite > 0 && ! wouldBlock ) {
  40fd36:	85 db                	test   %ebx,%ebx
  40fd38:	0f 9f c0             	setg   %al
  40fd3b:	38 c2                	cmp    %al,%dl
  40fd3d:	73 51                	jae    40fd90 <_ZN6rocket10BaseSocket7nbWriteEiRSsPi+0x90>
#if defined(WIN32)
    int n = send(fd, sp, nToWrite, 0);
#else
    int n = write(fd, sp, nToWrite);
  40fd3f:	48 63 d3             	movslq %ebx,%rdx
  40fd42:	48 89 ee             	mov    %rbp,%rsi
  40fd45:	44 89 ef             	mov    %r13d,%edi
  40fd48:	e8 23 44 ff ff       	callq  404170 <write@plt>
#endif
	
    if (n > 0) {
  40fd4d:	85 c0                	test   %eax,%eax
  40fd4f:	7f d7                	jg     40fd28 <_ZN6rocket10BaseSocket7nbWriteEiRSsPi+0x28>

// These errors are not considered fatal for an IO operation; the operation will be re-tried.
static inline bool
nonFatalError()
{
  int err = BaseSocket::getError();
  40fd51:	e8 ca f8 ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
  return (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
  40fd56:	83 f8 73             	cmp    $0x73,%eax
  40fd59:	0f 94 c1             	sete   %cl
  40fd5c:	83 f8 0b             	cmp    $0xb,%eax
  40fd5f:	0f 94 c2             	sete   %dl
  40fd62:	08 ca                	or     %cl,%dl
  40fd64:	75 1a                	jne    40fd80 <_ZN6rocket10BaseSocket7nbWriteEiRSsPi+0x80>
  40fd66:	83 f8 04             	cmp    $0x4,%eax
  40fd69:	74 15                	je     40fd80 <_ZN6rocket10BaseSocket7nbWriteEiRSsPi+0x80>
    } else {
      return false;   // Error
    }
  }
  return true;
}
  40fd6b:	48 83 c4 08          	add    $0x8,%rsp
  40fd6f:	89 d0                	mov    %edx,%eax
  40fd71:	5b                   	pop    %rbx
  40fd72:	5d                   	pop    %rbp
  40fd73:	41 5c                	pop    %r12
  40fd75:	41 5d                	pop    %r13
  40fd77:	c3                   	retq   
  40fd78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40fd7f:	00 
{
  int nToWrite = int(s.length()) - *bytesSoFar;
  char *sp = const_cast<char*>(s.c_str()) + *bytesSoFar;
  bool wouldBlock = false;

  while ( nToWrite > 0 && ! wouldBlock ) {
  40fd80:	85 db                	test   %ebx,%ebx
    if (n > 0) {
      sp += n;
      *bytesSoFar += n;
      nToWrite -= n;
    } else if (nonFatalError()) {
      wouldBlock = true;
  40fd82:	ba 01 00 00 00       	mov    $0x1,%edx
{
  int nToWrite = int(s.length()) - *bytesSoFar;
  char *sp = const_cast<char*>(s.c_str()) + *bytesSoFar;
  bool wouldBlock = false;

  while ( nToWrite > 0 && ! wouldBlock ) {
  40fd87:	0f 9f c0             	setg   %al
  40fd8a:	38 c2                	cmp    %al,%dl
  40fd8c:	72 b1                	jb     40fd3f <_ZN6rocket10BaseSocket7nbWriteEiRSsPi+0x3f>
  40fd8e:	66 90                	xchg   %ax,%ax
    } else {
      return false;   // Error
    }
  }
  return true;
}
  40fd90:	48 83 c4 08          	add    $0x8,%rsp
      wouldBlock = true;
    } else {
      return false;   // Error
    }
  }
  return true;
  40fd94:	ba 01 00 00 00       	mov    $0x1,%edx
}
  40fd99:	5b                   	pop    %rbx
  40fd9a:	89 d0                	mov    %edx,%eax
  40fd9c:	5d                   	pop    %rbp
  40fd9d:	41 5c                	pop    %r12
  40fd9f:	41 5d                	pop    %r13
  40fda1:	c3                   	retq   
  40fda2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40fda9:	1f 84 00 00 00 00 00 

000000000040fdb0 <_ZN6rocket10BaseSocket6nbReadEiRSsRb>:
}

// Read available text from the specified socket. Returns false on error.
bool 
BaseSocket::nbRead(int fd, std::string& s, bool& eof)
{
  40fdb0:	41 56                	push   %r14
  40fdb2:	41 55                	push   %r13
  40fdb4:	49 89 f6             	mov    %rsi,%r14
  40fdb7:	41 54                	push   %r12
  40fdb9:	55                   	push   %rbp
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40fdba:	48 8d 35 06 15 00 00 	lea    0x1506(%rip),%rsi        # 4112c7 <_ZTSSt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS2_EE+0x47>
  40fdc1:	53                   	push   %rbx
  40fdc2:	89 fd                	mov    %edi,%ebp
  40fdc4:	49 89 d4             	mov    %rdx,%r12
  40fdc7:	ba 0c 00 00 00       	mov    $0xc,%edx
  40fdcc:	48 81 ec 10 10 00 00 	sub    $0x1010,%rsp
  40fdd3:	4c 8b 2d 46 41 20 00 	mov    0x204146(%rip),%r13        # 613f20 <_DYNAMIC+0x298>
  40fdda:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40fde1:	00 00 
  40fde3:	48 89 84 24 08 10 00 	mov    %rax,0x1008(%rsp)
  40fdea:	00 
  40fdeb:	31 c0                	xor    %eax,%eax
  40fded:	4c 89 ef             	mov    %r13,%rdi
  40fdf0:	e8 ab 40 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40fdf5:	49 8b 45 00          	mov    0x0(%r13),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40fdf9:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40fdfd:	4a 8b 9c 28 f0 00 00 	mov    0xf0(%rax,%r13,1),%rbx
  40fe04:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40fe05:	48 85 db             	test   %rbx,%rbx
  40fe08:	0f 84 85 01 00 00    	je     40ff93 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x1e3>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40fe0e:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  40fe12:	0f 84 10 01 00 00    	je     40ff28 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x178>
  40fe18:	0f be 73 43          	movsbl 0x43(%rbx),%esi
  40fe1c:	4c 89 ef             	mov    %r13,%rdi
  40fe1f:	48 89 e3             	mov    %rsp,%rbx
  40fe22:	e8 b9 43 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40fe27:	48 89 c7             	mov    %rax,%rdi
  40fe2a:	e8 01 41 ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
	std::cout << "nbRead begin" << std::endl;
	const int READ_SIZE = 4096;   // Number of bytes to attempt to read at a time
	char readBuf[READ_SIZE];

	bool wouldBlock = false;
	eof = false;
  40fe2f:	41 c6 04 24 00       	movb   $0x0,(%r12)
  40fe34:	0f 1f 40 00          	nopl   0x0(%rax)
  40fe38:	ba ff 0f 00 00       	mov    $0xfff,%edx
  40fe3d:	48 89 de             	mov    %rbx,%rsi
  40fe40:	89 ef                	mov    %ebp,%edi
  40fe42:	e8 f9 3d ff ff       	callq  403c40 <read@plt>
		int n = recv(fd, readBuf, READ_SIZE-1, 0);
	#else
		int n = read(fd, readBuf, READ_SIZE-1);
	#endif

		if (n > 0) {
  40fe47:	83 f8 00             	cmp    $0x0,%eax
  40fe4a:	0f 8e a0 00 00 00    	jle    40fef0 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x140>
			readBuf[n] = 0;
  40fe50:	48 63 d0             	movslq %eax,%rdx
		  	s.append(readBuf, n);
  40fe53:	48 89 de             	mov    %rbx,%rsi
  40fe56:	4c 89 f7             	mov    %r14,%rdi
	#else
		int n = read(fd, readBuf, READ_SIZE-1);
	#endif

		if (n > 0) {
			readBuf[n] = 0;
  40fe59:	c6 04 14 00          	movb   $0x0,(%rsp,%rdx,1)
		  	s.append(readBuf, n);
  40fe5d:	e8 ee 3b ff ff       	callq  403a50 <_ZNSs6appendEPKcm@plt>
	char readBuf[READ_SIZE];

	bool wouldBlock = false;
	eof = false;

	while ( !wouldBlock && !eof) {
  40fe62:	41 80 3c 24 00       	cmpb   $0x0,(%r12)
  40fe67:	74 cf                	je     40fe38 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x88>
  40fe69:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40fe70:	48 8d 35 5d 14 00 00 	lea    0x145d(%rip),%rsi        # 4112d4 <_ZTSSt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS2_EE+0x54>
  40fe77:	ba 0a 00 00 00       	mov    $0xa,%edx
  40fe7c:	4c 89 ef             	mov    %r13,%rdi
  40fe7f:	e8 1c 40 ff ff       	callq  403ea0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40fe84:	49 8b 45 00          	mov    0x0(%r13),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40fe88:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  40fe8c:	4a 8b 9c 28 f0 00 00 	mov    0xf0(%rax,%r13,1),%rbx
  40fe93:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40fe94:	48 85 db             	test   %rbx,%rbx
  40fe97:	0f 84 f6 00 00 00    	je     40ff93 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x1e3>
  40fe9d:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  40fea1:	0f 84 b9 00 00 00    	je     40ff60 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x1b0>
  40fea7:	0f be 73 43          	movsbl 0x43(%rbx),%esi
  40feab:	4c 89 ef             	mov    %r13,%rdi
  40feae:	e8 2d 43 ff ff       	callq  4041e0 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40feb3:	48 89 c7             	mov    %rax,%rdi
  40feb6:	e8 75 40 ff ff       	callq  403f30 <_ZNSo5flushEv@plt>
		} else {
		  	return false;   // Error
		}
	}
	std::cout << "nbRead end" << std::endl;
	return true;
  40febb:	ba 01 00 00 00       	mov    $0x1,%edx
}
  40fec0:	48 8b 8c 24 08 10 00 	mov    0x1008(%rsp),%rcx
  40fec7:	00 
  40fec8:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  40fecf:	00 00 
  40fed1:	89 d0                	mov    %edx,%eax
  40fed3:	0f 85 b5 00 00 00    	jne    40ff8e <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x1de>
  40fed9:	48 81 c4 10 10 00 00 	add    $0x1010,%rsp
  40fee0:	5b                   	pop    %rbx
  40fee1:	5d                   	pop    %rbp
  40fee2:	41 5c                	pop    %r12
  40fee4:	41 5d                	pop    %r13
  40fee6:	41 5e                	pop    %r14
  40fee8:	c3                   	retq   
  40fee9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	#endif

		if (n > 0) {
			readBuf[n] = 0;
		  	s.append(readBuf, n);
		} else if (n == 0) {
  40fef0:	75 0e                	jne    40ff00 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x150>
		  	eof = true;
  40fef2:	41 c6 04 24 01       	movb   $0x1,(%r12)
  40fef7:	e9 74 ff ff ff       	jmpq   40fe70 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0xc0>
  40fefc:	0f 1f 40 00          	nopl   0x0(%rax)

// These errors are not considered fatal for an IO operation; the operation will be re-tried.
static inline bool
nonFatalError()
{
  int err = BaseSocket::getError();
  40ff00:	e8 1b f7 ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
  return (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
  40ff05:	83 f8 73             	cmp    $0x73,%eax
  40ff08:	0f 94 c1             	sete   %cl
  40ff0b:	83 f8 0b             	cmp    $0xb,%eax
  40ff0e:	0f 94 c2             	sete   %dl
  40ff11:	08 ca                	or     %cl,%dl
  40ff13:	0f 85 57 ff ff ff    	jne    40fe70 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0xc0>
  40ff19:	83 f8 04             	cmp    $0x4,%eax
  40ff1c:	75 a2                	jne    40fec0 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x110>
  40ff1e:	e9 4d ff ff ff       	jmpq   40fe70 <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0xc0>
  40ff23:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40ff28:	48 89 df             	mov    %rbx,%rdi
  40ff2b:	e8 c0 3c ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40ff30:	48 8b 03             	mov    (%rbx),%rax
  40ff33:	be 0a 00 00 00       	mov    $0xa,%esi
  40ff38:	48 8b 40 30          	mov    0x30(%rax),%rax
  40ff3c:	48 3b 05 4d 40 20 00 	cmp    0x20404d(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40ff43:	0f 84 d3 fe ff ff    	je     40fe1c <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x6c>
  40ff49:	48 89 df             	mov    %rbx,%rdi
  40ff4c:	ff d0                	callq  *%rax
  40ff4e:	0f be f0             	movsbl %al,%esi
  40ff51:	e9 c6 fe ff ff       	jmpq   40fe1c <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0x6c>
  40ff56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40ff5d:	00 00 00 
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  40ff60:	48 89 df             	mov    %rbx,%rdi
  40ff63:	e8 88 3c ff ff       	callq  403bf0 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40ff68:	48 8b 03             	mov    (%rbx),%rax
  40ff6b:	be 0a 00 00 00       	mov    $0xa,%esi
  40ff70:	48 8b 40 30          	mov    0x30(%rax),%rax
  40ff74:	48 3b 05 15 40 20 00 	cmp    0x204015(%rip),%rax        # 613f90 <_DYNAMIC+0x308>
  40ff7b:	0f 84 2a ff ff ff    	je     40feab <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0xfb>
  40ff81:	48 89 df             	mov    %rbx,%rdi
  40ff84:	ff d0                	callq  *%rax
  40ff86:	0f be f0             	movsbl %al,%esi
  40ff89:	e9 1d ff ff ff       	jmpq   40feab <_ZN6rocket10BaseSocket6nbReadEiRSsRb+0xfb>
		  	return false;   // Error
		}
	}
	std::cout << "nbRead end" << std::endl;
	return true;
}
  40ff8e:	e8 bd 3f ff ff       	callq  403f50 <__stack_chk_fail@plt>
	__throw_bad_cast();
  40ff93:	e8 48 3b ff ff       	callq  403ae0 <_ZSt16__throw_bad_castv@plt>
  40ff98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40ff9f:	00 

000000000040ffa0 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs>:

   
// Connect a socket to a server (from a client)
bool
BaseSocket::connectByHostName(int fd, int port, std::string& host)
{
  40ffa0:	41 54                	push   %r12
  40ffa2:	55                   	push   %rbp
  40ffa3:	41 89 fc             	mov    %edi,%r12d
  40ffa6:	53                   	push   %rbx
  40ffa7:	89 f3                	mov    %esi,%ebx
  40ffa9:	48 83 ec 20          	sub    $0x20,%rsp
  struct sockaddr_in saddr;
  memset(&saddr, 0, sizeof(saddr));
  saddr.sin_family = AF_INET;

  struct hostent *hp = gethostbyname(host.c_str());
  40ffad:	48 8b 3a             	mov    (%rdx),%rdi

   
// Connect a socket to a server (from a client)
bool
BaseSocket::connectByHostName(int fd, int port, std::string& host)
{
  40ffb0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40ffb7:	00 00 
  40ffb9:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40ffbe:	31 c0                	xor    %eax,%eax
  struct sockaddr_in saddr;
  memset(&saddr, 0, sizeof(saddr));
  saddr.sin_family = AF_INET;
  40ffc0:	b8 02 00 00 00       	mov    $0x2,%eax
  40ffc5:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40ffcc:	00 
  40ffcd:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  40ffd4:	00 00 
  40ffd6:	66 89 04 24          	mov    %ax,(%rsp)

  struct hostent *hp = gethostbyname(host.c_str());
  40ffda:	e8 a1 3b ff ff       	callq  403b80 <gethostbyname@plt>
  if (hp == 0) return false;
  40ffdf:	48 85 c0             	test   %rax,%rax
  40ffe2:	74 64                	je     410048 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs+0xa8>

  saddr.sin_family = hp->h_addrtype;
  40ffe4:	8b 50 10             	mov    0x10(%rax),%edx

__extern_always_inline void *
__NTH (memcpy (void *__restrict __dest, __const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
  40ffe7:	48 8d 7c 24 04       	lea    0x4(%rsp),%rdi
  40ffec:	b9 0c 00 00 00       	mov    $0xc,%ecx
  40fff1:	66 89 14 24          	mov    %dx,(%rsp)
  memcpy(&saddr.sin_addr, hp->h_addr, hp->h_length);
  40fff5:	48 63 50 14          	movslq 0x14(%rax),%rdx
  40fff9:	48 8b 40 18          	mov    0x18(%rax),%rax
  40fffd:	48 8b 30             	mov    (%rax),%rsi
  410000:	e8 ab 3c ff ff       	callq  403cb0 <__memcpy_chk@plt>
  saddr.sin_port = htons((u_short) port);

  // For asynch operation, this will return EWOULDBLOCK (windows) or
  // EINPROGRESS (linux) and we just need to wait for the socket to be writable...
  int result = ::connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));
  410005:	ba 10 00 00 00       	mov    $0x10,%edx
  41000a:	48 89 e6             	mov    %rsp,%rsi
  41000d:	44 89 e7             	mov    %r12d,%edi
  struct hostent *hp = gethostbyname(host.c_str());
  if (hp == 0) return false;

  saddr.sin_family = hp->h_addrtype;
  memcpy(&saddr.sin_addr, hp->h_addr, hp->h_length);
  saddr.sin_port = htons((u_short) port);
  410010:	89 d8                	mov    %ebx,%eax
  410012:	66 c1 c8 08          	ror    $0x8,%ax
  410016:	66 89 44 24 02       	mov    %ax,0x2(%rsp)

  // For asynch operation, this will return EWOULDBLOCK (windows) or
  // EINPROGRESS (linux) and we just need to wait for the socket to be writable...
  int result = ::connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));
  41001b:	e8 50 3e ff ff       	callq  403e70 <connect@plt>
  return result == 0 || nonFatalError();
  410020:	85 c0                	test   %eax,%eax
  410022:	ba 01 00 00 00       	mov    $0x1,%edx
  410027:	75 27                	jne    410050 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs+0xb0>
}
  410029:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  41002e:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  410035:	00 00 
  410037:	89 d0                	mov    %edx,%eax
  410039:	75 36                	jne    410071 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs+0xd1>
  41003b:	48 83 c4 20          	add    $0x20,%rsp
  41003f:	5b                   	pop    %rbx
  410040:	5d                   	pop    %rbp
  410041:	41 5c                	pop    %r12
  410043:	c3                   	retq   
  410044:	0f 1f 40 00          	nopl   0x0(%rax)
  struct sockaddr_in saddr;
  memset(&saddr, 0, sizeof(saddr));
  saddr.sin_family = AF_INET;

  struct hostent *hp = gethostbyname(host.c_str());
  if (hp == 0) return false;
  410048:	31 d2                	xor    %edx,%edx
  41004a:	eb dd                	jmp    410029 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs+0x89>
  41004c:	0f 1f 40 00          	nopl   0x0(%rax)

// These errors are not considered fatal for an IO operation; the operation will be re-tried.
static inline bool
nonFatalError()
{
  int err = BaseSocket::getError();
  410050:	e8 cb f5 ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
  return (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
  410055:	83 f8 73             	cmp    $0x73,%eax
  410058:	0f 94 c1             	sete   %cl
  41005b:	83 f8 0b             	cmp    $0xb,%eax
  41005e:	0f 94 c2             	sete   %dl
  410061:	08 ca                	or     %cl,%dl
  410063:	75 c4                	jne    410029 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs+0x89>
  410065:	83 f8 04             	cmp    $0x4,%eax
  410068:	75 de                	jne    410048 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs+0xa8>
  saddr.sin_port = htons((u_short) port);

  // For asynch operation, this will return EWOULDBLOCK (windows) or
  // EINPROGRESS (linux) and we just need to wait for the socket to be writable...
  int result = ::connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));
  return result == 0 || nonFatalError();
  41006a:	ba 01 00 00 00       	mov    $0x1,%edx
  41006f:	eb b8                	jmp    410029 <_ZN6rocket10BaseSocket17connectByHostNameEiiRSs+0x89>
}
  410071:	e8 da 3e ff ff       	callq  403f50 <__stack_chk_fail@plt>
  410076:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41007d:	00 00 00 

0000000000410080 <_ZN6rocket10BaseSocket11getErrorMsgEi>:
}

// Returns message corresponding to errno... well, it should anyway
std::string 
BaseSocket::getErrorMsg(int error)
{
  410080:	55                   	push   %rbp
  410081:	53                   	push   %rbx
__extern_always_inline int
__NTH (snprintf (char *__restrict __s, size_t __n,
		 __const char *__restrict __fmt, ...))
{
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
				   __bos (__s), __fmt, __va_arg_pack ());
  410082:	4c 8d 05 56 12 00 00 	lea    0x1256(%rip),%r8        # 4112df <_ZTSSt5_BindIFSt7_Mem_fnIMN6rocket6ServerEFvvEEPS2_EE+0x5f>
  410089:	41 89 f1             	mov    %esi,%r9d
  41008c:	b9 3c 00 00 00       	mov    $0x3c,%ecx
  410091:	48 89 fb             	mov    %rdi,%rbx
  410094:	48 83 ec 68          	sub    $0x68,%rsp
  410098:	ba 01 00 00 00       	mov    $0x1,%edx
  41009d:	be 3c 00 00 00       	mov    $0x3c,%esi
  4100a2:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
  4100a7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4100ae:	00 00 
  4100b0:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  4100b5:	31 c0                	xor    %eax,%eax
  4100b7:	48 89 ef             	mov    %rbp,%rdi
  4100ba:	e8 01 40 ff ff       	callq  4040c0 <__snprintf_chk@plt>
  char err[60];
  snprintf(err,sizeof(err),"error %d", error);
  return std::string(err);
  4100bf:	48 8d 54 24 0f       	lea    0xf(%rsp),%rdx
  4100c4:	48 89 ee             	mov    %rbp,%rsi
  4100c7:	48 89 df             	mov    %rbx,%rdi
  4100ca:	e8 51 3d ff ff       	callq  403e20 <_ZNSsC1EPKcRKSaIcE@plt>
}
  4100cf:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
  4100d4:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  4100db:	00 00 
  4100dd:	75 0a                	jne    4100e9 <_ZN6rocket10BaseSocket11getErrorMsgEi+0x69>
  4100df:	48 83 c4 68          	add    $0x68,%rsp
  4100e3:	48 89 d8             	mov    %rbx,%rax
  4100e6:	5b                   	pop    %rbx
  4100e7:	5d                   	pop    %rbp
  4100e8:	c3                   	retq   
  4100e9:	e8 62 3e ff ff       	callq  403f50 <__stack_chk_fail@plt>
  4100ee:	66 90                	xchg   %ax,%ax

00000000004100f0 <_ZN6rocket10BaseSocket11getErrorMsgEv>:


// Returns message corresponding to last errno
std::string 
BaseSocket::getErrorMsg()
{
  4100f0:	53                   	push   %rbx
  4100f1:	48 89 fb             	mov    %rdi,%rbx
  return getErrorMsg(getError());
  4100f4:	e8 27 f5 ff ff       	callq  40f620 <_ZN6rocket10BaseSocket8getErrorEv>
  4100f9:	48 89 df             	mov    %rbx,%rdi
  4100fc:	89 c6                	mov    %eax,%esi
  4100fe:	e8 7d ff ff ff       	callq  410080 <_ZN6rocket10BaseSocket11getErrorMsgEi>
}
  410103:	48 89 d8             	mov    %rbx,%rax
  410106:	5b                   	pop    %rbx
  410107:	c3                   	retq   
  410108:	90                   	nop
  410109:	90                   	nop
  41010a:	90                   	nop
  41010b:	90                   	nop
  41010c:	90                   	nop
  41010d:	90                   	nop
  41010e:	90                   	nop
  41010f:	90                   	nop

0000000000410110 <_ZN6rocket10TcpWrapper16AcceptConnectionEiR11sockaddr_inPcRib>:
  410110:	41 55                	push   %r13
  410112:	41 54                	push   %r12
  410114:	89 f7                	mov    %esi,%edi
  410116:	55                   	push   %rbp
  410117:	53                   	push   %rbx
  410118:	49 89 cd             	mov    %rcx,%r13
  41011b:	4d 89 c4             	mov    %r8,%r12
  41011e:	48 83 ec 48          	sub    $0x48,%rsp
  410122:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  410129:	00 00 
  41012b:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  410130:	31 c0                	xor    %eax,%eax
  410132:	45 84 c9             	test   %r9b,%r9b
  410135:	74 69                	je     4101a0 <_ZN6rocket10TcpWrapper16AcceptConnectionEiR11sockaddr_inPcRib+0x90>
  410137:	48 8d 5c 24 10       	lea    0x10(%rsp),%rbx
  41013c:	48 8d 54 24 0c       	lea    0xc(%rsp),%rdx
  410141:	c7 44 24 0c 1c 00 00 	movl   $0x1c,0xc(%rsp)
  410148:	00 
  410149:	48 89 de             	mov    %rbx,%rsi
  41014c:	e8 6f 40 ff ff       	callq  4041c0 <accept@plt>
  410151:	85 c0                	test   %eax,%eax
  410153:	89 c5                	mov    %eax,%ebp
  410155:	78 26                	js     41017d <_ZN6rocket10TcpWrapper16AcceptConnectionEiR11sockaddr_inPcRib+0x6d>
  410157:	48 8d 73 08          	lea    0x8(%rbx),%rsi
  41015b:	b9 00 01 00 00       	mov    $0x100,%ecx
  410160:	4c 89 ea             	mov    %r13,%rdx
  410163:	bf 0a 00 00 00       	mov    $0xa,%edi
  410168:	e8 93 40 ff ff       	callq  404200 <inet_ntop@plt>
  41016d:	0f b7 44 24 12       	movzwl 0x12(%rsp),%eax
  410172:	66 c1 c8 08          	ror    $0x8,%ax
  410176:	0f b7 c0             	movzwl %ax,%eax
  410179:	41 89 04 24          	mov    %eax,(%r12)
  41017d:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
  410182:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  410189:	00 00 
  41018b:	89 e8                	mov    %ebp,%eax
  41018d:	75 65                	jne    4101f4 <_ZN6rocket10TcpWrapper16AcceptConnectionEiR11sockaddr_inPcRib+0xe4>
  41018f:	48 83 c4 48          	add    $0x48,%rsp
  410193:	5b                   	pop    %rbx
  410194:	5d                   	pop    %rbp
  410195:	41 5c                	pop    %r12
  410197:	41 5d                	pop    %r13
  410199:	c3                   	retq   
  41019a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4101a0:	48 89 d3             	mov    %rdx,%rbx
  4101a3:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  4101aa:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  4101b1:	00 
  4101b2:	48 8d 54 24 0c       	lea    0xc(%rsp),%rdx
  4101b7:	48 89 de             	mov    %rbx,%rsi
  4101ba:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%rsp)
  4101c1:	00 
  4101c2:	e8 f9 3f ff ff       	callq  4041c0 <accept@plt>
  4101c7:	85 c0                	test   %eax,%eax
  4101c9:	89 c5                	mov    %eax,%ebp
  4101cb:	78 b0                	js     41017d <_ZN6rocket10TcpWrapper16AcceptConnectionEiR11sockaddr_inPcRib+0x6d>
  4101cd:	48 8d 73 04          	lea    0x4(%rbx),%rsi
  4101d1:	b9 00 01 00 00       	mov    $0x100,%ecx
  4101d6:	4c 89 ea             	mov    %r13,%rdx
  4101d9:	bf 02 00 00 00       	mov    $0x2,%edi
  4101de:	e8 1d 40 ff ff       	callq  404200 <inet_ntop@plt>
  4101e3:	0f b7 43 02          	movzwl 0x2(%rbx),%eax
  4101e7:	66 c1 c8 08          	ror    $0x8,%ax
  4101eb:	0f b7 c0             	movzwl %ax,%eax
  4101ee:	41 89 04 24          	mov    %eax,(%r12)
  4101f2:	eb 89                	jmp    41017d <_ZN6rocket10TcpWrapper16AcceptConnectionEiR11sockaddr_inPcRib+0x6d>
  4101f4:	e8 57 3d ff ff       	callq  403f50 <__stack_chk_fail@plt>
  4101f9:	90                   	nop
  4101fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000410200 <_ZN6rocket10TcpWrapper16AcceptConnectionEiR11sockaddr_in>:
  410200:	48 83 ec 18          	sub    $0x18,%rsp
  410204:	89 f7                	mov    %esi,%edi
  410206:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  41020d:	48 89 d6             	mov    %rdx,%rsi
  410210:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  410217:	00 
  410218:	48 8d 54 24 0c       	lea    0xc(%rsp),%rdx
  41021d:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%rsp)
  410224:	00 
  410225:	e8 96 3f ff ff       	callq  4041c0 <accept@plt>
  41022a:	48 83 c4 18          	add    $0x18,%rsp
  41022e:	c3                   	retq   
  41022f:	90                   	nop

0000000000410230 <_ZN6rocket10TcpWrapper14SetNonBlockingEi>:
  410230:	48 83 ec 08          	sub    $0x8,%rsp
  410234:	89 f7                	mov    %esi,%edi
  410236:	31 c0                	xor    %eax,%eax
  410238:	ba 00 08 00 00       	mov    $0x800,%edx
  41023d:	be 04 00 00 00       	mov    $0x4,%esi
  410242:	e8 e9 3f ff ff       	callq  404230 <fcntl@plt>
  410247:	85 c0                	test   %eax,%eax
  410249:	0f 94 c0             	sete   %al
  41024c:	48 83 c4 08          	add    $0x8,%rsp
  410250:	c3                   	retq   
  410251:	90                   	nop
  410252:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  410259:	1f 84 00 00 00 00 00 

0000000000410260 <_ZN6rocket10TcpWrapper12SetReuseAddrEi>:
  410260:	48 83 ec 18          	sub    $0x18,%rsp
  410264:	89 f7                	mov    %esi,%edi
  410266:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  41026c:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  410271:	ba 02 00 00 00       	mov    $0x2,%edx
  410276:	be 01 00 00 00       	mov    $0x1,%esi
  41027b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%rsp)
  410282:	00 
  410283:	e8 68 3a ff ff       	callq  403cf0 <setsockopt@plt>
  410288:	85 c0                	test   %eax,%eax
  41028a:	0f 94 c0             	sete   %al
  41028d:	48 83 c4 18          	add    $0x18,%rsp
  410291:	c3                   	retq   
  410292:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  410299:	1f 84 00 00 00 00 00 

00000000004102a0 <_ZN6rocket10TcpWrapper9SetLingerEii>:
  4102a0:	b8 01 00 00 00       	mov    $0x1,%eax
  4102a5:	c3                   	retq   
  4102a6:	90                   	nop
  4102a7:	90                   	nop
  4102a8:	90                   	nop
  4102a9:	90                   	nop
  4102aa:	90                   	nop
  4102ab:	90                   	nop
  4102ac:	90                   	nop
  4102ad:	90                   	nop
  4102ae:	90                   	nop
  4102af:	90                   	nop

00000000004102b0 <__libc_csu_init>:
  4102b0:	48 89 6c 24 d8       	mov    %rbp,-0x28(%rsp)
  4102b5:	4c 89 64 24 e0       	mov    %r12,-0x20(%rsp)
  4102ba:	48 8d 2d 57 36 20 00 	lea    0x203657(%rip),%rbp        # 613918 <__init_array_end>
  4102c1:	4c 8d 25 20 36 20 00 	lea    0x203620(%rip),%r12        # 6138e8 <__frame_dummy_init_array_entry>
  4102c8:	4c 89 6c 24 e8       	mov    %r13,-0x18(%rsp)
  4102cd:	4c 89 74 24 f0       	mov    %r14,-0x10(%rsp)
  4102d2:	4c 89 7c 24 f8       	mov    %r15,-0x8(%rsp)
  4102d7:	48 89 5c 24 d0       	mov    %rbx,-0x30(%rsp)
  4102dc:	48 83 ec 38          	sub    $0x38,%rsp
  4102e0:	4c 29 e5             	sub    %r12,%rbp
  4102e3:	41 89 fd             	mov    %edi,%r13d
  4102e6:	49 89 f6             	mov    %rsi,%r14
  4102e9:	48 c1 fd 03          	sar    $0x3,%rbp
  4102ed:	49 89 d7             	mov    %rdx,%r15
  4102f0:	e8 3b 37 ff ff       	callq  403a30 <_init>
  4102f5:	48 85 ed             	test   %rbp,%rbp
  4102f8:	74 1c                	je     410316 <__libc_csu_init+0x66>
  4102fa:	31 db                	xor    %ebx,%ebx
  4102fc:	0f 1f 40 00          	nopl   0x0(%rax)
  410300:	4c 89 fa             	mov    %r15,%rdx
  410303:	4c 89 f6             	mov    %r14,%rsi
  410306:	44 89 ef             	mov    %r13d,%edi
  410309:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  41030d:	48 83 c3 01          	add    $0x1,%rbx
  410311:	48 39 eb             	cmp    %rbp,%rbx
  410314:	75 ea                	jne    410300 <__libc_csu_init+0x50>
  410316:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  41031b:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp
  410320:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  410325:	4c 8b 6c 24 20       	mov    0x20(%rsp),%r13
  41032a:	4c 8b 74 24 28       	mov    0x28(%rsp),%r14
  41032f:	4c 8b 7c 24 30       	mov    0x30(%rsp),%r15
  410334:	48 83 c4 38          	add    $0x38,%rsp
  410338:	c3                   	retq   
  410339:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000410340 <__libc_csu_fini>:
  410340:	f3 c3                	repz retq 
  410342:	90                   	nop
  410343:	90                   	nop

Disassembly of section .fini:

0000000000410344 <_fini>:
  410344:	48 83 ec 08          	sub    $0x8,%rsp
  410348:	48 83 c4 08          	add    $0x8,%rsp
  41034c:	c3                   	retq   
